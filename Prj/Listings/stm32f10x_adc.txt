; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_adc.crf ..\Chip\Hal_lib\stm32f10x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;1081     */
;;;1082   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  b570              PUSH     {r4-r6,lr}
;;;1083   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1084     uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  4917              LDR      r1,|L1.104|
00000a  428d              CMP      r5,r1
00000c  d005              BEQ      |L1.26|
00000e  4917              LDR      r1,|L1.108|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L1.26|
000014  4916              LDR      r1,|L1.112|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L1.30|
                  |L1.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  2100              MOVS     r1,#0
                  |L1.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1087     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
000026  4913              LDR      r1,|L1.116|
000028  428c              CMP      r4,r1
00002a  d00f              BEQ      |L1.76|
00002c  4912              LDR      r1,|L1.120|
00002e  428c              CMP      r4,r1
000030  d00c              BEQ      |L1.76|
000032  4912              LDR      r1,|L1.124|
000034  428c              CMP      r4,r1
000036  d009              BEQ      |L1.76|
000038  f5b40f00          CMP      r4,#0x800000
00003c  d006              BEQ      |L1.76|
00003e  f5b40f80          CMP      r4,#0x400000
000042  d003              BEQ      |L1.76|
000044  f5b40f40          CMP      r4,#0xc00000
000048  d000              BEQ      |L1.76|
00004a  b90c              CBNZ     r4,|L1.80|
                  |L1.76|
00004c  2101              MOVS     r1,#1
00004e  e000              B        |L1.82|
                  |L1.80|
000050  2100              MOVS     r1,#0
                  |L1.82|
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       assert_param
;;;1088     /* Get the old register value */
;;;1089     tmpreg = ADCx->CR1;
000058  686e              LDR      r6,[r5,#4]
;;;1090     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1091     tmpreg &= CR1_AWDMode_Reset;
00005a  4808              LDR      r0,|L1.124|
00005c  43c0              MVNS     r0,r0
00005e  4006              ANDS     r6,r6,r0
;;;1092     /* Set the analog watchdog enable mode */
;;;1093     tmpreg |= ADC_AnalogWatchdog;
000060  4326              ORRS     r6,r6,r4
;;;1094     /* Store the new register value */
;;;1095     ADCx->CR1 = tmpreg;
000062  606e              STR      r6,[r5,#4]
;;;1096   }
000064  bd70              POP      {r4-r6,pc}
;;;1097   
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      0x40012400
                  |L1.108|
                          DCD      0x40012800
                  |L1.112|
                          DCD      0x40013c00
                  |L1.116|
                          DCD      0x00800200
                  |L1.120|
                          DCD      0x00400200
                  |L1.124|
                          DCD      0x00c00200

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1144     */
;;;1145   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1146   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1147     uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;1148     /* Check the parameters */
;;;1149     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  491e              LDR      r1,|L2.132|
00000a  428d              CMP      r5,r1
00000c  d005              BEQ      |L2.26|
00000e  491e              LDR      r1,|L2.136|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L2.26|
000014  491d              LDR      r1,|L2.140|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L2.30|
                  |L2.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L2.32|
                  |L2.30|
00001e  2100              MOVS     r1,#0
                  |L2.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1150     assert_param(IS_ADC_CHANNEL(ADC_Channel));
000026  b30c              CBZ      r4,|L2.108|
000028  2c01              CMP      r4,#1
00002a  d01f              BEQ      |L2.108|
00002c  2c02              CMP      r4,#2
00002e  d01d              BEQ      |L2.108|
000030  2c03              CMP      r4,#3
000032  d01b              BEQ      |L2.108|
000034  2c04              CMP      r4,#4
000036  d019              BEQ      |L2.108|
000038  2c05              CMP      r4,#5
00003a  d017              BEQ      |L2.108|
00003c  2c06              CMP      r4,#6
00003e  d015              BEQ      |L2.108|
000040  2c07              CMP      r4,#7
000042  d013              BEQ      |L2.108|
000044  2c08              CMP      r4,#8
000046  d011              BEQ      |L2.108|
000048  2c09              CMP      r4,#9
00004a  d00f              BEQ      |L2.108|
00004c  2c0a              CMP      r4,#0xa
00004e  d00d              BEQ      |L2.108|
000050  2c0b              CMP      r4,#0xb
000052  d00b              BEQ      |L2.108|
000054  2c0c              CMP      r4,#0xc
000056  d009              BEQ      |L2.108|
000058  2c0d              CMP      r4,#0xd
00005a  d007              BEQ      |L2.108|
00005c  2c0e              CMP      r4,#0xe
00005e  d005              BEQ      |L2.108|
000060  2c0f              CMP      r4,#0xf
000062  d003              BEQ      |L2.108|
000064  2c10              CMP      r4,#0x10
000066  d001              BEQ      |L2.108|
000068  2c11              CMP      r4,#0x11
00006a  d101              BNE      |L2.112|
                  |L2.108|
00006c  2101              MOVS     r1,#1
00006e  e000              B        |L2.114|
                  |L2.112|
000070  2100              MOVS     r1,#0
                  |L2.114|
000072  4608              MOV      r0,r1
000074  f7fffffe          BL       assert_param
;;;1151     /* Get the old register value */
;;;1152     tmpreg = ADCx->CR1;
000078  686e              LDR      r6,[r5,#4]
;;;1153     /* Clear the Analog watchdog channel select bits */
;;;1154     tmpreg &= CR1_AWDCH_Reset;
00007a  f026061f          BIC      r6,r6,#0x1f
;;;1155     /* Set the Analog watchdog channel */
;;;1156     tmpreg |= ADC_Channel;
00007e  4326              ORRS     r6,r6,r4
;;;1157     /* Store the new register value */
;;;1158     ADCx->CR1 = tmpreg;
000080  606e              STR      r6,[r5,#4]
;;;1159   }
000082  bd70              POP      {r4-r6,pc}
;;;1160   
                          ENDP

                  |L2.132|
                          DCD      0x40012400
                  |L2.136|
                          DCD      0x40012800
                  |L2.140|
                          DCD      0x40013c00

                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1106     */
;;;1107   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  b570              PUSH     {r4-r6,lr}
;;;1108                                           uint16_t LowThreshold)
;;;1109   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  4911              LDR      r1,|L3.80|
00000a  428c              CMP      r4,r1
00000c  d005              BEQ      |L3.26|
00000e  4911              LDR      r1,|L3.84|
000010  428c              CMP      r4,r1
000012  d002              BEQ      |L3.26|
000014  4910              LDR      r1,|L3.88|
000016  428c              CMP      r4,r1
000018  d101              BNE      |L3.30|
                  |L3.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L3.32|
                  |L3.30|
00001e  2100              MOVS     r1,#0
                  |L3.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1112     assert_param(IS_ADC_THRESHOLD(HighThreshold));
000026  f5b55f80          CMP      r5,#0x1000
00002a  da01              BGE      |L3.48|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L3.50|
                  |L3.48|
000030  2100              MOVS     r1,#0
                  |L3.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;1113     assert_param(IS_ADC_THRESHOLD(LowThreshold));
000038  f5b65f80          CMP      r6,#0x1000
00003c  da01              BGE      |L3.66|
00003e  2101              MOVS     r1,#1
000040  e000              B        |L3.68|
                  |L3.66|
000042  2100              MOVS     r1,#0
                  |L3.68|
000044  4608              MOV      r0,r1
000046  f7fffffe          BL       assert_param
;;;1114     /* Set the ADCx high threshold */
;;;1115     ADCx->HTR = HighThreshold;
00004a  6265              STR      r5,[r4,#0x24]
;;;1116     /* Set the ADCx low threshold */
;;;1117     ADCx->LTR = LowThreshold;
00004c  62a6              STR      r6,[r4,#0x28]
;;;1118   }
00004e  bd70              POP      {r4-r6,pc}
;;;1119   
                          ENDP

                  |L3.80|
                          DCD      0x40012400
                  |L3.84|
                          DCD      0x40012800
                  |L3.88|
                          DCD      0x40013c00

                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_AutoInjectedConvCmd PROC
;;;733      */
;;;734    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;735    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;736      /* Check the parameters */
;;;737      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L4.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L4.24|
00000c  4910              LDR      r1,|L4.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L4.24|
000012  4910              LDR      r1,|L4.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L4.28|
                  |L4.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  2100              MOVS     r1,#0
                  |L4.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;738      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L4.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L4.46|
                  |L4.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L4.48|
                  |L4.46|
00002e  2100              MOVS     r1,#0
                  |L4.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;739      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L4.66|
;;;740      {
;;;741        /* Enable the selected ADC automatic injected group conversion */
;;;742        ADCx->CR1 |= CR1_JAUTO_Set;
000038  6860              LDR      r0,[r4,#4]
00003a  f4406080          ORR      r0,r0,#0x400
00003e  6060              STR      r0,[r4,#4]
000040  e003              B        |L4.74|
                  |L4.66|
;;;743      }
;;;744      else
;;;745      {
;;;746        /* Disable the selected ADC automatic injected group conversion */
;;;747        ADCx->CR1 &= CR1_JAUTO_Reset;
000042  6860              LDR      r0,[r4,#4]
000044  f4206080          BIC      r0,r0,#0x400
000048  6060              STR      r0,[r4,#4]
                  |L4.74|
;;;748      }
;;;749    }
00004a  bd70              POP      {r4-r6,pc}
;;;750    
                          ENDP

                  |L4.76|
                          DCD      0x40012400
                  |L4.80|
                          DCD      0x40012800
                  |L4.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=2

                  ADC_ClearFlag PROC
;;;1227     */
;;;1228   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1229   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  490e              LDR      r1,|L5.64|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L5.24|
00000c  490d              LDR      r1,|L5.68|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L5.24|
000012  490d              LDR      r1,|L5.72|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L5.28|
                  |L5.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L5.30|
                  |L5.28|
00001c  2100              MOVS     r1,#0
                  |L5.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;1232     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
000024  f00501e0          AND      r1,r5,#0xe0
000028  b911              CBNZ     r1,|L5.48|
00002a  b10d              CBZ      r5,|L5.48|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L5.50|
                  |L5.48|
000030  2100              MOVS     r1,#0
                  |L5.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;1233     /* Clear the selected ADC flags */
;;;1234     ADCx->SR = ~(uint32_t)ADC_FLAG;
000038  43e8              MVNS     r0,r5
00003a  6020              STR      r0,[r4,#0]
;;;1235   }
00003c  bd70              POP      {r4-r6,pc}
;;;1236   
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40012400
                  |L5.68|
                          DCD      0x40012800
                  |L5.72|
                          DCD      0x40013c00

                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  ADC_ClearITPendingBit PROC
;;;1282     */
;;;1283   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1284   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1285     uint8_t itmask = 0;
000006  2600              MOVS     r6,#0
;;;1286     /* Check the parameters */
;;;1287     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  490e              LDR      r1,|L6.68|
00000a  428c              CMP      r4,r1
00000c  d005              BEQ      |L6.26|
00000e  490e              LDR      r1,|L6.72|
000010  428c              CMP      r4,r1
000012  d002              BEQ      |L6.26|
000014  490d              LDR      r1,|L6.76|
000016  428c              CMP      r4,r1
000018  d101              BNE      |L6.30|
                  |L6.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L6.32|
                  |L6.30|
00001e  2100              MOVS     r1,#0
                  |L6.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1288     assert_param(IS_ADC_IT(ADC_IT));
000026  f64f011f          MOV      r1,#0xf81f
00002a  4029              ANDS     r1,r1,r5
00002c  b911              CBNZ     r1,|L6.52|
00002e  b10d              CBZ      r5,|L6.52|
000030  2101              MOVS     r1,#1
000032  e000              B        |L6.54|
                  |L6.52|
000034  2100              MOVS     r1,#0
                  |L6.54|
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       assert_param
;;;1289     /* Get the ADC IT index */
;;;1290     itmask = (uint8_t)(ADC_IT >> 8);
00003c  122e              ASRS     r6,r5,#8
;;;1291     /* Clear the selected ADC interrupt pending bits */
;;;1292     ADCx->SR = ~(uint32_t)itmask;
00003e  43f0              MVNS     r0,r6
000040  6020              STR      r0,[r4,#0]
;;;1293   }
000042  bd70              POP      {r4-r6,pc}
;;;1294   
                          ENDP

                  |L6.68|
                          DCD      0x40012400
                  |L6.72|
                          DCD      0x40012800
                  |L6.76|
                          DCD      0x40013c00

                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=2

                  ADC_Cmd PROC
;;;298      */
;;;299    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;300    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;301      /* Check the parameters */
;;;302      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L7.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L7.24|
00000c  4910              LDR      r1,|L7.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L7.24|
000012  4910              LDR      r1,|L7.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L7.28|
                  |L7.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L7.30|
                  |L7.28|
00001c  2100              MOVS     r1,#0
                  |L7.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;303      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L7.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L7.46|
                  |L7.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L7.48|
                  |L7.46|
00002e  2100              MOVS     r1,#0
                  |L7.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;304      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L7.66|
;;;305      {
;;;306        /* Set the ADON bit to wake up the ADC from power down mode */
;;;307        ADCx->CR2 |= CR2_ADON_Set;
000038  68a0              LDR      r0,[r4,#8]
00003a  f0400001          ORR      r0,r0,#1
00003e  60a0              STR      r0,[r4,#8]
000040  e003              B        |L7.74|
                  |L7.66|
;;;308      }
;;;309      else
;;;310      {
;;;311        /* Disable the selected ADC peripheral */
;;;312        ADCx->CR2 &= CR2_ADON_Reset;
000042  68a0              LDR      r0,[r4,#8]
000044  f0200001          BIC      r0,r0,#1
000048  60a0              STR      r0,[r4,#8]
                  |L7.74|
;;;313      }
;;;314    }
00004a  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP

                  |L7.76|
                          DCD      0x40012400
                  |L7.80|
                          DCD      0x40012800
                  |L7.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=2

                  ADC_DMACmd PROC
;;;323      */
;;;324    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;326      /* Check the parameters */
;;;327      assert_param(IS_ADC_DMA_PERIPH(ADCx));
000006  4910              LDR      r1,|L8.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L8.18|
00000c  490f              LDR      r1,|L8.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L8.22|
                  |L8.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L8.24|
                  |L8.22|
000016  2100              MOVS     r1,#0
                  |L8.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;328      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L8.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L8.40|
                  |L8.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L8.42|
                  |L8.40|
000028  2100              MOVS     r1,#0
                  |L8.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;329      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L8.60|
;;;330      {
;;;331        /* Enable the selected ADC DMA request */
;;;332        ADCx->CR2 |= CR2_DMA_Set;
000032  68a0              LDR      r0,[r4,#8]
000034  f4407080          ORR      r0,r0,#0x100
000038  60a0              STR      r0,[r4,#8]
00003a  e003              B        |L8.68|
                  |L8.60|
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Disable the selected ADC DMA request */
;;;337        ADCx->CR2 &= CR2_DMA_Reset;
00003c  68a0              LDR      r0,[r4,#8]
00003e  f4207080          BIC      r0,r0,#0x100
000042  60a0              STR      r0,[r4,#8]
                  |L8.68|
;;;338      }
;;;339    }
000044  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      0x40012400
                  |L8.76|
                          DCD      0x40013c00

                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;178      */
;;;179    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;180    {
000002  4604              MOV      r4,r0
;;;181      /* Check the parameters */
;;;182      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4919              LDR      r1,|L9.108|
000006  428c              CMP      r4,r1
000008  d005              BEQ      |L9.22|
00000a  4919              LDR      r1,|L9.112|
00000c  428c              CMP      r4,r1
00000e  d002              BEQ      |L9.22|
000010  4918              LDR      r1,|L9.116|
000012  428c              CMP      r4,r1
000014  d101              BNE      |L9.26|
                  |L9.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L9.28|
                  |L9.26|
00001a  2100              MOVS     r1,#0
                  |L9.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;183      
;;;184      if (ADCx == ADC1)
000022  4812              LDR      r0,|L9.108|
000024  4284              CMP      r4,r0
000026  d108              BNE      |L9.58|
;;;185      {
;;;186        /* Enable ADC1 reset state */
;;;187        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000028  2101              MOVS     r1,#1
00002a  1540              ASRS     r0,r0,#21
00002c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;188        /* Release ADC1 from reset state */
;;;189        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000030  2100              MOVS     r1,#0
000032  1560              ASRS     r0,r4,#21
000034  f7fffffe          BL       RCC_APB2PeriphResetCmd
000038  e017              B        |L9.106|
                  |L9.58|
;;;190      }
;;;191      else if (ADCx == ADC2)
00003a  480d              LDR      r0,|L9.112|
00003c  4284              CMP      r4,r0
00003e  d108              BNE      |L9.82|
;;;192      {
;;;193        /* Enable ADC2 reset state */
;;;194        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
000040  2101              MOVS     r1,#1
000042  1500              ASRS     r0,r0,#20
000044  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195        /* Release ADC2 from reset state */
;;;196        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
000048  2100              MOVS     r1,#0
00004a  1520              ASRS     r0,r4,#20
00004c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000050  e00b              B        |L9.106|
                  |L9.82|
;;;197      }
;;;198      else
;;;199      {
;;;200        if (ADCx == ADC3)
000052  4808              LDR      r0,|L9.116|
000054  4284              CMP      r4,r0
000056  d108              BNE      |L9.106|
;;;201        {
;;;202          /* Enable ADC3 reset state */
;;;203          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000058  2101              MOVS     r1,#1
00005a  03c8              LSLS     r0,r1,#15
00005c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;204          /* Release ADC3 from reset state */
;;;205          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000060  2100              MOVS     r1,#0
000062  f44f4000          MOV      r0,#0x8000
000066  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L9.106|
;;;206        }
;;;207      }
;;;208    }
00006a  bd10              POP      {r4,pc}
;;;209    
                          ENDP

                  |L9.108|
                          DCD      0x40012400
                  |L9.112|
                          DCD      0x40012800
                  |L9.116|
                          DCD      0x40013c00

                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=2

                  ADC_DiscModeChannelCountConfig PROC
;;;508      */
;;;509    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;510    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;511      uint32_t tmpreg1 = 0;
000008  2600              MOVS     r6,#0
;;;512      uint32_t tmpreg2 = 0;
00000a  2700              MOVS     r7,#0
;;;513      /* Check the parameters */
;;;514      assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000c  4910              LDR      r1,|L10.80|
00000e  428c              CMP      r4,r1
000010  d005              BEQ      |L10.30|
000012  4910              LDR      r1,|L10.84|
000014  428c              CMP      r4,r1
000016  d002              BEQ      |L10.30|
000018  490f              LDR      r1,|L10.88|
00001a  428c              CMP      r4,r1
00001c  d101              BNE      |L10.34|
                  |L10.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L10.36|
                  |L10.34|
000022  2100              MOVS     r1,#0
                  |L10.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;515      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
00002a  2d01              CMP      r5,#1
00002c  db03              BLT      |L10.54|
00002e  2d08              CMP      r5,#8
000030  dc01              BGT      |L10.54|
000032  2101              MOVS     r1,#1
000034  e000              B        |L10.56|
                  |L10.54|
000036  2100              MOVS     r1,#0
                  |L10.56|
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       assert_param
;;;516      /* Get the old register value */
;;;517      tmpreg1 = ADCx->CR1;
00003e  6866              LDR      r6,[r4,#4]
;;;518      /* Clear the old discontinuous mode channel count */
;;;519      tmpreg1 &= CR1_DISCNUM_Reset;
000040  f4264660          BIC      r6,r6,#0xe000
;;;520      /* Set the discontinuous mode channel count */
;;;521      tmpreg2 = Number - 1;
000044  1e6f              SUBS     r7,r5,#1
;;;522      tmpreg1 |= tmpreg2 << 13;
000046  ea463647          ORR      r6,r6,r7,LSL #13
;;;523      /* Store the new register value */
;;;524      ADCx->CR1 = tmpreg1;
00004a  6066              STR      r6,[r4,#4]
;;;525    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;526    
                          ENDP

                  |L10.80|
                          DCD      0x40012400
                  |L10.84|
                          DCD      0x40012800
                  |L10.88|
                          DCD      0x40013c00

                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=2

                  ADC_DiscModeCmd PROC
;;;535      */
;;;536    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;538      /* Check the parameters */
;;;539      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L11.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L11.24|
00000c  4910              LDR      r1,|L11.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L11.24|
000012  4910              LDR      r1,|L11.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L11.28|
                  |L11.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L11.30|
                  |L11.28|
00001c  2100              MOVS     r1,#0
                  |L11.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L11.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L11.46|
                  |L11.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L11.48|
                  |L11.46|
00002e  2100              MOVS     r1,#0
                  |L11.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;541      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L11.66|
;;;542      {
;;;543        /* Enable the selected ADC regular discontinuous mode */
;;;544        ADCx->CR1 |= CR1_DISCEN_Set;
000038  6860              LDR      r0,[r4,#4]
00003a  f4406000          ORR      r0,r0,#0x800
00003e  6060              STR      r0,[r4,#4]
000040  e003              B        |L11.74|
                  |L11.66|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected ADC regular discontinuous mode */
;;;549        ADCx->CR1 &= CR1_DISCEN_Reset;
000042  6860              LDR      r0,[r4,#4]
000044  f4206000          BIC      r0,r0,#0x800
000048  6060              STR      r0,[r4,#4]
                  |L11.74|
;;;550      }
;;;551    }
00004a  bd70              POP      {r4-r6,pc}
;;;552    
                          ENDP

                  |L11.76|
                          DCD      0x40012400
                  |L11.80|
                          DCD      0x40012800
                  |L11.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_ExternalTrigConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_ExternalTrigConvCmd PROC
;;;685      */
;;;686    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;687    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;688      /* Check the parameters */
;;;689      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L12.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L12.24|
00000c  4910              LDR      r1,|L12.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L12.24|
000012  4910              LDR      r1,|L12.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L12.28|
                  |L12.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L12.30|
                  |L12.28|
00001c  2100              MOVS     r1,#0
                  |L12.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;690      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L12.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L12.46|
                  |L12.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L12.48|
                  |L12.46|
00002e  2100              MOVS     r1,#0
                  |L12.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;691      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L12.66|
;;;692      {
;;;693        /* Enable the selected ADC conversion on external event */
;;;694        ADCx->CR2 |= CR2_EXTTRIG_Set;
000038  68a0              LDR      r0,[r4,#8]
00003a  f4401080          ORR      r0,r0,#0x100000
00003e  60a0              STR      r0,[r4,#8]
000040  e003              B        |L12.74|
                  |L12.66|
;;;695      }
;;;696      else
;;;697      {
;;;698        /* Disable the selected ADC conversion on external event */
;;;699        ADCx->CR2 &= CR2_EXTTRIG_Reset;
000042  68a0              LDR      r0,[r4,#8]
000044  f4201080          BIC      r0,r0,#0x100000
000048  60a0              STR      r0,[r4,#8]
                  |L12.74|
;;;700      }
;;;701    }
00004a  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

                  |L12.76|
                          DCD      0x40012400
                  |L12.80|
                          DCD      0x40012800
                  |L12.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_ExternalTrigInjectedConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;823      */
;;;824    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;825    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;826      /* Check the parameters */
;;;827      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L13.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L13.24|
00000c  4910              LDR      r1,|L13.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L13.24|
000012  4910              LDR      r1,|L13.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L13.28|
                  |L13.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L13.30|
                  |L13.28|
00001c  2100              MOVS     r1,#0
                  |L13.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;828      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L13.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L13.46|
                  |L13.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L13.48|
                  |L13.46|
00002e  2100              MOVS     r1,#0
                  |L13.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;829      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L13.66|
;;;830      {
;;;831        /* Enable the selected ADC external event selection for injected group */
;;;832        ADCx->CR2 |= CR2_JEXTTRIG_Set;
000038  68a0              LDR      r0,[r4,#8]
00003a  f4404000          ORR      r0,r0,#0x8000
00003e  60a0              STR      r0,[r4,#8]
000040  e003              B        |L13.74|
                  |L13.66|
;;;833      }
;;;834      else
;;;835      {
;;;836        /* Disable the selected ADC external event selection for injected group */
;;;837        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
000042  68a0              LDR      r0,[r4,#8]
000044  f4204000          BIC      r0,r0,#0x8000
000048  60a0              STR      r0,[r4,#8]
                  |L13.74|
;;;838      }
;;;839    }
00004a  bd70              POP      {r4-r6,pc}
;;;840    
                          ENDP

                  |L13.76|
                          DCD      0x40012400
                  |L13.80|
                          DCD      0x40012800
                  |L13.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=2

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;798      */
;;;799    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  b570              PUSH     {r4-r6,lr}
;;;800    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;801      uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;802      /* Check the parameters */
;;;803      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  491f              LDR      r1,|L14.136|
00000a  428d              CMP      r5,r1
00000c  d005              BEQ      |L14.26|
00000e  491f              LDR      r1,|L14.140|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L14.26|
000014  491e              LDR      r1,|L14.144|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L14.30|
                  |L14.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L14.32|
                  |L14.30|
00001e  2100              MOVS     r1,#0
                  |L14.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;804      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
000026  b31c              CBZ      r4,|L14.112|
000028  f5b45f80          CMP      r4,#0x1000
00002c  d020              BEQ      |L14.112|
00002e  f5b45f00          CMP      r4,#0x2000
000032  d01d              BEQ      |L14.112|
000034  f5b45f40          CMP      r4,#0x3000
000038  d01a              BEQ      |L14.112|
00003a  f5b44f80          CMP      r4,#0x4000
00003e  d017              BEQ      |L14.112|
000040  f5b44fa0          CMP      r4,#0x5000
000044  d014              BEQ      |L14.112|
000046  f5b44fc0          CMP      r4,#0x6000
00004a  d011              BEQ      |L14.112|
00004c  f5b44fe0          CMP      r4,#0x7000
000050  d00e              BEQ      |L14.112|
000052  f5b45f00          CMP      r4,#0x2000
000056  d00b              BEQ      |L14.112|
000058  f5b45f40          CMP      r4,#0x3000
00005c  d008              BEQ      |L14.112|
00005e  f5b44f80          CMP      r4,#0x4000
000062  d005              BEQ      |L14.112|
000064  f5b44fa0          CMP      r4,#0x5000
000068  d002              BEQ      |L14.112|
00006a  f5b44fc0          CMP      r4,#0x6000
00006e  d101              BNE      |L14.116|
                  |L14.112|
000070  2101              MOVS     r1,#1
000072  e000              B        |L14.118|
                  |L14.116|
000074  2100              MOVS     r1,#0
                  |L14.118|
000076  4608              MOV      r0,r1
000078  f7fffffe          BL       assert_param
;;;805      /* Get the old register value */
;;;806      tmpreg = ADCx->CR2;
00007c  68ae              LDR      r6,[r5,#8]
;;;807      /* Clear the old external event selection for injected group */
;;;808      tmpreg &= CR2_JEXTSEL_Reset;
00007e  f42646e0          BIC      r6,r6,#0x7000
;;;809      /* Set the external event selection for injected group */
;;;810      tmpreg |= ADC_ExternalTrigInjecConv;
000082  4326              ORRS     r6,r6,r4
;;;811      /* Store the new register value */
;;;812      ADCx->CR2 = tmpreg;
000084  60ae              STR      r6,[r5,#8]
;;;813    }
000086  bd70              POP      {r4-r6,pc}
;;;814    
                          ENDP

                  |L14.136|
                          DCD      0x40012400
                  |L14.140|
                          DCD      0x40012800
                  |L14.144|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetCalibrationStatus PROC
;;;429      */
;;;430    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;431    {
000002  4604              MOV      r4,r0
;;;432      FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;433      /* Check the parameters */
;;;434      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  490c              LDR      r1,|L15.56|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L15.24|
00000c  490b              LDR      r1,|L15.60|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L15.24|
000012  490b              LDR      r1,|L15.64|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L15.28|
                  |L15.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L15.30|
                  |L15.28|
00001c  2100              MOVS     r1,#0
                  |L15.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;435      /* Check the status of CAL bit */
;;;436      if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
000024  68a0              LDR      r0,[r4,#8]
000026  f0000004          AND      r0,r0,#4
00002a  b108              CBZ      r0,|L15.48|
;;;437      {
;;;438        /* CAL bit is set: calibration on going */
;;;439        bitstatus = SET;
00002c  2501              MOVS     r5,#1
00002e  e000              B        |L15.50|
                  |L15.48|
;;;440      }
;;;441      else
;;;442      {
;;;443        /* CAL bit is reset: end of calibration */
;;;444        bitstatus = RESET;
000030  2500              MOVS     r5,#0
                  |L15.50|
;;;445      }
;;;446      /* Return the CAL bit status */
;;;447      return  bitstatus;
000032  4628              MOV      r0,r5
;;;448    }
000034  bd70              POP      {r4-r6,pc}
;;;449    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x40012400
                  |L15.60|
                          DCD      0x40012800
                  |L15.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetConversionValue PROC
;;;707      */
;;;708    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;709    {
000002  4604              MOV      r4,r0
;;;710      /* Check the parameters */
;;;711      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4908              LDR      r1,|L16.40|
000006  428c              CMP      r4,r1
000008  d005              BEQ      |L16.22|
00000a  4908              LDR      r1,|L16.44|
00000c  428c              CMP      r4,r1
00000e  d002              BEQ      |L16.22|
000010  4907              LDR      r1,|L16.48|
000012  428c              CMP      r4,r1
000014  d101              BNE      |L16.26|
                  |L16.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L16.28|
                  |L16.26|
00001a  2100              MOVS     r1,#0
                  |L16.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;712      /* Return the selected ADC conversion value */
;;;713      return (uint16_t) ADCx->DR;
000022  6ce0              LDR      r0,[r4,#0x4c]
000024  b280              UXTH     r0,r0
;;;714    }
000026  bd10              POP      {r4,pc}
;;;715    
                          ENDP

                  |L16.40|
                          DCD      0x40012400
                  |L16.44|
                          DCD      0x40012800
                  |L16.48|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;719      */
;;;720    uint32_t ADC_GetDualModeConversionValue(void)
000000  4801              LDR      r0,|L17.8|
;;;721    {
;;;722      /* Return the dual mode conversion value */
;;;723      return (*(__IO uint32_t *) DR_ADDRESS);
000002  6800              LDR      r0,[r0,#0]
;;;724    }
000004  4770              BX       lr
;;;725    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x4001244c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetFlagStatus PROC
;;;1194     */
;;;1195   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1196   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1197     FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;1198     /* Check the parameters */
;;;1199     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000008  4913              LDR      r1,|L18.88|
00000a  428d              CMP      r5,r1
00000c  d005              BEQ      |L18.26|
00000e  4913              LDR      r1,|L18.92|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L18.26|
000014  4912              LDR      r1,|L18.96|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L18.30|
                  |L18.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L18.32|
                  |L18.30|
00001e  2100              MOVS     r1,#0
                  |L18.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1200     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
000026  2c01              CMP      r4,#1
000028  d007              BEQ      |L18.58|
00002a  2c02              CMP      r4,#2
00002c  d005              BEQ      |L18.58|
00002e  2c04              CMP      r4,#4
000030  d003              BEQ      |L18.58|
000032  2c08              CMP      r4,#8
000034  d001              BEQ      |L18.58|
000036  2c10              CMP      r4,#0x10
000038  d101              BNE      |L18.62|
                  |L18.58|
00003a  2101              MOVS     r1,#1
00003c  e000              B        |L18.64|
                  |L18.62|
00003e  2100              MOVS     r1,#0
                  |L18.64|
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       assert_param
;;;1201     /* Check the status of the specified ADC flag */
;;;1202     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000046  6828              LDR      r0,[r5,#0]
000048  4020              ANDS     r0,r0,r4
00004a  b108              CBZ      r0,|L18.80|
;;;1203     {
;;;1204       /* ADC_FLAG is set */
;;;1205       bitstatus = SET;
00004c  2601              MOVS     r6,#1
00004e  e000              B        |L18.82|
                  |L18.80|
;;;1206     }
;;;1207     else
;;;1208     {
;;;1209       /* ADC_FLAG is reset */
;;;1210       bitstatus = RESET;
000050  2600              MOVS     r6,#0
                  |L18.82|
;;;1211     }
;;;1212     /* Return the ADC_FLAG status */
;;;1213     return  bitstatus;
000052  4630              MOV      r0,r6
;;;1214   }
000054  bd70              POP      {r4-r6,pc}
;;;1215   
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      0x40012400
                  |L18.92|
                          DCD      0x40012800
                  |L18.96|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetITStatus PROC
;;;1246     */
;;;1247   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1248   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1249     ITStatus bitstatus = RESET;
000008  2600              MOVS     r6,#0
;;;1250     uint32_t itmask = 0, enablestatus = 0;
00000a  2700              MOVS     r7,#0
00000c  46b0              MOV      r8,r6
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000e  4917              LDR      r1,|L19.108|
000010  428c              CMP      r4,r1
000012  d005              BEQ      |L19.32|
000014  4916              LDR      r1,|L19.112|
000016  428c              CMP      r4,r1
000018  d002              BEQ      |L19.32|
00001a  4916              LDR      r1,|L19.116|
00001c  428c              CMP      r4,r1
00001e  d101              BNE      |L19.36|
                  |L19.32|
000020  2101              MOVS     r1,#1
000022  e000              B        |L19.38|
                  |L19.36|
000024  2100              MOVS     r1,#0
                  |L19.38|
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       assert_param
;;;1253     assert_param(IS_ADC_GET_IT(ADC_IT));
00002c  f5b57f08          CMP      r5,#0x220
000030  d005              BEQ      |L19.62|
000032  f5b57fa0          CMP      r5,#0x140
000036  d002              BEQ      |L19.62|
000038  f5b56f90          CMP      r5,#0x480
00003c  d101              BNE      |L19.66|
                  |L19.62|
00003e  2101              MOVS     r1,#1
000040  e000              B        |L19.68|
                  |L19.66|
000042  2100              MOVS     r1,#0
                  |L19.68|
000044  4608              MOV      r0,r1
000046  f7fffffe          BL       assert_param
;;;1254     /* Get the ADC IT index */
;;;1255     itmask = ADC_IT >> 8;
00004a  122f              ASRS     r7,r5,#8
;;;1256     /* Get the ADC_IT enable bit status */
;;;1257     enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
00004c  6860              LDR      r0,[r4,#4]
00004e  b2e9              UXTB     r1,r5
000050  ea000801          AND      r8,r0,r1
;;;1258     /* Check the status of the specified ADC interrupt */
;;;1259     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
000054  6820              LDR      r0,[r4,#0]
000056  4038              ANDS     r0,r0,r7
000058  b120              CBZ      r0,|L19.100|
00005a  f1b80f00          CMP      r8,#0
00005e  d001              BEQ      |L19.100|
;;;1260     {
;;;1261       /* ADC_IT is set */
;;;1262       bitstatus = SET;
000060  2601              MOVS     r6,#1
000062  e000              B        |L19.102|
                  |L19.100|
;;;1263     }
;;;1264     else
;;;1265     {
;;;1266       /* ADC_IT is reset */
;;;1267       bitstatus = RESET;
000064  2600              MOVS     r6,#0
                  |L19.102|
;;;1268     }
;;;1269     /* Return the ADC_IT status */
;;;1270     return  bitstatus;
000066  4630              MOV      r0,r6
;;;1271   }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;1272   
                          ENDP

                  |L19.108|
                          DCD      0x40012400
                  |L19.112|
                          DCD      0x40012800
                  |L19.116|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetInjectedConversionValue PROC
;;;1051     */
;;;1052   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b538              PUSH     {r3-r5,lr}
;;;1053   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1054     __IO uint32_t tmp = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1055     
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000a  4913              LDR      r1,|L20.88|
00000c  428d              CMP      r5,r1
00000e  d005              BEQ      |L20.28|
000010  4912              LDR      r1,|L20.92|
000012  428d              CMP      r5,r1
000014  d002              BEQ      |L20.28|
000016  4912              LDR      r1,|L20.96|
000018  428d              CMP      r5,r1
00001a  d101              BNE      |L20.32|
                  |L20.28|
00001c  2101              MOVS     r1,#1
00001e  e000              B        |L20.34|
                  |L20.32|
000020  2100              MOVS     r1,#0
                  |L20.34|
000022  4608              MOV      r0,r1
000024  f7fffffe          BL       assert_param
;;;1058     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
000028  2c14              CMP      r4,#0x14
00002a  d005              BEQ      |L20.56|
00002c  2c18              CMP      r4,#0x18
00002e  d003              BEQ      |L20.56|
000030  2c1c              CMP      r4,#0x1c
000032  d001              BEQ      |L20.56|
000034  2c20              CMP      r4,#0x20
000036  d101              BNE      |L20.60|
                  |L20.56|
000038  2101              MOVS     r1,#1
00003a  e000              B        |L20.62|
                  |L20.60|
00003c  2100              MOVS     r1,#0
                  |L20.62|
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       assert_param
;;;1059   
;;;1060     tmp = (uint32_t)ADCx;
000044  9500              STR      r5,[sp,#0]
;;;1061     tmp += ADC_InjectedChannel + JDR_Offset;
000046  f1040028          ADD      r0,r4,#0x28
00004a  9900              LDR      r1,[sp,#0]
00004c  4408              ADD      r0,r0,r1
00004e  9000              STR      r0,[sp,#0]
;;;1062     
;;;1063     /* Returns the selected injected channel conversion data value */
;;;1064     return (uint16_t) (*(__IO uint32_t*)  tmp);   
000050  9800              LDR      r0,[sp,#0]
000052  6800              LDR      r0,[r0,#0]
000054  b280              UXTH     r0,r0
;;;1065   }
000056  bd38              POP      {r3-r5,pc}
;;;1066   
                          ENDP

                  |L20.88|
                          DCD      0x40012400
                  |L20.92|
                          DCD      0x40012800
                  |L20.96|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetResetCalibrationStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetResetCalibrationStatus PROC
;;;391      */
;;;392    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;393    {
000002  4604              MOV      r4,r0
;;;394      FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;395      /* Check the parameters */
;;;396      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  490c              LDR      r1,|L21.56|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L21.24|
00000c  490b              LDR      r1,|L21.60|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L21.24|
000012  490b              LDR      r1,|L21.64|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L21.28|
                  |L21.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L21.30|
                  |L21.28|
00001c  2100              MOVS     r1,#0
                  |L21.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;397      /* Check the status of RSTCAL bit */
;;;398      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
000024  68a0              LDR      r0,[r4,#8]
000026  f0000008          AND      r0,r0,#8
00002a  b108              CBZ      r0,|L21.48|
;;;399      {
;;;400        /* RSTCAL bit is set */
;;;401        bitstatus = SET;
00002c  2501              MOVS     r5,#1
00002e  e000              B        |L21.50|
                  |L21.48|
;;;402      }
;;;403      else
;;;404      {
;;;405        /* RSTCAL bit is reset */
;;;406        bitstatus = RESET;
000030  2500              MOVS     r5,#0
                  |L21.50|
;;;407      }
;;;408      /* Return the RSTCAL bit status */
;;;409      return  bitstatus;
000032  4628              MOV      r0,r5
;;;410    }
000034  bd70              POP      {r4-r6,pc}
;;;411    
                          ENDP

000036  0000              DCW      0x0000
                  |L21.56|
                          DCD      0x40012400
                  |L21.60|
                          DCD      0x40012800
                  |L21.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetSoftwareStartConvStatus PROC
;;;480      */
;;;481    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4604              MOV      r4,r0
;;;483      FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;484      /* Check the parameters */
;;;485      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  490c              LDR      r1,|L22.56|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L22.24|
00000c  490b              LDR      r1,|L22.60|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L22.24|
000012  490b              LDR      r1,|L22.64|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L22.28|
                  |L22.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L22.30|
                  |L22.28|
00001c  2100              MOVS     r1,#0
                  |L22.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;486      /* Check the status of SWSTART bit */
;;;487      if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
000024  68a0              LDR      r0,[r4,#8]
000026  f4000080          AND      r0,r0,#0x400000
00002a  b108              CBZ      r0,|L22.48|
;;;488      {
;;;489        /* SWSTART bit is set */
;;;490        bitstatus = SET;
00002c  2501              MOVS     r5,#1
00002e  e000              B        |L22.50|
                  |L22.48|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* SWSTART bit is reset */
;;;495        bitstatus = RESET;
000030  2500              MOVS     r5,#0
                  |L22.50|
;;;496      }
;;;497      /* Return the SWSTART bit status */
;;;498      return  bitstatus;
000032  4628              MOV      r0,r5
;;;499    }
000034  bd70              POP      {r4-r6,pc}
;;;500    
                          ENDP

000036  0000              DCW      0x0000
                  |L22.56|
                          DCD      0x40012400
                  |L22.60|
                          DCD      0x40012800
                  |L22.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;872      */
;;;873    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  4604              MOV      r4,r0
;;;875      FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;876      /* Check the parameters */
;;;877      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  490c              LDR      r1,|L23.56|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L23.24|
00000c  490b              LDR      r1,|L23.60|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L23.24|
000012  490b              LDR      r1,|L23.64|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L23.28|
                  |L23.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L23.30|
                  |L23.28|
00001c  2100              MOVS     r1,#0
                  |L23.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;878      /* Check the status of JSWSTART bit */
;;;879      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
000024  68a0              LDR      r0,[r4,#8]
000026  f4001000          AND      r0,r0,#0x200000
00002a  b108              CBZ      r0,|L23.48|
;;;880      {
;;;881        /* JSWSTART bit is set */
;;;882        bitstatus = SET;
00002c  2501              MOVS     r5,#1
00002e  e000              B        |L23.50|
                  |L23.48|
;;;883      }
;;;884      else
;;;885      {
;;;886        /* JSWSTART bit is reset */
;;;887        bitstatus = RESET;
000030  2500              MOVS     r5,#0
                  |L23.50|
;;;888      }
;;;889      /* Return the JSWSTART bit status */
;;;890      return  bitstatus;
000032  4628              MOV      r0,r5
;;;891    }
000034  bd70              POP      {r4-r6,pc}
;;;892    
                          ENDP

000036  0000              DCW      0x0000
                  |L23.56|
                          DCD      0x40012400
                  |L23.60|
                          DCD      0x40012800
                  |L23.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC_ITConfig PROC
;;;352      */
;;;353    void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;354    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;355      uint8_t itmask = 0;
00000a  2700              MOVS     r7,#0
;;;356      /* Check the parameters */
;;;357      assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000c  4916              LDR      r1,|L24.104|
00000e  428c              CMP      r4,r1
000010  d005              BEQ      |L24.30|
000012  4916              LDR      r1,|L24.108|
000014  428c              CMP      r4,r1
000016  d002              BEQ      |L24.30|
000018  4915              LDR      r1,|L24.112|
00001a  428c              CMP      r4,r1
00001c  d101              BNE      |L24.34|
                  |L24.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L24.36|
                  |L24.34|
000022  2100              MOVS     r1,#0
                  |L24.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;358      assert_param(IS_FUNCTIONAL_STATE(NewState));
00002a  b10e              CBZ      r6,|L24.48|
00002c  2e01              CMP      r6,#1
00002e  d101              BNE      |L24.52|
                  |L24.48|
000030  2101              MOVS     r1,#1
000032  e000              B        |L24.54|
                  |L24.52|
000034  2100              MOVS     r1,#0
                  |L24.54|
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       assert_param
;;;359      assert_param(IS_ADC_IT(ADC_IT));
00003c  f64f011f          MOV      r1,#0xf81f
000040  4029              ANDS     r1,r1,r5
000042  b911              CBNZ     r1,|L24.74|
000044  b10d              CBZ      r5,|L24.74|
000046  2101              MOVS     r1,#1
000048  e000              B        |L24.76|
                  |L24.74|
00004a  2100              MOVS     r1,#0
                  |L24.76|
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       assert_param
;;;360      /* Get the ADC IT index */
;;;361      itmask = (uint8_t)ADC_IT;
000052  b2ef              UXTB     r7,r5
;;;362      if (NewState != DISABLE)
000054  b11e              CBZ      r6,|L24.94|
;;;363      {
;;;364        /* Enable the selected ADC interrupts */
;;;365        ADCx->CR1 |= itmask;
000056  6860              LDR      r0,[r4,#4]
000058  4338              ORRS     r0,r0,r7
00005a  6060              STR      r0,[r4,#4]
00005c  e002              B        |L24.100|
                  |L24.94|
;;;366      }
;;;367      else
;;;368      {
;;;369        /* Disable the selected ADC interrupts */
;;;370        ADCx->CR1 &= (~(uint32_t)itmask);
00005e  6860              LDR      r0,[r4,#4]
000060  43b8              BICS     r0,r0,r7
000062  6060              STR      r0,[r4,#4]
                  |L24.100|
;;;371      }
;;;372    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;373    
                          ENDP

                  |L24.104|
                          DCD      0x40012400
                  |L24.108|
                          DCD      0x40012800
                  |L24.112|
                          DCD      0x40013c00

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;217      */
;;;218    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;219    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;220      uint32_t tmpreg1 = 0;
000008  2600              MOVS     r6,#0
;;;221      uint8_t tmpreg2 = 0;
00000a  2700              MOVS     r7,#0
;;;222      /* Check the parameters */
;;;223      assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000c  4961              LDR      r1,|L25.404|
00000e  428d              CMP      r5,r1
000010  d005              BEQ      |L25.30|
000012  4961              LDR      r1,|L25.408|
000014  428d              CMP      r5,r1
000016  d002              BEQ      |L25.30|
000018  4960              LDR      r1,|L25.412|
00001a  428d              CMP      r5,r1
00001c  d101              BNE      |L25.34|
                  |L25.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L25.36|
                  |L25.34|
000022  2100              MOVS     r1,#0
                  |L25.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;224      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
00002a  6821              LDR      r1,[r4,#0]
00002c  b319              CBZ      r1,|L25.118|
00002e  6821              LDR      r1,[r4,#0]
000030  f5b13f80          CMP      r1,#0x10000
000034  d01f              BEQ      |L25.118|
000036  6821              LDR      r1,[r4,#0]
000038  f5b13f00          CMP      r1,#0x20000
00003c  d01b              BEQ      |L25.118|
00003e  6821              LDR      r1,[r4,#0]
000040  f5b13f40          CMP      r1,#0x30000
000044  d017              BEQ      |L25.118|
000046  6821              LDR      r1,[r4,#0]
000048  f5b12f80          CMP      r1,#0x40000
00004c  d013              BEQ      |L25.118|
00004e  6821              LDR      r1,[r4,#0]
000050  f5b12fa0          CMP      r1,#0x50000
000054  d00f              BEQ      |L25.118|
000056  6821              LDR      r1,[r4,#0]
000058  f5b12fc0          CMP      r1,#0x60000
00005c  d00b              BEQ      |L25.118|
00005e  6821              LDR      r1,[r4,#0]
000060  f5b12fe0          CMP      r1,#0x70000
000064  d007              BEQ      |L25.118|
000066  6821              LDR      r1,[r4,#0]
000068  f5b12f00          CMP      r1,#0x80000
00006c  d003              BEQ      |L25.118|
00006e  6821              LDR      r1,[r4,#0]
000070  f5b12f10          CMP      r1,#0x90000
000074  d101              BNE      |L25.122|
                  |L25.118|
000076  2101              MOVS     r1,#1
000078  e000              B        |L25.124|
                  |L25.122|
00007a  2100              MOVS     r1,#0
                  |L25.124|
00007c  4608              MOV      r0,r1
00007e  f7fffffe          BL       assert_param
;;;225      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
000082  7921              LDRB     r1,[r4,#4]
000084  b111              CBZ      r1,|L25.140|
000086  7921              LDRB     r1,[r4,#4]
000088  2901              CMP      r1,#1
00008a  d101              BNE      |L25.144|
                  |L25.140|
00008c  2101              MOVS     r1,#1
00008e  e000              B        |L25.146|
                  |L25.144|
000090  2100              MOVS     r1,#0
                  |L25.146|
000092  4608              MOV      r0,r1
000094  f7fffffe          BL       assert_param
;;;226      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
000098  7961              LDRB     r1,[r4,#5]
00009a  b111              CBZ      r1,|L25.162|
00009c  7961              LDRB     r1,[r4,#5]
00009e  2901              CMP      r1,#1
0000a0  d101              BNE      |L25.166|
                  |L25.162|
0000a2  2101              MOVS     r1,#1
0000a4  e000              B        |L25.168|
                  |L25.166|
0000a6  2100              MOVS     r1,#0
                  |L25.168|
0000a8  4608              MOV      r0,r1
0000aa  f7fffffe          BL       assert_param
;;;227      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
0000ae  68a1              LDR      r1,[r4,#8]
0000b0  b389              CBZ      r1,|L25.278|
0000b2  68a1              LDR      r1,[r4,#8]
0000b4  f5b13f00          CMP      r1,#0x20000
0000b8  d02d              BEQ      |L25.278|
0000ba  68a1              LDR      r1,[r4,#8]
0000bc  f5b12f80          CMP      r1,#0x40000
0000c0  d029              BEQ      |L25.278|
0000c2  68a1              LDR      r1,[r4,#8]
0000c4  f5b12fc0          CMP      r1,#0x60000
0000c8  d025              BEQ      |L25.278|
0000ca  68a1              LDR      r1,[r4,#8]
0000cc  f5b12f00          CMP      r1,#0x80000
0000d0  d021              BEQ      |L25.278|
0000d2  68a1              LDR      r1,[r4,#8]
0000d4  f5b12f20          CMP      r1,#0xa0000
0000d8  d01d              BEQ      |L25.278|
0000da  68a1              LDR      r1,[r4,#8]
0000dc  f5b12f40          CMP      r1,#0xc0000
0000e0  d019              BEQ      |L25.278|
0000e2  68a1              LDR      r1,[r4,#8]
0000e4  f5b12f60          CMP      r1,#0xe0000
0000e8  d015              BEQ      |L25.278|
0000ea  68a1              LDR      r1,[r4,#8]
0000ec  b199              CBZ      r1,|L25.278|
0000ee  68a1              LDR      r1,[r4,#8]
0000f0  f5b13f00          CMP      r1,#0x20000
0000f4  d00f              BEQ      |L25.278|
0000f6  68a1              LDR      r1,[r4,#8]
0000f8  f5b12fc0          CMP      r1,#0x60000
0000fc  d00b              BEQ      |L25.278|
0000fe  68a1              LDR      r1,[r4,#8]
000100  f5b12f00          CMP      r1,#0x80000
000104  d007              BEQ      |L25.278|
000106  68a1              LDR      r1,[r4,#8]
000108  f5b12f20          CMP      r1,#0xa0000
00010c  d003              BEQ      |L25.278|
00010e  68a1              LDR      r1,[r4,#8]
000110  f5b12f40          CMP      r1,#0xc0000
000114  d101              BNE      |L25.282|
                  |L25.278|
000116  2101              MOVS     r1,#1
000118  e000              B        |L25.284|
                  |L25.282|
00011a  2100              MOVS     r1,#0
                  |L25.284|
00011c  4608              MOV      r0,r1
00011e  f7fffffe          BL       assert_param
;;;228      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
000122  68e1              LDR      r1,[r4,#0xc]
000124  b119              CBZ      r1,|L25.302|
000126  68e1              LDR      r1,[r4,#0xc]
000128  f5b16f00          CMP      r1,#0x800
00012c  d101              BNE      |L25.306|
                  |L25.302|
00012e  2101              MOVS     r1,#1
000130  e000              B        |L25.308|
                  |L25.306|
000132  2100              MOVS     r1,#0
                  |L25.308|
000134  4608              MOV      r0,r1
000136  f7fffffe          BL       assert_param
;;;229      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
00013a  7c21              LDRB     r1,[r4,#0x10]
00013c  2901              CMP      r1,#1
00013e  db04              BLT      |L25.330|
000140  7c21              LDRB     r1,[r4,#0x10]
000142  2910              CMP      r1,#0x10
000144  dc01              BGT      |L25.330|
000146  2101              MOVS     r1,#1
000148  e000              B        |L25.332|
                  |L25.330|
00014a  2100              MOVS     r1,#0
                  |L25.332|
00014c  4608              MOV      r0,r1
00014e  f7fffffe          BL       assert_param
;;;230    
;;;231      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;232      /* Get the ADCx CR1 value */
;;;233      tmpreg1 = ADCx->CR1;
000152  686e              LDR      r6,[r5,#4]
;;;234      /* Clear DUALMOD and SCAN bits */
;;;235      tmpreg1 &= CR1_CLEAR_Mask;
000154  4812              LDR      r0,|L25.416|
000156  4006              ANDS     r6,r6,r0
;;;236      /* Configure ADCx: Dual mode and scan conversion mode */
;;;237      /* Set DUALMOD bits according to ADC_Mode value */
;;;238      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;239      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
000158  7921              LDRB     r1,[r4,#4]
00015a  6820              LDR      r0,[r4,#0]
00015c  ea402001          ORR      r0,r0,r1,LSL #8
000160  4306              ORRS     r6,r6,r0
;;;240      /* Write to ADCx CR1 */
;;;241      ADCx->CR1 = tmpreg1;
000162  606e              STR      r6,[r5,#4]
;;;242    
;;;243      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;244      /* Get the ADCx CR2 value */
;;;245      tmpreg1 = ADCx->CR2;
000164  68ae              LDR      r6,[r5,#8]
;;;246      /* Clear CONT, ALIGN and EXTSEL bits */
;;;247      tmpreg1 &= CR2_CLEAR_Mask;
000166  480f              LDR      r0,|L25.420|
000168  4006              ANDS     r6,r6,r0
;;;248      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;249      /* Set ALIGN bit according to ADC_DataAlign value */
;;;250      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;251      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;252      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00016a  e9d41002          LDRD     r1,r0,[r4,#8]
00016e  4308              ORRS     r0,r0,r1
000170  7961              LDRB     r1,[r4,#5]
000172  ea400041          ORR      r0,r0,r1,LSL #1
000176  4306              ORRS     r6,r6,r0
;;;253                ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;254      /* Write to ADCx CR2 */
;;;255      ADCx->CR2 = tmpreg1;
000178  60ae              STR      r6,[r5,#8]
;;;256    
;;;257      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;258      /* Get the ADCx SQR1 value */
;;;259      tmpreg1 = ADCx->SQR1;
00017a  6aee              LDR      r6,[r5,#0x2c]
;;;260      /* Clear L bits */
;;;261      tmpreg1 &= SQR1_CLEAR_Mask;
00017c  f4260670          BIC      r6,r6,#0xf00000
;;;262      /* Configure ADCx: regular channel sequence length */
;;;263      /* Set L bits according to ADC_NbrOfChannel value */
;;;264      tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
000180  7c20              LDRB     r0,[r4,#0x10]
000182  1e40              SUBS     r0,r0,#1
000184  b2c0              UXTB     r0,r0
000186  4307              ORRS     r7,r7,r0
;;;265      tmpreg1 |= (uint32_t)tmpreg2 << 20;
000188  ea465607          ORR      r6,r6,r7,LSL #20
;;;266      /* Write to ADCx SQR1 */
;;;267      ADCx->SQR1 = tmpreg1;
00018c  62ee              STR      r6,[r5,#0x2c]
;;;268    }
00018e  e8bd81f0          POP      {r4-r8,pc}
;;;269    
                          ENDP

000192  0000              DCW      0x0000
                  |L25.404|
                          DCD      0x40012400
                  |L25.408|
                          DCD      0x40012800
                  |L25.412|
                          DCD      0x40013c00
                  |L25.416|
                          DCD      0xfff0feff
                  |L25.420|
                          DCD      0xfff1f7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_InjectedChannelConfig PROC
;;;929      */
;;;930    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;931    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;932      uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
00000c  2700              MOVS     r7,#0
00000e  46b8              MOV      r8,r7
000010  46ba              MOV      r10,r7
;;;933      /* Check the parameters */
;;;934      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000012  494d              LDR      r1,|L26.328|
000014  428e              CMP      r6,r1
000016  d005              BEQ      |L26.36|
000018  494c              LDR      r1,|L26.332|
00001a  428e              CMP      r6,r1
00001c  d002              BEQ      |L26.36|
00001e  494c              LDR      r1,|L26.336|
000020  428e              CMP      r6,r1
000022  d101              BNE      |L26.40|
                  |L26.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L26.42|
                  |L26.40|
000028  2100              MOVS     r1,#0
                  |L26.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;935      assert_param(IS_ADC_CHANNEL(ADC_Channel));
000030  b30c              CBZ      r4,|L26.118|
000032  2c01              CMP      r4,#1
000034  d01f              BEQ      |L26.118|
000036  2c02              CMP      r4,#2
000038  d01d              BEQ      |L26.118|
00003a  2c03              CMP      r4,#3
00003c  d01b              BEQ      |L26.118|
00003e  2c04              CMP      r4,#4
000040  d019              BEQ      |L26.118|
000042  2c05              CMP      r4,#5
000044  d017              BEQ      |L26.118|
000046  2c06              CMP      r4,#6
000048  d015              BEQ      |L26.118|
00004a  2c07              CMP      r4,#7
00004c  d013              BEQ      |L26.118|
00004e  2c08              CMP      r4,#8
000050  d011              BEQ      |L26.118|
000052  2c09              CMP      r4,#9
000054  d00f              BEQ      |L26.118|
000056  2c0a              CMP      r4,#0xa
000058  d00d              BEQ      |L26.118|
00005a  2c0b              CMP      r4,#0xb
00005c  d00b              BEQ      |L26.118|
00005e  2c0c              CMP      r4,#0xc
000060  d009              BEQ      |L26.118|
000062  2c0d              CMP      r4,#0xd
000064  d007              BEQ      |L26.118|
000066  2c0e              CMP      r4,#0xe
000068  d005              BEQ      |L26.118|
00006a  2c0f              CMP      r4,#0xf
00006c  d003              BEQ      |L26.118|
00006e  2c10              CMP      r4,#0x10
000070  d001              BEQ      |L26.118|
000072  2c11              CMP      r4,#0x11
000074  d101              BNE      |L26.122|
                  |L26.118|
000076  2101              MOVS     r1,#1
000078  e000              B        |L26.124|
                  |L26.122|
00007a  2100              MOVS     r1,#0
                  |L26.124|
00007c  4608              MOV      r0,r1
00007e  f7fffffe          BL       assert_param
;;;936      assert_param(IS_ADC_INJECTED_RANK(Rank));
000082  f1b90f01          CMP      r9,#1
000086  db04              BLT      |L26.146|
000088  f1b90f04          CMP      r9,#4
00008c  dc01              BGT      |L26.146|
00008e  2101              MOVS     r1,#1
000090  e000              B        |L26.148|
                  |L26.146|
000092  2100              MOVS     r1,#0
                  |L26.148|
000094  4608              MOV      r0,r1
000096  f7fffffe          BL       assert_param
;;;937      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
00009a  b16d              CBZ      r5,|L26.184|
00009c  2d01              CMP      r5,#1
00009e  d00b              BEQ      |L26.184|
0000a0  2d02              CMP      r5,#2
0000a2  d009              BEQ      |L26.184|
0000a4  2d03              CMP      r5,#3
0000a6  d007              BEQ      |L26.184|
0000a8  2d04              CMP      r5,#4
0000aa  d005              BEQ      |L26.184|
0000ac  2d05              CMP      r5,#5
0000ae  d003              BEQ      |L26.184|
0000b0  2d06              CMP      r5,#6
0000b2  d001              BEQ      |L26.184|
0000b4  2d07              CMP      r5,#7
0000b6  d101              BNE      |L26.188|
                  |L26.184|
0000b8  2101              MOVS     r1,#1
0000ba  e000              B        |L26.190|
                  |L26.188|
0000bc  2100              MOVS     r1,#0
                  |L26.190|
0000be  4608              MOV      r0,r1
0000c0  f7fffffe          BL       assert_param
;;;938      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;939      if (ADC_Channel > ADC_Channel_9)
0000c4  2c09              CMP      r4,#9
0000c6  dd13              BLE      |L26.240|
;;;940      {
;;;941        /* Get the old register value */
;;;942        tmpreg1 = ADCx->SMPR1;
0000c8  68f7              LDR      r7,[r6,#0xc]
;;;943        /* Calculate the mask to clear */
;;;944        tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
0000ca  f1a4000a          SUB      r0,r4,#0xa
0000ce  eb000140          ADD      r1,r0,r0,LSL #1
0000d2  2007              MOVS     r0,#7
0000d4  fa00f801          LSL      r8,r0,r1
;;;945        /* Clear the old channel sample time */
;;;946        tmpreg1 &= ~tmpreg2;
0000d8  ea270708          BIC      r7,r7,r8
;;;947        /* Calculate the mask to set */
;;;948        tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
0000dc  f1a4000a          SUB      r0,r4,#0xa
0000e0  eb000040          ADD      r0,r0,r0,LSL #1
0000e4  fa05f800          LSL      r8,r5,r0
;;;949        /* Set the new channel sample time */
;;;950        tmpreg1 |= tmpreg2;
0000e8  ea470708          ORR      r7,r7,r8
;;;951        /* Store the new register value */
;;;952        ADCx->SMPR1 = tmpreg1;
0000ec  60f7              STR      r7,[r6,#0xc]
0000ee  e00e              B        |L26.270|
                  |L26.240|
;;;953      }
;;;954      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;955      {
;;;956        /* Get the old register value */
;;;957        tmpreg1 = ADCx->SMPR2;
0000f0  6937              LDR      r7,[r6,#0x10]
;;;958        /* Calculate the mask to clear */
;;;959        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0000f2  eb040144          ADD      r1,r4,r4,LSL #1
0000f6  2007              MOVS     r0,#7
0000f8  fa00f801          LSL      r8,r0,r1
;;;960        /* Clear the old channel sample time */
;;;961        tmpreg1 &= ~tmpreg2;
0000fc  ea270708          BIC      r7,r7,r8
;;;962        /* Calculate the mask to set */
;;;963        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000100  eb040044          ADD      r0,r4,r4,LSL #1
000104  fa05f800          LSL      r8,r5,r0
;;;964        /* Set the new channel sample time */
;;;965        tmpreg1 |= tmpreg2;
000108  ea470708          ORR      r7,r7,r8
;;;966        /* Store the new register value */
;;;967        ADCx->SMPR2 = tmpreg1;
00010c  6137              STR      r7,[r6,#0x10]
                  |L26.270|
;;;968      }
;;;969      /* Rank configuration */
;;;970      /* Get the old register value */
;;;971      tmpreg1 = ADCx->JSQR;
00010e  6bb7              LDR      r7,[r6,#0x38]
;;;972      /* Get JL value: Number = JL+1 */
;;;973      tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000110  f3c75a01          UBFX     r10,r7,#20,#2
;;;974      /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;975      tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000114  f1090003          ADD      r0,r9,#3
000118  f10a0101          ADD      r1,r10,#1
00011c  1a40              SUBS     r0,r0,r1
00011e  eb000180          ADD      r1,r0,r0,LSL #2
000122  201f              MOVS     r0,#0x1f
000124  fa00f801          LSL      r8,r0,r1
;;;976      /* Clear the old JSQx bits for the selected rank */
;;;977      tmpreg1 &= ~tmpreg2;
000128  ea270708          BIC      r7,r7,r8
;;;978      /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;979      tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
00012c  f1090003          ADD      r0,r9,#3
000130  f10a0101          ADD      r1,r10,#1
000134  1a40              SUBS     r0,r0,r1
000136  eb000080          ADD      r0,r0,r0,LSL #2
00013a  fa04f800          LSL      r8,r4,r0
;;;980      /* Set the JSQx bits for the selected rank */
;;;981      tmpreg1 |= tmpreg2;
00013e  ea470708          ORR      r7,r7,r8
;;;982      /* Store the new register value */
;;;983      ADCx->JSQR = tmpreg1;
000142  63b7              STR      r7,[r6,#0x38]
;;;984    }
000144  e8bd87f0          POP      {r4-r10,pc}
;;;985    
                          ENDP

                  |L26.328|
                          DCD      0x40012400
                  |L26.332|
                          DCD      0x40012800
                  |L26.336|
                          DCD      0x40013c00

                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=2

                  ADC_InjectedDiscModeCmd PROC
;;;759      */
;;;760    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;761    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;762      /* Check the parameters */
;;;763      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L27.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L27.24|
00000c  4910              LDR      r1,|L27.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L27.24|
000012  4910              LDR      r1,|L27.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L27.28|
                  |L27.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L27.30|
                  |L27.28|
00001c  2100              MOVS     r1,#0
                  |L27.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;764      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L27.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L27.46|
                  |L27.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L27.48|
                  |L27.46|
00002e  2100              MOVS     r1,#0
                  |L27.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;765      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L27.66|
;;;766      {
;;;767        /* Enable the selected ADC injected discontinuous mode */
;;;768        ADCx->CR1 |= CR1_JDISCEN_Set;
000038  6860              LDR      r0,[r4,#4]
00003a  f4405080          ORR      r0,r0,#0x1000
00003e  6060              STR      r0,[r4,#4]
000040  e003              B        |L27.74|
                  |L27.66|
;;;769      }
;;;770      else
;;;771      {
;;;772        /* Disable the selected ADC injected discontinuous mode */
;;;773        ADCx->CR1 &= CR1_JDISCEN_Reset;
000042  6860              LDR      r0,[r4,#4]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6060              STR      r0,[r4,#4]
                  |L27.74|
;;;774      }
;;;775    }
00004a  bd70              POP      {r4-r6,pc}
;;;776    
                          ENDP

                  |L27.76|
                          DCD      0x40012400
                  |L27.80|
                          DCD      0x40012800
                  |L27.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=2

                  ADC_InjectedSequencerLengthConfig PROC
;;;992      */
;;;993    void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;994    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;995      uint32_t tmpreg1 = 0;
000008  2600              MOVS     r6,#0
;;;996      uint32_t tmpreg2 = 0;
00000a  2700              MOVS     r7,#0
;;;997      /* Check the parameters */
;;;998      assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000c  4910              LDR      r1,|L28.80|
00000e  428c              CMP      r4,r1
000010  d005              BEQ      |L28.30|
000012  4910              LDR      r1,|L28.84|
000014  428c              CMP      r4,r1
000016  d002              BEQ      |L28.30|
000018  490f              LDR      r1,|L28.88|
00001a  428c              CMP      r4,r1
00001c  d101              BNE      |L28.34|
                  |L28.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L28.36|
                  |L28.34|
000022  2100              MOVS     r1,#0
                  |L28.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;999      assert_param(IS_ADC_INJECTED_LENGTH(Length));
00002a  2d01              CMP      r5,#1
00002c  db03              BLT      |L28.54|
00002e  2d04              CMP      r5,#4
000030  dc01              BGT      |L28.54|
000032  2101              MOVS     r1,#1
000034  e000              B        |L28.56|
                  |L28.54|
000036  2100              MOVS     r1,#0
                  |L28.56|
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       assert_param
;;;1000     
;;;1001     /* Get the old register value */
;;;1002     tmpreg1 = ADCx->JSQR;
00003e  6ba6              LDR      r6,[r4,#0x38]
;;;1003     /* Clear the old injected sequnence lenght JL bits */
;;;1004     tmpreg1 &= JSQR_JL_Reset;
000040  f4261640          BIC      r6,r6,#0x300000
;;;1005     /* Set the injected sequnence lenght JL bits */
;;;1006     tmpreg2 = Length - 1; 
000044  1e6f              SUBS     r7,r5,#1
;;;1007     tmpreg1 |= tmpreg2 << 20;
000046  ea465607          ORR      r6,r6,r7,LSL #20
;;;1008     /* Store the new register value */
;;;1009     ADCx->JSQR = tmpreg1;
00004a  63a6              STR      r6,[r4,#0x38]
;;;1010   }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;1011   
                          ENDP

                  |L28.80|
                          DCD      0x40012400
                  |L28.84|
                          DCD      0x40012800
                  |L28.88|
                          DCD      0x40013c00

                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_RegularChannelConfig PROC
;;;589      */
;;;590    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;591    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;592      uint32_t tmpreg1 = 0, tmpreg2 = 0;
00000c  2500              MOVS     r5,#0
00000e  46a9              MOV      r9,r5
;;;593      /* Check the parameters */
;;;594      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000010  4960              LDR      r1,|L29.404|
000012  428e              CMP      r6,r1
000014  d005              BEQ      |L29.34|
000016  4960              LDR      r1,|L29.408|
000018  428e              CMP      r6,r1
00001a  d002              BEQ      |L29.34|
00001c  495f              LDR      r1,|L29.412|
00001e  428e              CMP      r6,r1
000020  d101              BNE      |L29.38|
                  |L29.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L29.40|
                  |L29.38|
000026  2100              MOVS     r1,#0
                  |L29.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;595      assert_param(IS_ADC_CHANNEL(ADC_Channel));
00002e  b30c              CBZ      r4,|L29.116|
000030  2c01              CMP      r4,#1
000032  d01f              BEQ      |L29.116|
000034  2c02              CMP      r4,#2
000036  d01d              BEQ      |L29.116|
000038  2c03              CMP      r4,#3
00003a  d01b              BEQ      |L29.116|
00003c  2c04              CMP      r4,#4
00003e  d019              BEQ      |L29.116|
000040  2c05              CMP      r4,#5
000042  d017              BEQ      |L29.116|
000044  2c06              CMP      r4,#6
000046  d015              BEQ      |L29.116|
000048  2c07              CMP      r4,#7
00004a  d013              BEQ      |L29.116|
00004c  2c08              CMP      r4,#8
00004e  d011              BEQ      |L29.116|
000050  2c09              CMP      r4,#9
000052  d00f              BEQ      |L29.116|
000054  2c0a              CMP      r4,#0xa
000056  d00d              BEQ      |L29.116|
000058  2c0b              CMP      r4,#0xb
00005a  d00b              BEQ      |L29.116|
00005c  2c0c              CMP      r4,#0xc
00005e  d009              BEQ      |L29.116|
000060  2c0d              CMP      r4,#0xd
000062  d007              BEQ      |L29.116|
000064  2c0e              CMP      r4,#0xe
000066  d005              BEQ      |L29.116|
000068  2c0f              CMP      r4,#0xf
00006a  d003              BEQ      |L29.116|
00006c  2c10              CMP      r4,#0x10
00006e  d001              BEQ      |L29.116|
000070  2c11              CMP      r4,#0x11
000072  d101              BNE      |L29.120|
                  |L29.116|
000074  2101              MOVS     r1,#1
000076  e000              B        |L29.122|
                  |L29.120|
000078  2100              MOVS     r1,#0
                  |L29.122|
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       assert_param
;;;596      assert_param(IS_ADC_REGULAR_RANK(Rank));
000080  2f01              CMP      r7,#1
000082  db03              BLT      |L29.140|
000084  2f10              CMP      r7,#0x10
000086  dc01              BGT      |L29.140|
000088  2101              MOVS     r1,#1
00008a  e000              B        |L29.142|
                  |L29.140|
00008c  2100              MOVS     r1,#0
                  |L29.142|
00008e  4608              MOV      r0,r1
000090  f7fffffe          BL       assert_param
;;;597      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
000094  f1b80f00          CMP      r8,#0
000098  d014              BEQ      |L29.196|
00009a  f1b80f01          CMP      r8,#1
00009e  d011              BEQ      |L29.196|
0000a0  f1b80f02          CMP      r8,#2
0000a4  d00e              BEQ      |L29.196|
0000a6  f1b80f03          CMP      r8,#3
0000aa  d00b              BEQ      |L29.196|
0000ac  f1b80f04          CMP      r8,#4
0000b0  d008              BEQ      |L29.196|
0000b2  f1b80f05          CMP      r8,#5
0000b6  d005              BEQ      |L29.196|
0000b8  f1b80f06          CMP      r8,#6
0000bc  d002              BEQ      |L29.196|
0000be  f1b80f07          CMP      r8,#7
0000c2  d101              BNE      |L29.200|
                  |L29.196|
0000c4  2101              MOVS     r1,#1
0000c6  e000              B        |L29.202|
                  |L29.200|
0000c8  2100              MOVS     r1,#0
                  |L29.202|
0000ca  4608              MOV      r0,r1
0000cc  f7fffffe          BL       assert_param
;;;598      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;599      if (ADC_Channel > ADC_Channel_9)
0000d0  2c09              CMP      r4,#9
0000d2  dd13              BLE      |L29.252|
;;;600      {
;;;601        /* Get the old register value */
;;;602        tmpreg1 = ADCx->SMPR1;
0000d4  68f5              LDR      r5,[r6,#0xc]
;;;603        /* Calculate the mask to clear */
;;;604        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
0000d6  f1a4000a          SUB      r0,r4,#0xa
0000da  eb000140          ADD      r1,r0,r0,LSL #1
0000de  2007              MOVS     r0,#7
0000e0  fa00f901          LSL      r9,r0,r1
;;;605        /* Clear the old channel sample time */
;;;606        tmpreg1 &= ~tmpreg2;
0000e4  ea250509          BIC      r5,r5,r9
;;;607        /* Calculate the mask to set */
;;;608        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
0000e8  f1a4000a          SUB      r0,r4,#0xa
0000ec  eb000040          ADD      r0,r0,r0,LSL #1
0000f0  fa08f900          LSL      r9,r8,r0
;;;609        /* Set the new channel sample time */
;;;610        tmpreg1 |= tmpreg2;
0000f4  ea450509          ORR      r5,r5,r9
;;;611        /* Store the new register value */
;;;612        ADCx->SMPR1 = tmpreg1;
0000f8  60f5              STR      r5,[r6,#0xc]
0000fa  e00e              B        |L29.282|
                  |L29.252|
;;;613      }
;;;614      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;615      {
;;;616        /* Get the old register value */
;;;617        tmpreg1 = ADCx->SMPR2;
0000fc  6935              LDR      r5,[r6,#0x10]
;;;618        /* Calculate the mask to clear */
;;;619        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0000fe  eb040144          ADD      r1,r4,r4,LSL #1
000102  2007              MOVS     r0,#7
000104  fa00f901          LSL      r9,r0,r1
;;;620        /* Clear the old channel sample time */
;;;621        tmpreg1 &= ~tmpreg2;
000108  ea250509          BIC      r5,r5,r9
;;;622        /* Calculate the mask to set */
;;;623        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00010c  eb040044          ADD      r0,r4,r4,LSL #1
000110  fa08f900          LSL      r9,r8,r0
;;;624        /* Set the new channel sample time */
;;;625        tmpreg1 |= tmpreg2;
000114  ea450509          ORR      r5,r5,r9
;;;626        /* Store the new register value */
;;;627        ADCx->SMPR2 = tmpreg1;
000118  6135              STR      r5,[r6,#0x10]
                  |L29.282|
;;;628      }
;;;629      /* For Rank 1 to 6 */
;;;630      if (Rank < 7)
00011a  2f07              CMP      r7,#7
00011c  da11              BGE      |L29.322|
;;;631      {
;;;632        /* Get the old register value */
;;;633        tmpreg1 = ADCx->SQR3;
00011e  6b75              LDR      r5,[r6,#0x34]
;;;634        /* Calculate the mask to clear */
;;;635        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
000120  1e78              SUBS     r0,r7,#1
000122  eb000180          ADD      r1,r0,r0,LSL #2
000126  201f              MOVS     r0,#0x1f
000128  fa00f901          LSL      r9,r0,r1
;;;636        /* Clear the old SQx bits for the selected rank */
;;;637        tmpreg1 &= ~tmpreg2;
00012c  ea250509          BIC      r5,r5,r9
;;;638        /* Calculate the mask to set */
;;;639        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000130  1e78              SUBS     r0,r7,#1
000132  eb000080          ADD      r0,r0,r0,LSL #2
000136  fa04f900          LSL      r9,r4,r0
;;;640        /* Set the SQx bits for the selected rank */
;;;641        tmpreg1 |= tmpreg2;
00013a  ea450509          ORR      r5,r5,r9
;;;642        /* Store the new register value */
;;;643        ADCx->SQR3 = tmpreg1;
00013e  6375              STR      r5,[r6,#0x34]
000140  e026              B        |L29.400|
                  |L29.322|
;;;644      }
;;;645      /* For Rank 7 to 12 */
;;;646      else if (Rank < 13)
000142  2f0d              CMP      r7,#0xd
000144  da11              BGE      |L29.362|
;;;647      {
;;;648        /* Get the old register value */
;;;649        tmpreg1 = ADCx->SQR2;
000146  6b35              LDR      r5,[r6,#0x30]
;;;650        /* Calculate the mask to clear */
;;;651        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
000148  1ff8              SUBS     r0,r7,#7
00014a  eb000180          ADD      r1,r0,r0,LSL #2
00014e  201f              MOVS     r0,#0x1f
000150  fa00f901          LSL      r9,r0,r1
;;;652        /* Clear the old SQx bits for the selected rank */
;;;653        tmpreg1 &= ~tmpreg2;
000154  ea250509          BIC      r5,r5,r9
;;;654        /* Calculate the mask to set */
;;;655        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
000158  1ff8              SUBS     r0,r7,#7
00015a  eb000080          ADD      r0,r0,r0,LSL #2
00015e  fa04f900          LSL      r9,r4,r0
;;;656        /* Set the SQx bits for the selected rank */
;;;657        tmpreg1 |= tmpreg2;
000162  ea450509          ORR      r5,r5,r9
;;;658        /* Store the new register value */
;;;659        ADCx->SQR2 = tmpreg1;
000166  6335              STR      r5,[r6,#0x30]
000168  e012              B        |L29.400|
                  |L29.362|
;;;660      }
;;;661      /* For Rank 13 to 16 */
;;;662      else
;;;663      {
;;;664        /* Get the old register value */
;;;665        tmpreg1 = ADCx->SQR1;
00016a  6af5              LDR      r5,[r6,#0x2c]
;;;666        /* Calculate the mask to clear */
;;;667        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
00016c  f1a7000d          SUB      r0,r7,#0xd
000170  eb000180          ADD      r1,r0,r0,LSL #2
000174  201f              MOVS     r0,#0x1f
000176  fa00f901          LSL      r9,r0,r1
;;;668        /* Clear the old SQx bits for the selected rank */
;;;669        tmpreg1 &= ~tmpreg2;
00017a  ea250509          BIC      r5,r5,r9
;;;670        /* Calculate the mask to set */
;;;671        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
00017e  f1a7000d          SUB      r0,r7,#0xd
000182  eb000080          ADD      r0,r0,r0,LSL #2
000186  fa04f900          LSL      r9,r4,r0
;;;672        /* Set the SQx bits for the selected rank */
;;;673        tmpreg1 |= tmpreg2;
00018a  ea450509          ORR      r5,r5,r9
;;;674        /* Store the new register value */
;;;675        ADCx->SQR1 = tmpreg1;
00018e  62f5              STR      r5,[r6,#0x2c]
                  |L29.400|
;;;676      }
;;;677    }
000190  e8bd87f0          POP      {r4-r10,pc}
;;;678    
                          ENDP

                  |L29.404|
                          DCD      0x40012400
                  |L29.408|
                          DCD      0x40012800
                  |L29.412|
                          DCD      0x40013c00

                          AREA ||i.ADC_ResetCalibration||, CODE, READONLY, ALIGN=2

                  ADC_ResetCalibration PROC
;;;378      */
;;;379    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;380    {
000002  4604              MOV      r4,r0
;;;381      /* Check the parameters */
;;;382      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4909              LDR      r1,|L30.44|
000006  428c              CMP      r4,r1
000008  d005              BEQ      |L30.22|
00000a  4909              LDR      r1,|L30.48|
00000c  428c              CMP      r4,r1
00000e  d002              BEQ      |L30.22|
000010  4908              LDR      r1,|L30.52|
000012  428c              CMP      r4,r1
000014  d101              BNE      |L30.26|
                  |L30.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L30.28|
                  |L30.26|
00001a  2100              MOVS     r1,#0
                  |L30.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;383      /* Resets the selected ADC calibration registers */  
;;;384      ADCx->CR2 |= CR2_RSTCAL_Set;
000022  68a0              LDR      r0,[r4,#8]
000024  f0400008          ORR      r0,r0,#8
000028  60a0              STR      r0,[r4,#8]
;;;385    }
00002a  bd10              POP      {r4,pc}
;;;386    
                          ENDP

                  |L30.44|
                          DCD      0x40012400
                  |L30.48|
                          DCD      0x40012800
                  |L30.52|
                          DCD      0x40013c00

                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=2

                  ADC_SetInjectedOffset PROC
;;;1024     */
;;;1025   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1026   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;1027     __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1028     
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_ADC_ALL_PERIPH(ADCx));
00000c  4916              LDR      r1,|L31.104|
00000e  428d              CMP      r5,r1
000010  d005              BEQ      |L31.30|
000012  4916              LDR      r1,|L31.108|
000014  428d              CMP      r5,r1
000016  d002              BEQ      |L31.30|
000018  4915              LDR      r1,|L31.112|
00001a  428d              CMP      r5,r1
00001c  d101              BNE      |L31.34|
                  |L31.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L31.36|
                  |L31.34|
000022  2100              MOVS     r1,#0
                  |L31.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;1031     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
00002a  2c14              CMP      r4,#0x14
00002c  d005              BEQ      |L31.58|
00002e  2c18              CMP      r4,#0x18
000030  d003              BEQ      |L31.58|
000032  2c1c              CMP      r4,#0x1c
000034  d001              BEQ      |L31.58|
000036  2c20              CMP      r4,#0x20
000038  d101              BNE      |L31.62|
                  |L31.58|
00003a  2101              MOVS     r1,#1
00003c  e000              B        |L31.64|
                  |L31.62|
00003e  2100              MOVS     r1,#0
                  |L31.64|
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       assert_param
;;;1032     assert_param(IS_ADC_OFFSET(Offset));  
000046  f5b65f80          CMP      r6,#0x1000
00004a  da01              BGE      |L31.80|
00004c  2101              MOVS     r1,#1
00004e  e000              B        |L31.82|
                  |L31.80|
000050  2100              MOVS     r1,#0
                  |L31.82|
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       assert_param
;;;1033     
;;;1034     tmp = (uint32_t)ADCx;
000058  9500              STR      r5,[sp,#0]
;;;1035     tmp += ADC_InjectedChannel;
00005a  9800              LDR      r0,[sp,#0]
00005c  4420              ADD      r0,r0,r4
00005e  9000              STR      r0,[sp,#0]
;;;1036     
;;;1037     /* Set the selected injected channel data offset */
;;;1038     *(__IO uint32_t *) tmp = (uint32_t)Offset;
000060  9800              LDR      r0,[sp,#0]
000062  6006              STR      r6,[r0,#0]
;;;1039   }
000064  bdf8              POP      {r3-r7,pc}
;;;1040   
                          ENDP

000066  0000              DCW      0x0000
                  |L31.104|
                          DCD      0x40012400
                  |L31.108|
                          DCD      0x40012800
                  |L31.112|
                          DCD      0x40013c00

                          AREA ||i.ADC_SoftwareStartConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_SoftwareStartConvCmd PROC
;;;456      */
;;;457    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;459      /* Check the parameters */
;;;460      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L32.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L32.24|
00000c  4910              LDR      r1,|L32.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L32.24|
000012  4910              LDR      r1,|L32.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L32.28|
                  |L32.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L32.30|
                  |L32.28|
00001c  2100              MOVS     r1,#0
                  |L32.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;461      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L32.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L32.46|
                  |L32.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L32.48|
                  |L32.46|
00002e  2100              MOVS     r1,#0
                  |L32.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;462      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L32.66|
;;;463      {
;;;464        /* Enable the selected ADC conversion on external event and start the selected
;;;465           ADC conversion */
;;;466        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
000038  68a0              LDR      r0,[r4,#8]
00003a  f44000a0          ORR      r0,r0,#0x500000
00003e  60a0              STR      r0,[r4,#8]
000040  e003              B        |L32.74|
                  |L32.66|
;;;467      }
;;;468      else
;;;469      {
;;;470        /* Disable the selected ADC conversion on external event and stop the selected
;;;471           ADC conversion */
;;;472        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
000042  68a0              LDR      r0,[r4,#8]
000044  f42000a0          BIC      r0,r0,#0x500000
000048  60a0              STR      r0,[r4,#8]
                  |L32.74|
;;;473      }
;;;474    }
00004a  bd70              POP      {r4-r6,pc}
;;;475    
                          ENDP

                  |L32.76|
                          DCD      0x40012400
                  |L32.80|
                          DCD      0x40012800
                  |L32.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_SoftwareStartInjectedConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;848      */
;;;849    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;850    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;851      /* Check the parameters */
;;;852      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4911              LDR      r1,|L33.76|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L33.24|
00000c  4910              LDR      r1,|L33.80|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L33.24|
000012  4910              LDR      r1,|L33.84|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L33.28|
                  |L33.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L33.30|
                  |L33.28|
00001c  2100              MOVS     r1,#0
                  |L33.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;853      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L33.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L33.46|
                  |L33.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L33.48|
                  |L33.46|
00002e  2100              MOVS     r1,#0
                  |L33.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;854      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L33.66|
;;;855      {
;;;856        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;857           ADC injected conversion */
;;;858        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
000038  68a0              LDR      r0,[r4,#8]
00003a  f4401002          ORR      r0,r0,#0x208000
00003e  60a0              STR      r0,[r4,#8]
000040  e003              B        |L33.74|
                  |L33.66|
;;;859      }
;;;860      else
;;;861      {
;;;862        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;863           ADC injected conversion */
;;;864        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
000042  68a0              LDR      r0,[r4,#8]
000044  f4201002          BIC      r0,r0,#0x208000
000048  60a0              STR      r0,[r4,#8]
                  |L33.74|
;;;865      }
;;;866    }
00004a  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP

                  |L33.76|
                          DCD      0x40012400
                  |L33.80|
                          DCD      0x40012800
                  |L33.84|
                          DCD      0x40013c00

                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=2

                  ADC_StartCalibration PROC
;;;416      */
;;;417    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;418    {
000002  4604              MOV      r4,r0
;;;419      /* Check the parameters */
;;;420      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4909              LDR      r1,|L34.44|
000006  428c              CMP      r4,r1
000008  d005              BEQ      |L34.22|
00000a  4909              LDR      r1,|L34.48|
00000c  428c              CMP      r4,r1
00000e  d002              BEQ      |L34.22|
000010  4908              LDR      r1,|L34.52|
000012  428c              CMP      r4,r1
000014  d101              BNE      |L34.26|
                  |L34.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L34.28|
                  |L34.26|
00001a  2100              MOVS     r1,#0
                  |L34.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;421      /* Enable the selected ADC calibration process */  
;;;422      ADCx->CR2 |= CR2_CAL_Set;
000022  68a0              LDR      r0,[r4,#8]
000024  f0400004          ORR      r0,r0,#4
000028  60a0              STR      r0,[r4,#8]
;;;423    }
00002a  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  |L34.44|
                          DCD      0x40012400
                  |L34.48|
                          DCD      0x40012800
                  |L34.52|
                          DCD      0x40013c00

                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;274      */
;;;275    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;276    {
;;;277      /* Reset ADC init structure parameters values */
;;;278      /* Initialize the ADC_Mode member */
;;;279      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
000002  6001              STR      r1,[r0,#0]
;;;280      /* initialize the ADC_ScanConvMode member */
;;;281      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000004  7101              STRB     r1,[r0,#4]
;;;282      /* Initialize the ADC_ContinuousConvMode member */
;;;283      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;284      /* Initialize the ADC_ExternalTrigConv member */
;;;285      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
000008  6081              STR      r1,[r0,#8]
;;;286      /* Initialize the ADC_DataAlign member */
;;;287      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00000a  60c1              STR      r1,[r0,#0xc]
;;;288      /* Initialize the ADC_NbrOfChannel member */
;;;289      ADC_InitStruct->ADC_NbrOfChannel = 1;
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;290    }
000010  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;1166     */
;;;1167   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1168   {
000002  4604              MOV      r4,r0
;;;1169     /* Check the parameters */
;;;1170     assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L36.10|
000006  2c01              CMP      r4,#1
000008  d101              BNE      |L36.14|
                  |L36.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L36.16|
                  |L36.14|
00000e  2100              MOVS     r1,#0
                  |L36.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;1171     if (NewState != DISABLE)
000016  b134              CBZ      r4,|L36.38|
;;;1172     {
;;;1173       /* Enable the temperature sensor and Vrefint channel*/
;;;1174       ADC1->CR2 |= CR2_TSVREFE_Set;
000018  4806              LDR      r0,|L36.52|
00001a  6800              LDR      r0,[r0,#0]
00001c  f4400000          ORR      r0,r0,#0x800000
000020  4904              LDR      r1,|L36.52|
000022  6008              STR      r0,[r1,#0]
000024  e005              B        |L36.50|
                  |L36.38|
;;;1175     }
;;;1176     else
;;;1177     {
;;;1178       /* Disable the temperature sensor and Vrefint channel*/
;;;1179       ADC1->CR2 &= CR2_TSVREFE_Reset;
000026  4803              LDR      r0,|L36.52|
000028  6800              LDR      r0,[r0,#0]
00002a  f4200000          BIC      r0,r0,#0x800000
00002e  4901              LDR      r1,|L36.52|
000030  6008              STR      r0,[r1,#0]
                  |L36.50|
;;;1180     }
;;;1181   }
000032  bd10              POP      {r4,pc}
;;;1182   
                          ENDP

                  |L36.52|
                          DCD      0x40012408
