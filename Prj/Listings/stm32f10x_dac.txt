; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_dac.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_dac.crf ..\Chip\Hal_lib\stm32f10x_dac.c]
                          THUMB

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;172      */
;;;173    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;175      /* Check the parameters */
;;;176      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000006  b10c              CBZ      r4,|L1.12|
000008  2c10              CMP      r4,#0x10
00000a  d101              BNE      |L1.16|
                  |L1.12|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L1.18|
                  |L1.16|
000010  2100              MOVS     r1,#0
                  |L1.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;177      assert_param(IS_FUNCTIONAL_STATE(NewState));
000018  b10d              CBZ      r5,|L1.30|
00001a  2d01              CMP      r5,#1
00001c  d101              BNE      |L1.34|
                  |L1.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L1.36|
                  |L1.34|
000022  2100              MOVS     r1,#0
                  |L1.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;178      if (NewState != DISABLE)
00002a  b13d              CBZ      r5,|L1.60|
;;;179      {
;;;180        /* Enable the selected DAC channel */
;;;181        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
00002c  4807              LDR      r0,|L1.76|
00002e  6800              LDR      r0,[r0,#0]
000030  2101              MOVS     r1,#1
000032  40a1              LSLS     r1,r1,r4
000034  4308              ORRS     r0,r0,r1
000036  4905              LDR      r1,|L1.76|
000038  6008              STR      r0,[r1,#0]
00003a  e006              B        |L1.74|
                  |L1.60|
;;;182      }
;;;183      else
;;;184      {
;;;185        /* Disable the selected DAC channel */
;;;186        DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);
00003c  4803              LDR      r0,|L1.76|
00003e  6800              LDR      r0,[r0,#0]
000040  2101              MOVS     r1,#1
000042  40a1              LSLS     r1,r1,r4
000044  4388              BICS     r0,r0,r1
000046  4901              LDR      r1,|L1.76|
000048  6008              STR      r0,[r1,#0]
                  |L1.74|
;;;187      }
;;;188    }
00004a  bd70              POP      {r4-r6,pc}
;;;189    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
                          ENDP

                  |L1.76|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;232      */
;;;233    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;234    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;235      /* Check the parameters */
;;;236      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000006  b10c              CBZ      r4,|L2.12|
000008  2c10              CMP      r4,#0x10
00000a  d101              BNE      |L2.16|
                  |L2.12|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L2.18|
                  |L2.16|
000010  2100              MOVS     r1,#0
                  |L2.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;237      assert_param(IS_FUNCTIONAL_STATE(NewState));
000018  b10d              CBZ      r5,|L2.30|
00001a  2d01              CMP      r5,#1
00001c  d101              BNE      |L2.34|
                  |L2.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L2.36|
                  |L2.34|
000022  2100              MOVS     r1,#0
                  |L2.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;238      if (NewState != DISABLE)
00002a  b145              CBZ      r5,|L2.62|
;;;239      {
;;;240        /* Enable the selected DAC channel DMA request */
;;;241        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
00002c  4808              LDR      r0,|L2.80|
00002e  6800              LDR      r0,[r0,#0]
000030  f44f5180          MOV      r1,#0x1000
000034  40a1              LSLS     r1,r1,r4
000036  4308              ORRS     r0,r0,r1
000038  4905              LDR      r1,|L2.80|
00003a  6008              STR      r0,[r1,#0]
00003c  e007              B        |L2.78|
                  |L2.62|
;;;242      }
;;;243      else
;;;244      {
;;;245        /* Disable the selected DAC channel DMA request */
;;;246        DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);
00003e  4804              LDR      r0,|L2.80|
000040  6800              LDR      r0,[r0,#0]
000042  f44f5180          MOV      r1,#0x1000
000046  40a1              LSLS     r1,r1,r4
000048  4388              BICS     r0,r0,r1
00004a  4901              LDR      r1,|L2.80|
00004c  6008              STR      r0,[r1,#0]
                  |L2.78|
;;;247      }
;;;248    }
00004e  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  |L2.80|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;97       */
;;;98     void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100      /* Enable DAC reset state */
;;;101      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;102      /* Release DAC from reset state */
;;;103      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;104    }
000014  bd10              POP      {r4,pc}
;;;105    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;283      */
;;;284    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;285    {
000002  4604              MOV      r4,r0
;;;286      /* Check the parameters */
;;;287      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L4.10|
000006  2c01              CMP      r4,#1
000008  d101              BNE      |L4.14|
                  |L4.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L4.16|
                  |L4.14|
00000e  2100              MOVS     r1,#0
                  |L4.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;288      if (NewState != DISABLE)
000016  b134              CBZ      r4,|L4.38|
;;;289      {
;;;290        /* Enable software trigger for both DAC channels */
;;;291        DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
000018  4806              LDR      r0,|L4.52|
00001a  6800              LDR      r0,[r0,#0]
00001c  f0400003          ORR      r0,r0,#3
000020  4904              LDR      r1,|L4.52|
000022  6008              STR      r0,[r1,#0]
000024  e005              B        |L4.50|
                  |L4.38|
;;;292      }
;;;293      else
;;;294      {
;;;295        /* Disable software trigger for both DAC channels */
;;;296        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
000026  4803              LDR      r0,|L4.52|
000028  6800              LDR      r0,[r0,#0]
00002a  f0200003          BIC      r0,r0,#3
00002e  4901              LDR      r1,|L4.52|
000030  6008              STR      r0,[r1,#0]
                  |L4.50|
;;;297      }
;;;298    }
000032  bd10              POP      {r4,pc}
;;;299    
                          ENDP

                  |L4.52|
                          DCD      0x40007404

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;429      */
;;;430    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  b538              PUSH     {r3-r5,lr}
;;;431    {
000002  4604              MOV      r4,r0
;;;432      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;433      
;;;434      /* Check the parameters */
;;;435      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000008  b10c              CBZ      r4,|L5.14|
00000a  2c10              CMP      r4,#0x10
00000c  d101              BNE      |L5.18|
                  |L5.14|
00000e  2101              MOVS     r1,#1
000010  e000              B        |L5.20|
                  |L5.18|
000012  2100              MOVS     r1,#0
                  |L5.20|
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       assert_param
;;;436      
;;;437      tmp = (uint32_t) DAC_BASE ;
00001a  4806              LDR      r0,|L5.52|
00001c  9000              STR      r0,[sp,#0]
;;;438      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
00001e  202c              MOVS     r0,#0x2c
000020  eb000094          ADD      r0,r0,r4,LSR #2
000024  9900              LDR      r1,[sp,#0]
000026  4408              ADD      r0,r0,r1
000028  9000              STR      r0,[sp,#0]
;;;439      
;;;440      /* Returns the DAC channel data output register value */
;;;441      return (uint16_t) (*(__IO uint32_t*) tmp);
00002a  9800              LDR      r0,[sp,#0]
00002c  6800              LDR      r0,[r0,#0]
00002e  b280              UXTH     r0,r0
;;;442    }
000030  bd38              POP      {r3-r5,pc}
;;;443    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;116      */
;;;117    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;118    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;119      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;120      /* Check the DAC parameters */
;;;121      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
00000c  6821              LDR      r1,[r4,#0]
00000e  b1b9              CBZ      r1,|L6.64|
000010  6821              LDR      r1,[r4,#0]
000012  2904              CMP      r1,#4
000014  d014              BEQ      |L6.64|
000016  6821              LDR      r1,[r4,#0]
000018  290c              CMP      r1,#0xc
00001a  d011              BEQ      |L6.64|
00001c  6821              LDR      r1,[r4,#0]
00001e  2914              CMP      r1,#0x14
000020  d00e              BEQ      |L6.64|
000022  6821              LDR      r1,[r4,#0]
000024  291c              CMP      r1,#0x1c
000026  d00b              BEQ      |L6.64|
000028  6821              LDR      r1,[r4,#0]
00002a  2924              CMP      r1,#0x24
00002c  d008              BEQ      |L6.64|
00002e  6821              LDR      r1,[r4,#0]
000030  292c              CMP      r1,#0x2c
000032  d005              BEQ      |L6.64|
000034  6821              LDR      r1,[r4,#0]
000036  2934              CMP      r1,#0x34
000038  d002              BEQ      |L6.64|
00003a  6821              LDR      r1,[r4,#0]
00003c  293c              CMP      r1,#0x3c
00003e  d101              BNE      |L6.68|
                  |L6.64|
000040  2101              MOVS     r1,#1
000042  e000              B        |L6.70|
                  |L6.68|
000044  2100              MOVS     r1,#0
                  |L6.70|
000046  4608              MOV      r0,r1
000048  f7fffffe          BL       assert_param
;;;122      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
00004c  6861              LDR      r1,[r4,#4]
00004e  b129              CBZ      r1,|L6.92|
000050  6861              LDR      r1,[r4,#4]
000052  2940              CMP      r1,#0x40
000054  d002              BEQ      |L6.92|
000056  6861              LDR      r1,[r4,#4]
000058  2980              CMP      r1,#0x80
00005a  d101              BNE      |L6.96|
                  |L6.92|
00005c  2101              MOVS     r1,#1
00005e  e000              B        |L6.98|
                  |L6.96|
000060  2100              MOVS     r1,#0
                  |L6.98|
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       assert_param
;;;123      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
000068  68a1              LDR      r1,[r4,#8]
00006a  b3e9              CBZ      r1,|L6.232|
00006c  68a1              LDR      r1,[r4,#8]
00006e  f5b17f80          CMP      r1,#0x100
000072  d057              BEQ      |L6.292|
000074  68a1              LDR      r1,[r4,#8]
000076  f5b17f00          CMP      r1,#0x200
00007a  d053              BEQ      |L6.292|
00007c  68a1              LDR      r1,[r4,#8]
00007e  f5b17f40          CMP      r1,#0x300
000082  d04f              BEQ      |L6.292|
000084  68a1              LDR      r1,[r4,#8]
000086  f5b16f80          CMP      r1,#0x400
00008a  d04b              BEQ      |L6.292|
00008c  68a1              LDR      r1,[r4,#8]
00008e  f5b16fa0          CMP      r1,#0x500
000092  d047              BEQ      |L6.292|
000094  68a1              LDR      r1,[r4,#8]
000096  f5b16fc0          CMP      r1,#0x600
00009a  d043              BEQ      |L6.292|
00009c  68a1              LDR      r1,[r4,#8]
00009e  f5b16fe0          CMP      r1,#0x700
0000a2  d03f              BEQ      |L6.292|
0000a4  68a1              LDR      r1,[r4,#8]
0000a6  f5b16f00          CMP      r1,#0x800
0000aa  d03b              BEQ      |L6.292|
0000ac  68a1              LDR      r1,[r4,#8]
0000ae  f5b16f10          CMP      r1,#0x900
0000b2  d037              BEQ      |L6.292|
0000b4  68a1              LDR      r1,[r4,#8]
0000b6  f5b16f20          CMP      r1,#0xa00
0000ba  d033              BEQ      |L6.292|
0000bc  68a1              LDR      r1,[r4,#8]
0000be  f5b16f30          CMP      r1,#0xb00
0000c2  d02f              BEQ      |L6.292|
0000c4  68a1              LDR      r1,[r4,#8]
0000c6  b179              CBZ      r1,|L6.232|
0000c8  68a1              LDR      r1,[r4,#8]
0000ca  f5b17f80          CMP      r1,#0x100
0000ce  d029              BEQ      |L6.292|
0000d0  68a1              LDR      r1,[r4,#8]
0000d2  f5b17f00          CMP      r1,#0x200
0000d6  d025              BEQ      |L6.292|
0000d8  68a1              LDR      r1,[r4,#8]
0000da  f5b17f40          CMP      r1,#0x300
0000de  d021              BEQ      |L6.292|
0000e0  68a1              LDR      r1,[r4,#8]
0000e2  f5b16f80          CMP      r1,#0x400
0000e6  e000              B        |L6.234|
                  |L6.232|
0000e8  e01c              B        |L6.292|
                  |L6.234|
0000ea  d01b              BEQ      |L6.292|
0000ec  68a1              LDR      r1,[r4,#8]
0000ee  f5b16fa0          CMP      r1,#0x500
0000f2  d017              BEQ      |L6.292|
0000f4  68a1              LDR      r1,[r4,#8]
0000f6  f5b16fc0          CMP      r1,#0x600
0000fa  d013              BEQ      |L6.292|
0000fc  68a1              LDR      r1,[r4,#8]
0000fe  f5b16fe0          CMP      r1,#0x700
000102  d00f              BEQ      |L6.292|
000104  68a1              LDR      r1,[r4,#8]
000106  f5b16f00          CMP      r1,#0x800
00010a  d00b              BEQ      |L6.292|
00010c  68a1              LDR      r1,[r4,#8]
00010e  f5b16f10          CMP      r1,#0x900
000112  d007              BEQ      |L6.292|
000114  68a1              LDR      r1,[r4,#8]
000116  f5b16f20          CMP      r1,#0xa00
00011a  d003              BEQ      |L6.292|
00011c  68a1              LDR      r1,[r4,#8]
00011e  f5b16f30          CMP      r1,#0xb00
000122  d101              BNE      |L6.296|
                  |L6.292|
000124  2101              MOVS     r1,#1
000126  e000              B        |L6.298|
                  |L6.296|
000128  2100              MOVS     r1,#0
                  |L6.298|
00012a  4608              MOV      r0,r1
00012c  f7fffffe          BL       assert_param
;;;124      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
000130  68e1              LDR      r1,[r4,#0xc]
000132  b111              CBZ      r1,|L6.314|
000134  68e1              LDR      r1,[r4,#0xc]
000136  2902              CMP      r1,#2
000138  d101              BNE      |L6.318|
                  |L6.314|
00013a  2101              MOVS     r1,#1
00013c  e000              B        |L6.320|
                  |L6.318|
00013e  2100              MOVS     r1,#0
                  |L6.320|
000140  4608              MOV      r0,r1
000142  f7fffffe          BL       assert_param
;;;125    /*---------------------------- DAC CR Configuration --------------------------*/
;;;126      /* Get the DAC CR value */
;;;127      tmpreg1 = DAC->CR;
000146  480a              LDR      r0,|L6.368|
000148  6806              LDR      r6,[r0,#0]
;;;128      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;129      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
00014a  f64070fe          MOV      r0,#0xffe
00014e  40a8              LSLS     r0,r0,r5
000150  4386              BICS     r6,r6,r0
;;;130      /* Configure for the selected DAC channel: buffer output, trigger, wave generation,
;;;131         mask/amplitude for wave generation */
;;;132      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;133      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;134      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;135      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;136      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000152  e9d40100          LDRD     r0,r1,[r4,#0]
000156  4308              ORRS     r0,r0,r1
000158  68a1              LDR      r1,[r4,#8]
00015a  4308              ORRS     r0,r0,r1
00015c  68e1              LDR      r1,[r4,#0xc]
00015e  ea400701          ORR      r7,r0,r1
;;;137                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;138      /* Calculate CR register value depending on DAC_Channel */
;;;139      tmpreg1 |= tmpreg2 << DAC_Channel;
000162  fa07f005          LSL      r0,r7,r5
000166  4306              ORRS     r6,r6,r0
;;;140      /* Write to DAC CR */
;;;141      DAC->CR = tmpreg1;
000168  4801              LDR      r0,|L6.368|
00016a  6006              STR      r6,[r0,#0]
;;;142    }
00016c  e8bd81f0          POP      {r4-r8,pc}
;;;143    
                          ENDP

                  |L6.368|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;341      */
;;;342    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;343    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;344      __IO uint32_t tmp = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;345      
;;;346      /* Check the parameters */
;;;347      assert_param(IS_DAC_ALIGN(DAC_Align));
00000a  b11c              CBZ      r4,|L7.20|
00000c  2c04              CMP      r4,#4
00000e  d001              BEQ      |L7.20|
000010  2c08              CMP      r4,#8
000012  d101              BNE      |L7.24|
                  |L7.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L7.26|
                  |L7.24|
000018  2100              MOVS     r1,#0
                  |L7.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;348      assert_param(IS_DAC_DATA(Data));
000020  f64f71f0          MOV      r1,#0xfff0
000024  428d              CMP      r5,r1
000026  dc01              BGT      |L7.44|
000028  2101              MOVS     r1,#1
00002a  e000              B        |L7.46|
                  |L7.44|
00002c  2100              MOVS     r1,#0
                  |L7.46|
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       assert_param
;;;349      
;;;350      tmp = (uint32_t)DAC_BASE; 
000034  4804              LDR      r0,|L7.72|
000036  9000              STR      r0,[sp,#0]
;;;351      tmp += DHR12R1_OFFSET + DAC_Align;
000038  f1040008          ADD      r0,r4,#8
00003c  9900              LDR      r1,[sp,#0]
00003e  4408              ADD      r0,r0,r1
000040  9000              STR      r0,[sp,#0]
;;;352    
;;;353      /* Set the DAC channel1 selected data holding register */
;;;354      *(__IO uint32_t *) tmp = Data;
000042  9800              LDR      r0,[sp,#0]
000044  6005              STR      r5,[r0,#0]
;;;355    }
000046  bd38              POP      {r3-r5,pc}
;;;356    
                          ENDP

                  |L7.72|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;366      */
;;;367    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;368    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;369      __IO uint32_t tmp = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;370    
;;;371      /* Check the parameters */
;;;372      assert_param(IS_DAC_ALIGN(DAC_Align));
00000a  b11c              CBZ      r4,|L8.20|
00000c  2c04              CMP      r4,#4
00000e  d001              BEQ      |L8.20|
000010  2c08              CMP      r4,#8
000012  d101              BNE      |L8.24|
                  |L8.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L8.26|
                  |L8.24|
000018  2100              MOVS     r1,#0
                  |L8.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;373      assert_param(IS_DAC_DATA(Data));
000020  f64f71f0          MOV      r1,#0xfff0
000024  428d              CMP      r5,r1
000026  dc01              BGT      |L8.44|
000028  2101              MOVS     r1,#1
00002a  e000              B        |L8.46|
                  |L8.44|
00002c  2100              MOVS     r1,#0
                  |L8.46|
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       assert_param
;;;374      
;;;375      tmp = (uint32_t)DAC_BASE;
000034  4804              LDR      r0,|L8.72|
000036  9000              STR      r0,[sp,#0]
;;;376      tmp += DHR12R2_OFFSET + DAC_Align;
000038  f1040014          ADD      r0,r4,#0x14
00003c  9900              LDR      r1,[sp,#0]
00003e  4408              ADD      r0,r0,r1
000040  9000              STR      r0,[sp,#0]
;;;377    
;;;378      /* Set the DAC channel2 selected data holding register */
;;;379      *(__IO uint32_t *)tmp = Data;
000042  9800              LDR      r0,[sp,#0]
000044  6005              STR      r5,[r0,#0]
;;;380    }
000046  bd38              POP      {r3-r5,pc}
;;;381    
                          ENDP

                  |L8.72|
                          DCD      0x40007400

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;395      */
;;;396    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;398      uint32_t data = 0, tmp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  2700              MOVS     r7,#0
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_DAC_ALIGN(DAC_Align));
000010  b11c              CBZ      r4,|L9.26|
000012  2c04              CMP      r4,#4
000014  d001              BEQ      |L9.26|
000016  2c08              CMP      r4,#8
000018  d101              BNE      |L9.30|
                  |L9.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L9.32|
                  |L9.30|
00001e  2100              MOVS     r1,#0
                  |L9.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;402      assert_param(IS_DAC_DATA(Data1));
000026  f64f71f0          MOV      r1,#0xfff0
00002a  428e              CMP      r6,r1
00002c  dc01              BGT      |L9.50|
00002e  2101              MOVS     r1,#1
000030  e000              B        |L9.52|
                  |L9.50|
000032  2100              MOVS     r1,#0
                  |L9.52|
000034  4608              MOV      r0,r1
000036  f7fffffe          BL       assert_param
;;;403      assert_param(IS_DAC_DATA(Data2));
00003a  f64f71f0          MOV      r1,#0xfff0
00003e  428d              CMP      r5,r1
000040  dc01              BGT      |L9.70|
000042  2101              MOVS     r1,#1
000044  e000              B        |L9.72|
                  |L9.70|
000046  2100              MOVS     r1,#0
                  |L9.72|
000048  4608              MOV      r0,r1
00004a  f7fffffe          BL       assert_param
;;;404      
;;;405      /* Calculate and set dual DAC data holding register value */
;;;406      if (DAC_Align == DAC_Align_8b_R)
00004e  2c08              CMP      r4,#8
000050  d102              BNE      |L9.88|
;;;407      {
;;;408        data = ((uint32_t)Data2 << 8) | Data1; 
000052  ea462805          ORR      r8,r6,r5,LSL #8
000056  e001              B        |L9.92|
                  |L9.88|
;;;409      }
;;;410      else
;;;411      {
;;;412        data = ((uint32_t)Data2 << 16) | Data1;
000058  ea464805          ORR      r8,r6,r5,LSL #16
                  |L9.92|
;;;413      }
;;;414      
;;;415      tmp = (uint32_t)DAC_BASE;
00005c  4f03              LDR      r7,|L9.108|
;;;416      tmp += DHR12RD_OFFSET + DAC_Align;
00005e  f1040020          ADD      r0,r4,#0x20
000062  4407              ADD      r7,r7,r0
;;;417    
;;;418      /* Set the dual DAC selected data holding register */
;;;419      *(__IO uint32_t *)tmp = data;
000064  f8c78000          STR      r8,[r7,#0]
;;;420    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP

                  |L9.108|
                          DCD      0x40007400

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;259      */
;;;260    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;262      /* Check the parameters */
;;;263      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000006  b10c              CBZ      r4,|L10.12|
000008  2c10              CMP      r4,#0x10
00000a  d101              BNE      |L10.16|
                  |L10.12|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L10.18|
                  |L10.16|
000010  2100              MOVS     r1,#0
                  |L10.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
000018  b10d              CBZ      r5,|L10.30|
00001a  2d01              CMP      r5,#1
00001c  d101              BNE      |L10.34|
                  |L10.30|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L10.36|
                  |L10.34|
000022  2100              MOVS     r1,#0
                  |L10.36|
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       assert_param
;;;265      if (NewState != DISABLE)
00002a  b145              CBZ      r5,|L10.62|
;;;266      {
;;;267        /* Enable software trigger for the selected DAC channel */
;;;268        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
00002c  4808              LDR      r0,|L10.80|
00002e  6800              LDR      r0,[r0,#0]
000030  0922              LSRS     r2,r4,#4
000032  2101              MOVS     r1,#1
000034  4091              LSLS     r1,r1,r2
000036  4308              ORRS     r0,r0,r1
000038  4905              LDR      r1,|L10.80|
00003a  6008              STR      r0,[r1,#0]
00003c  e007              B        |L10.78|
                  |L10.62|
;;;269      }
;;;270      else
;;;271      {
;;;272        /* Disable software trigger for the selected DAC channel */
;;;273        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
00003e  4804              LDR      r0,|L10.80|
000040  6800              LDR      r0,[r0,#0]
000042  0922              LSRS     r2,r4,#4
000044  2101              MOVS     r1,#1
000046  4091              LSLS     r1,r1,r2
000048  4388              BICS     r0,r0,r1
00004a  4901              LDR      r1,|L10.80|
00004c  6008              STR      r0,[r1,#0]
                  |L10.78|
;;;274      }
;;;275    }
00004e  bd70              POP      {r4-r6,pc}
;;;276    
                          ENDP

                  |L10.80|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;149      */
;;;150    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;151    {
;;;152    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;153      /* Initialize the DAC_Trigger member */
;;;154      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000002  6001              STR      r1,[r0,#0]
;;;155      /* Initialize the DAC_WaveGeneration member */
;;;156      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000004  6041              STR      r1,[r0,#4]
;;;157      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;158      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000006  6081              STR      r1,[r0,#8]
;;;159      /* Initialize the DAC_OutputBuffer member */
;;;160      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000008  60c1              STR      r1,[r0,#0xc]
;;;161    }
00000a  4770              BX       lr
;;;162    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;313      */
;;;314    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;316      /* Check the parameters */
;;;317      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000008  b10c              CBZ      r4,|L12.14|
00000a  2c10              CMP      r4,#0x10
00000c  d101              BNE      |L12.18|
                  |L12.14|
00000e  2101              MOVS     r1,#1
000010  e000              B        |L12.20|
                  |L12.18|
000012  2100              MOVS     r1,#0
                  |L12.20|
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       assert_param
;;;318      assert_param(IS_DAC_WAVE(DAC_Wave)); 
00001a  2d40              CMP      r5,#0x40
00001c  d001              BEQ      |L12.34|
00001e  2d80              CMP      r5,#0x80
000020  d101              BNE      |L12.38|
                  |L12.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L12.40|
                  |L12.38|
000026  2100              MOVS     r1,#0
                  |L12.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;319      assert_param(IS_FUNCTIONAL_STATE(NewState));
00002e  b10e              CBZ      r6,|L12.52|
000030  2e01              CMP      r6,#1
000032  d101              BNE      |L12.56|
                  |L12.52|
000034  2101              MOVS     r1,#1
000036  e000              B        |L12.58|
                  |L12.56|
000038  2100              MOVS     r1,#0
                  |L12.58|
00003a  4608              MOV      r0,r1
00003c  f7fffffe          BL       assert_param
;;;320      if (NewState != DISABLE)
000040  b13e              CBZ      r6,|L12.82|
;;;321      {
;;;322        /* Enable the selected wave generation for the selected DAC channel */
;;;323        DAC->CR |= DAC_Wave << DAC_Channel;
000042  4808              LDR      r0,|L12.100|
000044  6800              LDR      r0,[r0,#0]
000046  fa05f104          LSL      r1,r5,r4
00004a  4308              ORRS     r0,r0,r1
00004c  4905              LDR      r1,|L12.100|
00004e  6008              STR      r0,[r1,#0]
000050  e006              B        |L12.96|
                  |L12.82|
;;;324      }
;;;325      else
;;;326      {
;;;327        /* Disable the selected wave generation for the selected DAC channel */
;;;328        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000052  4804              LDR      r0,|L12.100|
000054  6800              LDR      r0,[r0,#0]
000056  fa05f104          LSL      r1,r5,r4
00005a  4388              BICS     r0,r0,r1
00005c  4901              LDR      r1,|L12.100|
00005e  6008              STR      r0,[r1,#0]
                  |L12.96|
;;;329      }
;;;330    }
000060  bd70              POP      {r4-r6,pc}
;;;331    
                          ENDP

000062  0000              DCW      0x0000
                  |L12.100|
                          DCD      0x40007400
