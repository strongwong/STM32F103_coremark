; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_cec.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_cec.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_cec.crf ..\Chip\Hal_lib\stm32f10x_cec.c]
                          THUMB

                          AREA ||i.CEC_ClearFlag||, CODE, READONLY, ALIGN=2

                  CEC_ClearFlag PROC
;;;348      */
;;;349    void CEC_ClearFlag(uint32_t CEC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;350    { 
000002  4604              MOV      r4,r0
;;;351      uint32_t tmp = 0x0;
000004  2500              MOVS     r5,#0
;;;352      
;;;353      /* Check the parameters */
;;;354      assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
000006  f02401fc          BIC      r1,r4,#0xfc
00000a  b911              CBNZ     r1,|L1.18|
00000c  b10c              CBZ      r4,|L1.18|
00000e  2101              MOVS     r1,#1
000010  e000              B        |L1.20|
                  |L1.18|
000012  2100              MOVS     r1,#0
                  |L1.20|
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       assert_param
;;;355    
;;;356      tmp = CEC->CSR & 0x2;
00001a  4807              LDR      r0,|L1.56|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0000502          AND      r5,r0,#2
;;;357           
;;;358      /* Clear the selected CEC flags */
;;;359      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
000022  4805              LDR      r0,|L1.56|
000024  6801              LDR      r1,[r0,#0]
000026  f06f0003          MVN      r0,#3
00002a  43a0              BICS     r0,r0,r4
00002c  4328              ORRS     r0,r0,r5
00002e  4001              ANDS     r1,r1,r0
000030  4801              LDR      r0,|L1.56|
000032  6001              STR      r1,[r0,#0]
;;;360    }
000034  bd70              POP      {r4-r6,pc}
;;;361    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40007810

                          AREA ||i.CEC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CEC_ClearITPendingBit PROC
;;;407      */
;;;408    void CEC_ClearITPendingBit(uint16_t CEC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;409    {
000002  4604              MOV      r4,r0
;;;410      uint32_t tmp = 0x0;
000004  2500              MOVS     r5,#0
;;;411      
;;;412      /* Check the parameters */
;;;413      assert_param(IS_CEC_GET_IT(CEC_IT));
000006  2c04              CMP      r4,#4
000008  d005              BEQ      |L2.22|
00000a  2c08              CMP      r4,#8
00000c  d003              BEQ      |L2.22|
00000e  2c40              CMP      r4,#0x40
000010  d001              BEQ      |L2.22|
000012  2c80              CMP      r4,#0x80
000014  d101              BNE      |L2.26|
                  |L2.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L2.28|
                  |L2.26|
00001a  2100              MOVS     r1,#0
                  |L2.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;414      
;;;415      tmp = CEC->CSR & 0x2;
000022  4807              LDR      r0,|L2.64|
000024  6800              LDR      r0,[r0,#0]
000026  f0000502          AND      r5,r0,#2
;;;416      
;;;417      /* Clear the selected CEC interrupt pending bits */
;;;418      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
00002a  4805              LDR      r0,|L2.64|
00002c  6801              LDR      r1,[r0,#0]
00002e  f06f0003          MVN      r0,#3
000032  43a0              BICS     r0,r0,r4
000034  4328              ORRS     r0,r0,r5
000036  4001              ANDS     r1,r1,r0
000038  4801              LDR      r0,|L2.64|
00003a  6001              STR      r1,[r0,#0]
;;;419    }
00003c  bd70              POP      {r4-r6,pc}
;;;420    
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x40007810

                          AREA ||i.CEC_Cmd||, CODE, READONLY, ALIGN=2

                  CEC_Cmd PROC
;;;163      */
;;;164    void CEC_Cmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166      /* Check the parameters */
;;;167      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L3.10|
000006  2c01              CMP      r4,#1
000008  d101              BNE      |L3.14|
                  |L3.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2100              MOVS     r1,#0
                  |L3.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;168    
;;;169      *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
000016  4805              LDR      r0,|L3.44|
000018  6004              STR      r4,[r0,#0]
;;;170    
;;;171      if(NewState == DISABLE)
00001a  b934              CBNZ     r4,|L3.42|
;;;172      {
;;;173        /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
;;;174        while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
00001c  bf00              NOP      
                  |L3.30|
00001e  4804              LDR      r0,|L3.48|
000020  6800              LDR      r0,[r0,#0]
000022  f0000001          AND      r0,r0,#1
000026  2800              CMP      r0,#0
000028  d1f9              BNE      |L3.30|
                  |L3.42|
;;;175        {
;;;176        }  
;;;177      }  
;;;178    }
00002a  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  |L3.44|
                          DCD      0x420f0000
                  |L3.48|
                          DCD      0x40007800

                          AREA ||i.CEC_DeInit||, CODE, READONLY, ALIGN=1

                  CEC_DeInit PROC
;;;117      */
;;;118    void CEC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120      /* Enable CEC reset state */
;;;121      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);  
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;122      /* Release CEC from reset state */
;;;123      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE); 
00000a  2100              MOVS     r1,#0
00000c  f04f4080          MOV      r0,#0x40000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;124    }
000014  bd10              POP      {r4,pc}
;;;125    
                          ENDP


                          AREA ||i.CEC_EndOfMessageCmd||, CODE, READONLY, ALIGN=2

                  CEC_EndOfMessageCmd PROC
;;;261      */
;;;262    void CEC_EndOfMessageCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;263    {   
000002  4604              MOV      r4,r0
;;;264      /* Check the parameters */
;;;265      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L5.10|
000006  2c01              CMP      r4,#1
000008  d101              BNE      |L5.14|
                  |L5.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L5.16|
                  |L5.14|
00000e  2100              MOVS     r1,#0
                  |L5.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;266      
;;;267      /* The data byte will be transmitted with or without an EOM bit*/
;;;268      *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
000016  4801              LDR      r0,|L5.28|
000018  6004              STR      r4,[r0,#0]
;;;269    }
00001a  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L5.28|
                          DCD      0x420f0204

                          AREA ||i.CEC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetFlagStatus PROC
;;;290      */
;;;291    FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;292    {
000004  4604              MOV      r4,r0
;;;293      FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;294      uint32_t cecreg = 0, cecbase = 0;
000008  2700              MOVS     r7,#0
00000a  2500              MOVS     r5,#0
;;;295      
;;;296      /* Check the parameters */
;;;297      assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
00000c  491d              LDR      r1,|L6.132|
00000e  428c              CMP      r4,r1
000010  d01f              BEQ      |L6.82|
000012  491d              LDR      r1,|L6.136|
000014  428c              CMP      r4,r1
000016  d01c              BEQ      |L6.82|
000018  491c              LDR      r1,|L6.140|
00001a  428c              CMP      r4,r1
00001c  d019              BEQ      |L6.82|
00001e  491c              LDR      r1,|L6.144|
000020  428c              CMP      r4,r1
000022  d016              BEQ      |L6.82|
000024  491b              LDR      r1,|L6.148|
000026  428c              CMP      r4,r1
000028  d013              BEQ      |L6.82|
00002a  f1b45f81          CMP      r4,#0x10200000
00002e  d010              BEQ      |L6.82|
000030  f1b45f82          CMP      r4,#0x10400000
000034  d00d              BEQ      |L6.82|
000036  2c02              CMP      r4,#2
000038  d00b              BEQ      |L6.82|
00003a  2c04              CMP      r4,#4
00003c  d009              BEQ      |L6.82|
00003e  2c08              CMP      r4,#8
000040  d007              BEQ      |L6.82|
000042  2c10              CMP      r4,#0x10
000044  d005              BEQ      |L6.82|
000046  2c20              CMP      r4,#0x20
000048  d003              BEQ      |L6.82|
00004a  2c40              CMP      r4,#0x40
00004c  d001              BEQ      |L6.82|
00004e  2c80              CMP      r4,#0x80
000050  d101              BNE      |L6.86|
                  |L6.82|
000052  2101              MOVS     r1,#1
000054  e000              B        |L6.88|
                  |L6.86|
000056  2100              MOVS     r1,#0
                  |L6.88|
000058  4608              MOV      r0,r1
00005a  f7fffffe          BL       assert_param
;;;298     
;;;299      /* Get the CEC peripheral base address */
;;;300      cecbase = (uint32_t)(CEC_BASE);
00005e  4d0e              LDR      r5,|L6.152|
;;;301      
;;;302      /* Read flag register index */
;;;303      cecreg = CEC_FLAG >> 28;
000060  0f27              LSRS     r7,r4,#28
;;;304      
;;;305      /* Get bit[23:0] of the flag */
;;;306      CEC_FLAG &= FLAG_Mask;
000062  f024447f          BIC      r4,r4,#0xff000000
;;;307      
;;;308      if(cecreg != 0)
000066  b117              CBZ      r7,|L6.110|
;;;309      {
;;;310        /* Flag in CEC ESR Register */
;;;311        CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
000068  0c24              LSRS     r4,r4,#16
;;;312        
;;;313        /* Get the CEC ESR register address */
;;;314        cecbase += 0xC;
00006a  350c              ADDS     r5,r5,#0xc
00006c  e000              B        |L6.112|
                  |L6.110|
;;;315      }
;;;316      else
;;;317      {
;;;318        /* Get the CEC CSR register address */
;;;319        cecbase += 0x10;
00006e  3510              ADDS     r5,r5,#0x10
                  |L6.112|
;;;320      }
;;;321      
;;;322      if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
000070  6828              LDR      r0,[r5,#0]
000072  4020              ANDS     r0,r0,r4
000074  b108              CBZ      r0,|L6.122|
;;;323      {
;;;324        /* CEC_FLAG is set */
;;;325        bitstatus = SET;
000076  2601              MOVS     r6,#1
000078  e000              B        |L6.124|
                  |L6.122|
;;;326      }
;;;327      else
;;;328      {
;;;329        /* CEC_FLAG is reset */
;;;330        bitstatus = RESET;
00007a  2600              MOVS     r6,#0
                  |L6.124|
;;;331      }
;;;332      
;;;333      /* Return the CEC_FLAG status */
;;;334      return  bitstatus;
00007c  4630              MOV      r0,r6
;;;335    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;336    
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      0x10010000
                  |L6.136|
                          DCD      0x10020000
                  |L6.140|
                          DCD      0x10040000
                  |L6.144|
                          DCD      0x10080000
                  |L6.148|
                          DCD      0x10100000
                  |L6.152|
                          DCD      0x40007800

                          AREA ||i.CEC_GetITStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetITStatus PROC
;;;371      */
;;;372    ITStatus CEC_GetITStatus(uint8_t CEC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;373    {
000002  4604              MOV      r4,r0
;;;374      ITStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;375      uint32_t enablestatus = 0;
000006  2600              MOVS     r6,#0
;;;376      
;;;377      /* Check the parameters */
;;;378       assert_param(IS_CEC_GET_IT(CEC_IT));
000008  2c04              CMP      r4,#4
00000a  d005              BEQ      |L7.24|
00000c  2c08              CMP      r4,#8
00000e  d003              BEQ      |L7.24|
000010  2c40              CMP      r4,#0x40
000012  d001              BEQ      |L7.24|
000014  2c80              CMP      r4,#0x80
000016  d101              BNE      |L7.28|
                  |L7.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L7.30|
                  |L7.28|
00001c  2100              MOVS     r1,#0
                  |L7.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;379       
;;;380      /* Get the CEC IT enable bit status */
;;;381      enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
000024  4807              LDR      r0,|L7.68|
000026  6800              LDR      r0,[r0,#0]
000028  f0000602          AND      r6,r0,#2
;;;382      
;;;383      /* Check the status of the specified CEC interrupt */
;;;384      if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
00002c  4805              LDR      r0,|L7.68|
00002e  3010              ADDS     r0,r0,#0x10
000030  6800              LDR      r0,[r0,#0]
000032  4020              ANDS     r0,r0,r4
000034  b110              CBZ      r0,|L7.60|
000036  b10e              CBZ      r6,|L7.60|
;;;385      {
;;;386        /* CEC_IT is set */
;;;387        bitstatus = SET;
000038  2501              MOVS     r5,#1
00003a  e000              B        |L7.62|
                  |L7.60|
;;;388      }
;;;389      else
;;;390      {
;;;391        /* CEC_IT is reset */
;;;392        bitstatus = RESET;
00003c  2500              MOVS     r5,#0
                  |L7.62|
;;;393      }
;;;394      /* Return the CEC_IT status */
;;;395      return  bitstatus;
00003e  4628              MOV      r0,r5
;;;396    }
000040  bd70              POP      {r4-r6,pc}
;;;397    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x40007800

                          AREA ||i.CEC_ITConfig||, CODE, READONLY, ALIGN=2

                  CEC_ITConfig PROC
;;;185      */
;;;186    void CEC_ITConfig(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;187    {
000002  4604              MOV      r4,r0
;;;188      /* Check the parameters */
;;;189      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L8.10|
000006  2c01              CMP      r4,#1
000008  d101              BNE      |L8.14|
                  |L8.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L8.16|
                  |L8.14|
00000e  2100              MOVS     r1,#0
                  |L8.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;190    
;;;191      *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
000016  4801              LDR      r0,|L8.28|
000018  6044              STR      r4,[r0,#4]
;;;192    }
00001a  bd10              POP      {r4,pc}
;;;193    
                          ENDP

                  |L8.28|
                          DCD      0x420f0000

                          AREA ||i.CEC_Init||, CODE, READONLY, ALIGN=2

                  CEC_Init PROC
;;;134      */
;;;135    void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4604              MOV      r4,r0
;;;137      uint16_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;138     
;;;139      /* Check the parameters */
;;;140      assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode)); 
000006  8821              LDRH     r1,[r4,#0]
000008  b111              CBZ      r1,|L9.16|
00000a  8821              LDRH     r1,[r4,#0]
00000c  2904              CMP      r1,#4
00000e  d101              BNE      |L9.20|
                  |L9.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L9.22|
                  |L9.20|
000014  2100              MOVS     r1,#0
                  |L9.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;141      assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
00001c  8861              LDRH     r1,[r4,#2]
00001e  b111              CBZ      r1,|L9.38|
000020  8861              LDRH     r1,[r4,#2]
000022  2908              CMP      r1,#8
000024  d101              BNE      |L9.42|
                  |L9.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L9.44|
                  |L9.42|
00002a  2100              MOVS     r1,#0
                  |L9.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;142         
;;;143      /*---------------------------- CEC CFGR Configuration -----------------*/
;;;144      /* Get the CEC CFGR value */
;;;145      tmpreg = CEC->CFGR;
000032  4806              LDR      r0,|L9.76|
000034  6800              LDR      r0,[r0,#0]
000036  b285              UXTH     r5,r0
;;;146      
;;;147      /* Clear BTEM and BPEM bits */
;;;148      tmpreg &= CFGR_CLEAR_Mask;
000038  f00505f3          AND      r5,r5,#0xf3
;;;149      
;;;150      /* Configure CEC: Bit Timing Error and Bit Period Error */
;;;151      tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
00003c  8820              LDRH     r0,[r4,#0]
00003e  8861              LDRH     r1,[r4,#2]
000040  4308              ORRS     r0,r0,r1
000042  4305              ORRS     r5,r5,r0
;;;152    
;;;153      /* Write to CEC CFGR  register*/
;;;154      CEC->CFGR = tmpreg;
000044  4801              LDR      r0,|L9.76|
000046  6005              STR      r5,[r0,#0]
;;;155      
;;;156    }
000048  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      0x40007800

                          AREA ||i.CEC_OwnAddressConfig||, CODE, READONLY, ALIGN=2

                  CEC_OwnAddressConfig PROC
;;;198      */
;;;199    void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
000000  b510              PUSH     {r4,lr}
;;;200    {
000002  4604              MOV      r4,r0
;;;201      /* Check the parameters */
;;;202      assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
000004  2c10              CMP      r4,#0x10
000006  da01              BGE      |L10.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  2100              MOVS     r1,#0
                  |L10.14|
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       assert_param
;;;203    
;;;204      /* Set the CEC own address */
;;;205      CEC->OAR = CEC_OwnAddress;
000014  4801              LDR      r0,|L10.28|
000016  6004              STR      r4,[r0,#0]
;;;206    }
000018  bd10              POP      {r4,pc}
;;;207    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40007804

                          AREA ||i.CEC_ReceiveDataByte||, CODE, READONLY, ALIGN=2

                  CEC_ReceiveDataByte PROC
;;;238      */
;;;239    uint8_t CEC_ReceiveDataByte(void)
000000  4801              LDR      r0,|L11.8|
;;;240    {
;;;241      /* Receive Data */
;;;242      return (uint8_t)(CEC->RXD);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;243    }
000006  4770              BX       lr
;;;244    
                          ENDP

                  |L11.8|
                          DCD      0x40007818

                          AREA ||i.CEC_SendDataByte||, CODE, READONLY, ALIGN=2

                  CEC_SendDataByte PROC
;;;226      */
;;;227    void CEC_SendDataByte(uint8_t Data)
000000  4901              LDR      r1,|L12.8|
;;;228    {  
;;;229      /* Transmit Data */
;;;230      CEC->TXD = Data ;
000002  6008              STR      r0,[r1,#0]
;;;231    }
000004  4770              BX       lr
;;;232    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40007814

                          AREA ||i.CEC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  CEC_SetPrescaler PROC
;;;212      */
;;;213    void CEC_SetPrescaler(uint16_t CEC_Prescaler)
000000  b510              PUSH     {r4,lr}
;;;214    {
000002  4604              MOV      r4,r0
;;;215      /* Check the parameters */
;;;216      assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
000004  f5b44f80          CMP      r4,#0x4000
000008  da01              BGE      |L13.14|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L13.16|
                  |L13.14|
00000e  2100              MOVS     r1,#0
                  |L13.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;217    
;;;218      /* Set the  Prescaler value*/
;;;219      CEC->PRES = CEC_Prescaler;
000016  4801              LDR      r0,|L13.28|
000018  6004              STR      r4,[r0,#0]
;;;220    }
00001a  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  |L13.28|
                          DCD      0x40007808

                          AREA ||i.CEC_StartOfMessage||, CODE, READONLY, ALIGN=2

                  CEC_StartOfMessage PROC
;;;249      */
;;;250    void CEC_StartOfMessage(void)
000000  2001              MOVS     r0,#1
;;;251    {  
;;;252      /* Starts of new message */
;;;253      *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
000002  4901              LDR      r1,|L14.8|
000004  6008              STR      r0,[r1,#0]
;;;254    }
000006  4770              BX       lr
;;;255    
                          ENDP

                  |L14.8|
                          DCD      0x420f0200
