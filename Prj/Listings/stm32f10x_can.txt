; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_can.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_can.crf ..\Chip\Hal_lib\stm32f10x_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=2

                  CAN_CancelTransmit PROC
;;;642      */
;;;643    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b570              PUSH     {r4-r6,lr}
;;;644    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;645      /* Check the parameters */
;;;646      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4916              LDR      r1,|L1.96|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L1.18|
00000c  4915              LDR      r1,|L1.100|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L1.22|
                  |L1.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L1.24|
                  |L1.22|
000016  2100              MOVS     r1,#0
                  |L1.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;647      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
00001e  2d02              CMP      r5,#2
000020  dc01              BGT      |L1.38|
000022  2101              MOVS     r1,#1
000024  e000              B        |L1.40|
                  |L1.38|
000026  2100              MOVS     r1,#0
                  |L1.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;648      /* abort transmission */
;;;649      switch (Mailbox)
00002e  b125              CBZ      r5,|L1.58|
000030  2d01              CMP      r5,#1
000032  d007              BEQ      |L1.68|
000034  2d02              CMP      r5,#2
000036  d10f              BNE      |L1.88|
000038  e009              B        |L1.78|
                  |L1.58|
;;;650      {
;;;651        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
00003a  68a0              LDR      r0,[r4,#8]
00003c  f0400080          ORR      r0,r0,#0x80
000040  60a0              STR      r0,[r4,#8]
;;;652          break;
000042  e00a              B        |L1.90|
                  |L1.68|
;;;653        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
000044  68a0              LDR      r0,[r4,#8]
000046  f4404000          ORR      r0,r0,#0x8000
00004a  60a0              STR      r0,[r4,#8]
;;;654          break;
00004c  e005              B        |L1.90|
                  |L1.78|
;;;655        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
00004e  68a0              LDR      r0,[r4,#8]
000050  f4400000          ORR      r0,r0,#0x800000
000054  60a0              STR      r0,[r4,#8]
;;;656          break;
000056  e000              B        |L1.90|
                  |L1.88|
;;;657        default:
;;;658          break;
000058  bf00              NOP      
                  |L1.90|
00005a  bf00              NOP                            ;652
;;;659      }
;;;660    }
00005c  bd70              POP      {r4-r6,pc}
;;;661    
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      0x40006400
                  |L1.100|
                          DCD      0x40006800

                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1142     */
;;;1143   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1144   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1145     uint32_t flagtmp=0;
000006  2600              MOVS     r6,#0
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  4926              LDR      r1,|L2.164|
00000a  428d              CMP      r5,r1
00000c  d002              BEQ      |L2.20|
00000e  4926              LDR      r1,|L2.168|
000010  428d              CMP      r5,r1
000012  d101              BNE      |L2.24|
                  |L2.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L2.26|
                  |L2.24|
000018  2100              MOVS     r1,#0
                  |L2.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1148     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
000020  4922              LDR      r1,|L2.172|
000022  428c              CMP      r4,r1
000024  d01e              BEQ      |L2.100|
000026  4922              LDR      r1,|L2.176|
000028  428c              CMP      r4,r1
00002a  d01b              BEQ      |L2.100|
00002c  4921              LDR      r1,|L2.180|
00002e  428c              CMP      r4,r1
000030  d018              BEQ      |L2.100|
000032  4920              LDR      r1,|L2.180|
000034  39ff              SUBS     r1,r1,#0xff
000036  428c              CMP      r4,r1
000038  d014              BEQ      |L2.100|
00003a  491f              LDR      r1,|L2.184|
00003c  428c              CMP      r4,r1
00003e  d011              BEQ      |L2.100|
000040  491d              LDR      r1,|L2.184|
000042  3108              ADDS     r1,r1,#8
000044  428c              CMP      r4,r1
000046  d00d              BEQ      |L2.100|
000048  491c              LDR      r1,|L2.188|
00004a  428c              CMP      r4,r1
00004c  d00a              BEQ      |L2.100|
00004e  491b              LDR      r1,|L2.188|
000050  3108              ADDS     r1,r1,#8
000052  428c              CMP      r4,r1
000054  d006              BEQ      |L2.100|
000056  491a              LDR      r1,|L2.192|
000058  428c              CMP      r4,r1
00005a  d003              BEQ      |L2.100|
00005c  4918              LDR      r1,|L2.192|
00005e  310a              ADDS     r1,r1,#0xa
000060  428c              CMP      r4,r1
000062  d101              BNE      |L2.104|
                  |L2.100|
000064  2101              MOVS     r1,#1
000066  e000              B        |L2.106|
                  |L2.104|
000068  2100              MOVS     r1,#0
                  |L2.106|
00006a  4608              MOV      r0,r1
00006c  f7fffffe          BL       assert_param
;;;1149     
;;;1150     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000070  480e              LDR      r0,|L2.172|
000072  4284              CMP      r4,r0
000074  d102              BNE      |L2.124|
;;;1151     {
;;;1152       /* Clear the selected CAN flags */
;;;1153       CANx->ESR = (uint32_t)RESET;
000076  2000              MOVS     r0,#0
000078  61a8              STR      r0,[r5,#0x18]
00007a  e011              B        |L2.160|
                  |L2.124|
;;;1154     }
;;;1155     else /* MSR or TSR or RF0R or RF1R */
;;;1156     {
;;;1157       flagtmp = CAN_FLAG & 0x000FFFFF;
00007c  f3c40613          UBFX     r6,r4,#0,#20
;;;1158   
;;;1159       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
000080  f0047000          AND      r0,r4,#0x2000000
000084  b108              CBZ      r0,|L2.138|
;;;1160       {
;;;1161         /* Receive Flags */
;;;1162         CANx->RF0R = (uint32_t)(flagtmp);
000086  60ee              STR      r6,[r5,#0xc]
000088  e00a              B        |L2.160|
                  |L2.138|
;;;1163       }
;;;1164       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
00008a  f0046080          AND      r0,r4,#0x4000000
00008e  b108              CBZ      r0,|L2.148|
;;;1165       {
;;;1166         /* Receive Flags */
;;;1167         CANx->RF1R = (uint32_t)(flagtmp);
000090  612e              STR      r6,[r5,#0x10]
000092  e005              B        |L2.160|
                  |L2.148|
;;;1168       }
;;;1169       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
000094  f0046000          AND      r0,r4,#0x8000000
000098  b108              CBZ      r0,|L2.158|
;;;1170       {
;;;1171         /* Transmit Flags */
;;;1172         CANx->TSR = (uint32_t)(flagtmp);
00009a  60ae              STR      r6,[r5,#8]
00009c  e000              B        |L2.160|
                  |L2.158|
;;;1173       }
;;;1174       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1175       {
;;;1176         /* Operating mode Flags */
;;;1177         CANx->MSR = (uint32_t)(flagtmp);
00009e  606e              STR      r6,[r5,#4]
                  |L2.160|
;;;1178       }
;;;1179     }
;;;1180   }
0000a0  bd70              POP      {r4-r6,pc}
;;;1181   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L2.164|
                          DCD      0x40006400
                  |L2.168|
                          DCD      0x40006800
                  |L2.172|
                          DCD      0x30f00070
                  |L2.176|
                          DCD      0x38010000
                  |L2.180|
                          DCD      0x38000100
                  |L2.184|
                          DCD      0x32000008
                  |L2.188|
                          DCD      0x34000008
                  |L2.192|
                          DCD      0x31000008

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1305     */
;;;1306   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1307   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4941              LDR      r1,|L3.268|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L3.18|
00000c  4940              LDR      r1,|L3.272|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L3.22|
                  |L3.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L3.24|
                  |L3.22|
000016  2100              MOVS     r1,#0
                  |L3.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;1310     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
00001e  2d01              CMP      r5,#1
000020  d01c              BEQ      |L3.92|
000022  2d04              CMP      r5,#4
000024  d01a              BEQ      |L3.92|
000026  2d08              CMP      r5,#8
000028  d018              BEQ      |L3.92|
00002a  2d20              CMP      r5,#0x20
00002c  d016              BEQ      |L3.92|
00002e  2d40              CMP      r5,#0x40
000030  d014              BEQ      |L3.92|
000032  f5b57f80          CMP      r5,#0x100
000036  d011              BEQ      |L3.92|
000038  f5b57f00          CMP      r5,#0x200
00003c  d00e              BEQ      |L3.92|
00003e  f5b56f80          CMP      r5,#0x400
000042  d00b              BEQ      |L3.92|
000044  f5b56f00          CMP      r5,#0x800
000048  d008              BEQ      |L3.92|
00004a  f5b54f00          CMP      r5,#0x8000
00004e  d005              BEQ      |L3.92|
000050  f5b53f80          CMP      r5,#0x10000
000054  d002              BEQ      |L3.92|
000056  f5b53f00          CMP      r5,#0x20000
00005a  d101              BNE      |L3.96|
                  |L3.92|
00005c  2101              MOVS     r1,#1
00005e  e000              B        |L3.98|
                  |L3.96|
000060  2100              MOVS     r1,#0
                  |L3.98|
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       assert_param
;;;1311   
;;;1312     switch (CAN_IT)
000068  f5b57f00          CMP      r5,#0x200
00006c  d03a              BEQ      |L3.228|
00006e  dc0f              BGT      |L3.144|
000070  2d20              CMP      r5,#0x20
000072  d028              BEQ      |L3.198|
000074  dc06              BGT      |L3.132|
000076  2d01              CMP      r5,#1
000078  d01c              BEQ      |L3.180|
00007a  2d04              CMP      r5,#4
00007c  d01d              BEQ      |L3.186|
00007e  2d08              CMP      r5,#8
000080  d140              BNE      |L3.260|
000082  e01d              B        |L3.192|
                  |L3.132|
000084  2d40              CMP      r5,#0x40
000086  d021              BEQ      |L3.204|
000088  f5b57f80          CMP      r5,#0x100
00008c  d13a              BNE      |L3.260|
00008e  e026              B        |L3.222|
                  |L3.144|
000090  f5b54f00          CMP      r5,#0x8000
000094  d031              BEQ      |L3.250|
000096  dc06              BGT      |L3.166|
000098  f5b56f80          CMP      r5,#0x400
00009c  d025              BEQ      |L3.234|
00009e  f5b56f00          CMP      r5,#0x800
0000a2  d12f              BNE      |L3.260|
0000a4  e024              B        |L3.240|
                  |L3.166|
0000a6  f5b53f80          CMP      r5,#0x10000
0000aa  d012              BEQ      |L3.210|
0000ac  f5b53f00          CMP      r5,#0x20000
0000b0  d128              BNE      |L3.260|
0000b2  e011              B        |L3.216|
                  |L3.180|
;;;1313     {
;;;1314         case CAN_IT_TME:
;;;1315                 /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1316   	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
0000b4  4817              LDR      r0,|L3.276|
0000b6  60a0              STR      r0,[r4,#8]
;;;1317   	      break;
0000b8  e025              B        |L3.262|
                  |L3.186|
;;;1318         case CAN_IT_FF0:
;;;1319                 /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1320   	      CANx->RF0R = CAN_RF0R_FULL0; 
0000ba  2008              MOVS     r0,#8
0000bc  60e0              STR      r0,[r4,#0xc]
;;;1321   	      break;
0000be  e022              B        |L3.262|
                  |L3.192|
;;;1322         case CAN_IT_FOV0:
;;;1323                 /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1324   	      CANx->RF0R = CAN_RF0R_FOVR0; 
0000c0  2010              MOVS     r0,#0x10
0000c2  60e0              STR      r0,[r4,#0xc]
;;;1325   	      break;
0000c4  e01f              B        |L3.262|
                  |L3.198|
;;;1326         case CAN_IT_FF1:
;;;1327                 /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1328   	      CANx->RF1R = CAN_RF1R_FULL1;  
0000c6  2008              MOVS     r0,#8
0000c8  6120              STR      r0,[r4,#0x10]
;;;1329   	      break;
0000ca  e01c              B        |L3.262|
                  |L3.204|
;;;1330         case CAN_IT_FOV1:
;;;1331                 /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1332   	      CANx->RF1R = CAN_RF1R_FOVR1; 
0000cc  2010              MOVS     r0,#0x10
0000ce  6120              STR      r0,[r4,#0x10]
;;;1333   	      break;
0000d0  e019              B        |L3.262|
                  |L3.210|
;;;1334         case CAN_IT_WKU:
;;;1335                 /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1336   	      CANx->MSR = CAN_MSR_WKUI;  
0000d2  2008              MOVS     r0,#8
0000d4  6060              STR      r0,[r4,#4]
;;;1337   	      break;
0000d6  e016              B        |L3.262|
                  |L3.216|
;;;1338         case CAN_IT_SLK:
;;;1339                 /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1340   	      CANx->MSR = CAN_MSR_SLAKI;   
0000d8  2010              MOVS     r0,#0x10
0000da  6060              STR      r0,[r4,#4]
;;;1341   	      break;
0000dc  e013              B        |L3.262|
                  |L3.222|
;;;1342         case CAN_IT_EWG:
;;;1343                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1344   	      CANx->MSR = CAN_MSR_ERRI;
0000de  2004              MOVS     r0,#4
0000e0  6060              STR      r0,[r4,#4]
;;;1345                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1346                           of the CAN Bus status*/ 
;;;1347   	      break;
0000e2  e010              B        |L3.262|
                  |L3.228|
;;;1348         case CAN_IT_EPV:
;;;1349                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1350   	      CANx->MSR = CAN_MSR_ERRI; 
0000e4  2004              MOVS     r0,#4
0000e6  6060              STR      r0,[r4,#4]
;;;1351                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1352                           of the CAN Bus status*/
;;;1353   	      break;
0000e8  e00d              B        |L3.262|
                  |L3.234|
;;;1354         case CAN_IT_BOF:
;;;1355                 /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1356   	      CANx->MSR = CAN_MSR_ERRI; 
0000ea  2004              MOVS     r0,#4
0000ec  6060              STR      r0,[r4,#4]
;;;1357                 /* Note : the corresponding Flag is cleared by hardware depending 
;;;1358                           of the CAN Bus status*/
;;;1359   	      break;
0000ee  e00a              B        |L3.262|
                  |L3.240|
;;;1360         case CAN_IT_LEC:
;;;1361                 /*  Clear LEC bits */
;;;1362   	      CANx->ESR = RESET; 
0000f0  2000              MOVS     r0,#0
0000f2  61a0              STR      r0,[r4,#0x18]
;;;1363                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1364   	      CANx->MSR = CAN_MSR_ERRI; 
0000f4  2004              MOVS     r0,#4
0000f6  6060              STR      r0,[r4,#4]
;;;1365   	      break;
0000f8  e005              B        |L3.262|
                  |L3.250|
;;;1366         case CAN_IT_ERR:
;;;1367                 /*Clear LEC bits */
;;;1368   	      CANx->ESR = RESET; 
0000fa  2000              MOVS     r0,#0
0000fc  61a0              STR      r0,[r4,#0x18]
;;;1369                 /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1370   	      CANx->MSR = CAN_MSR_ERRI; 
0000fe  2004              MOVS     r0,#4
000100  6060              STR      r0,[r4,#4]
;;;1371   	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending 
;;;1372                     of the CAN Bus status*/
;;;1373   	      break;
000102  e000              B        |L3.262|
                  |L3.260|
;;;1374         default :
;;;1375   	      break;
000104  bf00              NOP      
                  |L3.262|
000106  bf00              NOP                            ;1317
;;;1376      }
;;;1377   }
000108  bd70              POP      {r4-r6,pc}
;;;1378   
                          ENDP

00010a  0000              DCW      0x0000
                  |L3.268|
                          DCD      0x40006400
                  |L3.272|
                          DCD      0x40006800
                  |L3.276|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=2

                  CAN_DBGFreeze PROC
;;;450      */
;;;451    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;453      /* Check the parameters */
;;;454      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4910              LDR      r1,|L4.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L4.18|
00000c  490f              LDR      r1,|L4.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L4.22|
                  |L4.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L4.24|
                  |L4.22|
000016  2100              MOVS     r1,#0
                  |L4.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;455      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L4.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L4.40|
                  |L4.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L4.42|
                  |L4.40|
000028  2100              MOVS     r1,#0
                  |L4.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;456      
;;;457      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L4.60|
;;;458      {
;;;459        /* Enable Debug Freeze  */
;;;460        CANx->MCR |= MCR_DBF;
000032  6820              LDR      r0,[r4,#0]
000034  f4403080          ORR      r0,r0,#0x10000
000038  6020              STR      r0,[r4,#0]
00003a  e003              B        |L4.68|
                  |L4.60|
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Disable Debug Freeze */
;;;465        CANx->MCR &= ~MCR_DBF;
00003c  6820              LDR      r0,[r4,#0]
00003e  f4203080          BIC      r0,r0,#0x10000
000042  6020              STR      r0,[r4,#0]
                  |L4.68|
;;;466      }
;;;467    }
000044  bd70              POP      {r4-r6,pc}
;;;468    
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x40006400
                  |L4.76|
                          DCD      0x40006800

                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;121      */
;;;122    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124      /* Check the parameters */
;;;125      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4911              LDR      r1,|L5.76|
000006  428c              CMP      r4,r1
000008  d002              BEQ      |L5.16|
00000a  4911              LDR      r1,|L5.80|
00000c  428c              CMP      r4,r1
00000e  d101              BNE      |L5.20|
                  |L5.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L5.22|
                  |L5.20|
000014  2100              MOVS     r1,#0
                  |L5.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;126     
;;;127      if (CANx == CAN1)
00001c  480b              LDR      r0,|L5.76|
00001e  4284              CMP      r4,r0
000020  d109              BNE      |L5.54|
;;;128      {
;;;129        /* Enable CAN1 reset state */
;;;130        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
000022  2101              MOVS     r1,#1
000024  0648              LSLS     r0,r1,#25
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;131        /* Release CAN1 from reset state */
;;;132        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  f04f7000          MOV      r0,#0x2000000
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  e008              B        |L5.72|
                  |L5.54|
;;;133      }
;;;134      else
;;;135      {  
;;;136        /* Enable CAN2 reset state */
;;;137        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
000036  2101              MOVS     r1,#1
000038  0688              LSLS     r0,r1,#26
00003a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;138        /* Release CAN2 from reset state */
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
00003e  2100              MOVS     r1,#0
000040  f04f6080          MOV      r0,#0x4000000
000044  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.72|
;;;140      }
;;;141    }
000048  bd10              POP      {r4,pc}
;;;142    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x40006400
                  |L5.80|
                          DCD      0x40006800

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=2

                  CAN_FIFORelease PROC
;;;719      */
;;;720    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b570              PUSH     {r4-r6,lr}
;;;721    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;722      /* Check the parameters */
;;;723      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4910              LDR      r1,|L6.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L6.18|
00000c  490f              LDR      r1,|L6.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L6.22|
                  |L6.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L6.24|
                  |L6.22|
000016  2100              MOVS     r1,#0
                  |L6.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;724      assert_param(IS_CAN_FIFO(FIFONumber));
00001e  b10d              CBZ      r5,|L6.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L6.40|
                  |L6.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L6.42|
                  |L6.40|
000028  2100              MOVS     r1,#0
                  |L6.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;725      /* Release FIFO0 */
;;;726      if (FIFONumber == CAN_FIFO0)
000030  b925              CBNZ     r5,|L6.60|
;;;727      {
;;;728        CANx->RF0R |= CAN_RF0R_RFOM0;
000032  68e0              LDR      r0,[r4,#0xc]
000034  f0400020          ORR      r0,r0,#0x20
000038  60e0              STR      r0,[r4,#0xc]
00003a  e003              B        |L6.68|
                  |L6.60|
;;;729      }
;;;730      /* Release FIFO1 */
;;;731      else /* FIFONumber == CAN_FIFO1 */
;;;732      {
;;;733        CANx->RF1R |= CAN_RF1R_RFOM1;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0400020          ORR      r0,r0,#0x20
000042  6120              STR      r0,[r4,#0x10]
                  |L6.68|
;;;734      }
;;;735    }
000044  bd70              POP      {r4-r6,pc}
;;;736    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0x40006400
                  |L6.76|
                          DCD      0x40006800

                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;291      */
;;;292    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;293    {
000002  4604              MOV      r4,r0
;;;294      uint32_t filter_number_bit_pos = 0;
000004  2500              MOVS     r5,#0
;;;295      /* Check the parameters */
;;;296      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
000006  7aa1              LDRB     r1,[r4,#0xa]
000008  290d              CMP      r1,#0xd
00000a  dc01              BGT      |L7.16|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L7.18|
                  |L7.16|
000010  2100              MOVS     r1,#0
                  |L7.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;297      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
000018  7ae1              LDRB     r1,[r4,#0xb]
00001a  b111              CBZ      r1,|L7.34|
00001c  7ae1              LDRB     r1,[r4,#0xb]
00001e  2901              CMP      r1,#1
000020  d101              BNE      |L7.38|
                  |L7.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L7.40|
                  |L7.38|
000026  2100              MOVS     r1,#0
                  |L7.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;298      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
00002e  7b21              LDRB     r1,[r4,#0xc]
000030  b111              CBZ      r1,|L7.56|
000032  7b21              LDRB     r1,[r4,#0xc]
000034  2901              CMP      r1,#1
000036  d101              BNE      |L7.60|
                  |L7.56|
000038  2101              MOVS     r1,#1
00003a  e000              B        |L7.62|
                  |L7.60|
00003c  2100              MOVS     r1,#0
                  |L7.62|
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       assert_param
;;;299      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
000044  8921              LDRH     r1,[r4,#8]
000046  b111              CBZ      r1,|L7.78|
000048  8921              LDRH     r1,[r4,#8]
00004a  2901              CMP      r1,#1
00004c  d101              BNE      |L7.82|
                  |L7.78|
00004e  2101              MOVS     r1,#1
000050  e000              B        |L7.84|
                  |L7.82|
000052  2100              MOVS     r1,#0
                  |L7.84|
000054  4608              MOV      r0,r1
000056  f7fffffe          BL       assert_param
;;;300      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
00005a  7b61              LDRB     r1,[r4,#0xd]
00005c  b111              CBZ      r1,|L7.100|
00005e  7b61              LDRB     r1,[r4,#0xd]
000060  2901              CMP      r1,#1
000062  d101              BNE      |L7.104|
                  |L7.100|
000064  2101              MOVS     r1,#1
000066  e000              B        |L7.106|
                  |L7.104|
000068  2100              MOVS     r1,#0
                  |L7.106|
00006a  4608              MOV      r0,r1
00006c  f7fffffe          BL       assert_param
;;;301    
;;;302      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000070  7aa1              LDRB     r1,[r4,#0xa]
000072  2001              MOVS     r0,#1
000074  fa00f501          LSL      r5,r0,r1
;;;303    
;;;304      /* Initialisation mode for the filter */
;;;305      CAN1->FMR |= FMR_FINIT;
000078  483d              LDR      r0,|L7.368|
00007a  6800              LDR      r0,[r0,#0]
00007c  f0400001          ORR      r0,r0,#1
000080  493b              LDR      r1,|L7.368|
000082  6008              STR      r0,[r1,#0]
;;;306    
;;;307      /* Filter Deactivation */
;;;308      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000084  483a              LDR      r0,|L7.368|
000086  301c              ADDS     r0,r0,#0x1c
000088  6800              LDR      r0,[r0,#0]
00008a  43a8              BICS     r0,r0,r5
00008c  4938              LDR      r1,|L7.368|
00008e  311c              ADDS     r1,r1,#0x1c
000090  6008              STR      r0,[r1,#0]
;;;309    
;;;310      /* Filter Scale */
;;;311      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000092  7b20              LDRB     r0,[r4,#0xc]
000094  b9c8              CBNZ     r0,|L7.202|
;;;312      {
;;;313        /* 16-bit scale for the filter */
;;;314        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
000096  4836              LDR      r0,|L7.368|
000098  300c              ADDS     r0,r0,#0xc
00009a  6800              LDR      r0,[r0,#0]
00009c  43a8              BICS     r0,r0,r5
00009e  4934              LDR      r1,|L7.368|
0000a0  310c              ADDS     r1,r1,#0xc
0000a2  6008              STR      r0,[r1,#0]
;;;315    
;;;316        /* First 16-bit identifier and First 16-bit mask */
;;;317        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;318        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
0000a4  8860              LDRH     r0,[r4,#2]
0000a6  88e1              LDRH     r1,[r4,#6]
0000a8  ea404101          ORR      r1,r0,r1,LSL #16
0000ac  4830              LDR      r0,|L7.368|
0000ae  3040              ADDS     r0,r0,#0x40
0000b0  7aa2              LDRB     r2,[r4,#0xa]
0000b2  f8401032          STR      r1,[r0,r2,LSL #3]
;;;319        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;320            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;321    
;;;322        /* Second 16-bit identifier and Second 16-bit mask */
;;;323        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;324        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0000b6  8820              LDRH     r0,[r4,#0]
0000b8  88a1              LDRH     r1,[r4,#4]
0000ba  ea404101          ORR      r1,r0,r1,LSL #16
0000be  482c              LDR      r0,|L7.368|
0000c0  3040              ADDS     r0,r0,#0x40
0000c2  7aa2              LDRB     r2,[r4,#0xa]
0000c4  eb0000c2          ADD      r0,r0,r2,LSL #3
0000c8  6041              STR      r1,[r0,#4]
                  |L7.202|
;;;325        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;326            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;327      }
;;;328    
;;;329      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
0000ca  7b20              LDRB     r0,[r4,#0xc]
0000cc  2801              CMP      r0,#1
0000ce  d119              BNE      |L7.260|
;;;330      {
;;;331        /* 32-bit scale for the filter */
;;;332        CAN1->FS1R |= filter_number_bit_pos;
0000d0  4827              LDR      r0,|L7.368|
0000d2  300c              ADDS     r0,r0,#0xc
0000d4  6800              LDR      r0,[r0,#0]
0000d6  4328              ORRS     r0,r0,r5
0000d8  4925              LDR      r1,|L7.368|
0000da  310c              ADDS     r1,r1,#0xc
0000dc  6008              STR      r0,[r1,#0]
;;;333        /* 32-bit identifier or First 32-bit identifier */
;;;334        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
0000de  8860              LDRH     r0,[r4,#2]
0000e0  8821              LDRH     r1,[r4,#0]
0000e2  ea404101          ORR      r1,r0,r1,LSL #16
0000e6  4822              LDR      r0,|L7.368|
0000e8  3040              ADDS     r0,r0,#0x40
0000ea  7aa2              LDRB     r2,[r4,#0xa]
0000ec  f8401032          STR      r1,[r0,r2,LSL #3]
;;;335        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;336            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;337        /* 32-bit mask or Second 32-bit identifier */
;;;338        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0000f0  88e0              LDRH     r0,[r4,#6]
0000f2  88a1              LDRH     r1,[r4,#4]
0000f4  ea404101          ORR      r1,r0,r1,LSL #16
0000f8  481d              LDR      r0,|L7.368|
0000fa  3040              ADDS     r0,r0,#0x40
0000fc  7aa2              LDRB     r2,[r4,#0xa]
0000fe  eb0000c2          ADD      r0,r0,r2,LSL #3
000102  6041              STR      r1,[r0,#4]
                  |L7.260|
;;;339        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;340            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;341      }
;;;342    
;;;343      /* Filter Mode */
;;;344      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
000104  7ae0              LDRB     r0,[r4,#0xb]
000106  b938              CBNZ     r0,|L7.280|
;;;345      {
;;;346        /*Id/Mask mode for the filter*/
;;;347        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
000108  4819              LDR      r0,|L7.368|
00010a  1d00              ADDS     r0,r0,#4
00010c  6800              LDR      r0,[r0,#0]
00010e  43a8              BICS     r0,r0,r5
000110  4917              LDR      r1,|L7.368|
000112  1d09              ADDS     r1,r1,#4
000114  6008              STR      r0,[r1,#0]
000116  e006              B        |L7.294|
                  |L7.280|
;;;348      }
;;;349      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;350      {
;;;351        /*Identifier list mode for the filter*/
;;;352        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
000118  4815              LDR      r0,|L7.368|
00011a  1d00              ADDS     r0,r0,#4
00011c  6800              LDR      r0,[r0,#0]
00011e  4328              ORRS     r0,r0,r5
000120  4913              LDR      r1,|L7.368|
000122  1d09              ADDS     r1,r1,#4
000124  6008              STR      r0,[r1,#0]
                  |L7.294|
;;;353      }
;;;354    
;;;355      /* Filter FIFO assignment */
;;;356      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
000126  8920              LDRH     r0,[r4,#8]
000128  b930              CBNZ     r0,|L7.312|
;;;357      {
;;;358        /* FIFO 0 assignation for the filter */
;;;359        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
00012a  4811              LDR      r0,|L7.368|
00012c  3014              ADDS     r0,r0,#0x14
00012e  6800              LDR      r0,[r0,#0]
000130  43a8              BICS     r0,r0,r5
000132  490f              LDR      r1,|L7.368|
000134  3114              ADDS     r1,r1,#0x14
000136  6008              STR      r0,[r1,#0]
                  |L7.312|
;;;360      }
;;;361    
;;;362      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
000138  8920              LDRH     r0,[r4,#8]
00013a  2801              CMP      r0,#1
00013c  d106              BNE      |L7.332|
;;;363      {
;;;364        /* FIFO 1 assignation for the filter */
;;;365        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
00013e  480c              LDR      r0,|L7.368|
000140  3014              ADDS     r0,r0,#0x14
000142  6800              LDR      r0,[r0,#0]
000144  4328              ORRS     r0,r0,r5
000146  490a              LDR      r1,|L7.368|
000148  3114              ADDS     r1,r1,#0x14
00014a  6008              STR      r0,[r1,#0]
                  |L7.332|
;;;366      }
;;;367      
;;;368      /* Filter activation */
;;;369      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
00014c  7b60              LDRB     r0,[r4,#0xd]
00014e  2801              CMP      r0,#1
000150  d106              BNE      |L7.352|
;;;370      {
;;;371        CAN1->FA1R |= filter_number_bit_pos;
000152  4807              LDR      r0,|L7.368|
000154  301c              ADDS     r0,r0,#0x1c
000156  6800              LDR      r0,[r0,#0]
000158  4328              ORRS     r0,r0,r5
00015a  4905              LDR      r1,|L7.368|
00015c  311c              ADDS     r1,r1,#0x1c
00015e  6008              STR      r0,[r1,#0]
                  |L7.352|
;;;372      }
;;;373    
;;;374      /* Leave the initialisation mode for the filter */
;;;375      CAN1->FMR &= ~FMR_FINIT;
000160  4803              LDR      r0,|L7.368|
000162  6800              LDR      r0,[r0,#0]
000164  f0200001          BIC      r0,r0,#1
000168  4901              LDR      r1,|L7.368|
00016a  6008              STR      r0,[r1,#0]
;;;376    }
00016c  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP

00016e  0000              DCW      0x0000
                  |L7.368|
                          DCD      0x40006600

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetFlagStatus PROC
;;;1042     */
;;;1043   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1044   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1045     FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;1046     
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  493e              LDR      r1,|L8.260|
00000a  428d              CMP      r5,r1
00000c  d002              BEQ      |L8.20|
00000e  493e              LDR      r1,|L8.264|
000010  428d              CMP      r5,r1
000012  d101              BNE      |L8.24|
                  |L8.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L8.26|
                  |L8.24|
000018  2100              MOVS     r1,#0
                  |L8.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1049     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
000020  493a              LDR      r1,|L8.268|
000022  428c              CMP      r4,r1
000024  d02d              BEQ      |L8.130|
000026  493a              LDR      r1,|L8.272|
000028  428c              CMP      r4,r1
00002a  d02a              BEQ      |L8.130|
00002c  1e89              SUBS     r1,r1,#2
00002e  428c              CMP      r4,r1
000030  d027              BEQ      |L8.130|
000032  1e49              SUBS     r1,r1,#1
000034  428c              CMP      r4,r1
000036  d024              BEQ      |L8.130|
000038  4936              LDR      r1,|L8.276|
00003a  428c              CMP      r4,r1
00003c  d021              BEQ      |L8.130|
00003e  4936              LDR      r1,|L8.280|
000040  428c              CMP      r4,r1
000042  d01e              BEQ      |L8.130|
000044  4934              LDR      r1,|L8.280|
000046  3908              SUBS     r1,r1,#8
000048  428c              CMP      r4,r1
00004a  d01a              BEQ      |L8.130|
00004c  4933              LDR      r1,|L8.284|
00004e  428c              CMP      r4,r1
000050  d017              BEQ      |L8.130|
000052  4933              LDR      r1,|L8.288|
000054  428c              CMP      r4,r1
000056  d014              BEQ      |L8.130|
000058  4931              LDR      r1,|L8.288|
00005a  3908              SUBS     r1,r1,#8
00005c  428c              CMP      r4,r1
00005e  d010              BEQ      |L8.130|
000060  4930              LDR      r1,|L8.292|
000062  428c              CMP      r4,r1
000064  d00d              BEQ      |L8.130|
000066  4930              LDR      r1,|L8.296|
000068  428c              CMP      r4,r1
00006a  d00a              BEQ      |L8.130|
00006c  492f              LDR      r1,|L8.300|
00006e  428c              CMP      r4,r1
000070  d007              BEQ      |L8.130|
000072  492e              LDR      r1,|L8.300|
000074  39ff              SUBS     r1,r1,#0xff
000076  428c              CMP      r4,r1
000078  d003              BEQ      |L8.130|
00007a  4926              LDR      r1,|L8.276|
00007c  310a              ADDS     r1,r1,#0xa
00007e  428c              CMP      r4,r1
000080  d101              BNE      |L8.134|
                  |L8.130|
000082  2101              MOVS     r1,#1
000084  e000              B        |L8.136|
                  |L8.134|
000086  2100              MOVS     r1,#0
                  |L8.136|
000088  4608              MOV      r0,r1
00008a  f7fffffe          BL       assert_param
;;;1050     
;;;1051   
;;;1052     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
00008e  f4040070          AND      r0,r4,#0xf00000
000092  b140              CBZ      r0,|L8.166|
;;;1053     { 
;;;1054       /* Check the status of the specified CAN flag */
;;;1055       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000094  69a8              LDR      r0,[r5,#0x18]
000096  f3c40113          UBFX     r1,r4,#0,#20
00009a  4008              ANDS     r0,r0,r1
00009c  b108              CBZ      r0,|L8.162|
;;;1056       { 
;;;1057         /* CAN_FLAG is set */
;;;1058         bitstatus = SET;
00009e  2601              MOVS     r6,#1
0000a0  e02d              B        |L8.254|
                  |L8.162|
;;;1059       }
;;;1060       else
;;;1061       { 
;;;1062         /* CAN_FLAG is reset */
;;;1063         bitstatus = RESET;
0000a2  2600              MOVS     r6,#0
0000a4  e02b              B        |L8.254|
                  |L8.166|
;;;1064       }
;;;1065     }
;;;1066     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
0000a6  f0047080          AND      r0,r4,#0x1000000
0000aa  b140              CBZ      r0,|L8.190|
;;;1067     { 
;;;1068       /* Check the status of the specified CAN flag */
;;;1069       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000ac  6868              LDR      r0,[r5,#4]
0000ae  f3c40113          UBFX     r1,r4,#0,#20
0000b2  4008              ANDS     r0,r0,r1
0000b4  b108              CBZ      r0,|L8.186|
;;;1070       { 
;;;1071         /* CAN_FLAG is set */
;;;1072         bitstatus = SET;
0000b6  2601              MOVS     r6,#1
0000b8  e021              B        |L8.254|
                  |L8.186|
;;;1073       }
;;;1074       else
;;;1075       { 
;;;1076         /* CAN_FLAG is reset */
;;;1077         bitstatus = RESET;
0000ba  2600              MOVS     r6,#0
0000bc  e01f              B        |L8.254|
                  |L8.190|
;;;1078       }
;;;1079     }
;;;1080     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
0000be  f0046000          AND      r0,r4,#0x8000000
0000c2  b140              CBZ      r0,|L8.214|
;;;1081     { 
;;;1082       /* Check the status of the specified CAN flag */
;;;1083       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000c4  68a8              LDR      r0,[r5,#8]
0000c6  f3c40113          UBFX     r1,r4,#0,#20
0000ca  4008              ANDS     r0,r0,r1
0000cc  b108              CBZ      r0,|L8.210|
;;;1084       { 
;;;1085         /* CAN_FLAG is set */
;;;1086         bitstatus = SET;
0000ce  2601              MOVS     r6,#1
0000d0  e015              B        |L8.254|
                  |L8.210|
;;;1087       }
;;;1088       else
;;;1089       { 
;;;1090         /* CAN_FLAG is reset */
;;;1091         bitstatus = RESET;
0000d2  2600              MOVS     r6,#0
0000d4  e013              B        |L8.254|
                  |L8.214|
;;;1092       }
;;;1093     }
;;;1094     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
0000d6  f0047000          AND      r0,r4,#0x2000000
0000da  b140              CBZ      r0,|L8.238|
;;;1095     { 
;;;1096       /* Check the status of the specified CAN flag */
;;;1097       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000dc  68e8              LDR      r0,[r5,#0xc]
0000de  f3c40113          UBFX     r1,r4,#0,#20
0000e2  4008              ANDS     r0,r0,r1
0000e4  b108              CBZ      r0,|L8.234|
;;;1098       { 
;;;1099         /* CAN_FLAG is set */
;;;1100         bitstatus = SET;
0000e6  2601              MOVS     r6,#1
0000e8  e009              B        |L8.254|
                  |L8.234|
;;;1101       }
;;;1102       else
;;;1103       { 
;;;1104         /* CAN_FLAG is reset */
;;;1105         bitstatus = RESET;
0000ea  2600              MOVS     r6,#0
0000ec  e007              B        |L8.254|
                  |L8.238|
;;;1106       }
;;;1107     }
;;;1108     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1109     { 
;;;1110       /* Check the status of the specified CAN flag */
;;;1111       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000ee  6928              LDR      r0,[r5,#0x10]
0000f0  f3c40113          UBFX     r1,r4,#0,#20
0000f4  4008              ANDS     r0,r0,r1
0000f6  b108              CBZ      r0,|L8.252|
;;;1112       { 
;;;1113         /* CAN_FLAG is set */
;;;1114         bitstatus = SET;
0000f8  2601              MOVS     r6,#1
0000fa  e000              B        |L8.254|
                  |L8.252|
;;;1115       }
;;;1116       else
;;;1117       { 
;;;1118         /* CAN_FLAG is reset */
;;;1119         bitstatus = RESET;
0000fc  2600              MOVS     r6,#0
                  |L8.254|
;;;1120       }
;;;1121     }
;;;1122     /* Return the CAN_FLAG status */
;;;1123     return  bitstatus;
0000fe  4630              MOV      r0,r6
;;;1124   }
000100  bd70              POP      {r4-r6,pc}
;;;1125   
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      0x40006400
                  |L8.264|
                          DCD      0x40006800
                  |L8.268|
                          DCD      0x30f00070
                  |L8.272|
                          DCD      0x10f00004
                  |L8.276|
                          DCD      0x31000008
                  |L8.280|
                          DCD      0x32000010
                  |L8.284|
                          DCD      0x12000003
                  |L8.288|
                          DCD      0x34000010
                  |L8.292|
                          DCD      0x14000003
                  |L8.296|
                          DCD      0x38010000
                  |L8.300|
                          DCD      0x38000100

                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1202     */
;;;1203   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1204   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1205     ITStatus itstatus = RESET;
000006  2600              MOVS     r6,#0
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  495f              LDR      r1,|L9.392|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L9.20|
00000e  495f              LDR      r1,|L9.396|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L9.24|
                  |L9.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L9.26|
                  |L9.24|
000018  2100              MOVS     r1,#0
                  |L9.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1208     assert_param(IS_CAN_IT(CAN_IT));
000020  2d01              CMP      r5,#1
000022  d020              BEQ      |L9.102|
000024  2d02              CMP      r5,#2
000026  d01e              BEQ      |L9.102|
000028  2d04              CMP      r5,#4
00002a  d01c              BEQ      |L9.102|
00002c  2d08              CMP      r5,#8
00002e  d01a              BEQ      |L9.102|
000030  2d10              CMP      r5,#0x10
000032  d018              BEQ      |L9.102|
000034  2d20              CMP      r5,#0x20
000036  d016              BEQ      |L9.102|
000038  2d40              CMP      r5,#0x40
00003a  d014              BEQ      |L9.102|
00003c  f5b57f80          CMP      r5,#0x100
000040  d011              BEQ      |L9.102|
000042  f5b57f00          CMP      r5,#0x200
000046  d00e              BEQ      |L9.102|
000048  f5b56f80          CMP      r5,#0x400
00004c  d00b              BEQ      |L9.102|
00004e  f5b56f00          CMP      r5,#0x800
000052  d008              BEQ      |L9.102|
000054  f5b54f00          CMP      r5,#0x8000
000058  d005              BEQ      |L9.102|
00005a  f5b53f80          CMP      r5,#0x10000
00005e  d002              BEQ      |L9.102|
000060  f5b53f00          CMP      r5,#0x20000
000064  d101              BNE      |L9.106|
                  |L9.102|
000066  2101              MOVS     r1,#1
000068  e000              B        |L9.108|
                  |L9.106|
00006a  2100              MOVS     r1,#0
                  |L9.108|
00006c  4608              MOV      r0,r1
00006e  f7fffffe          BL       assert_param
;;;1209     
;;;1210     /* check the enable interrupt bit */
;;;1211    if((CANx->IER & CAN_IT) != RESET)
000072  6960              LDR      r0,[r4,#0x14]
000074  4028              ANDS     r0,r0,r5
000076  2800              CMP      r0,#0
000078  d071              BEQ      |L9.350|
;;;1212    {
;;;1213      /* in case the Interrupt is enabled, .... */
;;;1214       switch (CAN_IT)
00007a  f5b57f80          CMP      r5,#0x100
00007e  d05c              BEQ      |L9.314|
000080  dc10              BGT      |L9.164|
000082  2d08              CMP      r5,#8
000084  d035              BEQ      |L9.242|
000086  dc06              BGT      |L9.150|
000088  2d01              CMP      r5,#1
00008a  d020              BEQ      |L9.206|
00008c  2d02              CMP      r5,#2
00008e  d024              BEQ      |L9.218|
000090  2d04              CMP      r5,#4
000092  d172              BNE      |L9.378|
000094  e027              B        |L9.230|
                  |L9.150|
000096  2d10              CMP      r5,#0x10
000098  d031              BEQ      |L9.254|
00009a  2d20              CMP      r5,#0x20
00009c  d035              BEQ      |L9.266|
00009e  2d40              CMP      r5,#0x40
0000a0  d16b              BNE      |L9.378|
0000a2  e038              B        |L9.278|
                  |L9.164|
0000a4  f5b54f00          CMP      r5,#0x8000
0000a8  d060              BEQ      |L9.364|
0000aa  dc09              BGT      |L9.192|
0000ac  f5b57f00          CMP      r5,#0x200
0000b0  d049              BEQ      |L9.326|
0000b2  f5b56f80          CMP      r5,#0x400
0000b6  d04c              BEQ      |L9.338|
0000b8  f5b56f00          CMP      r5,#0x800
0000bc  d15d              BNE      |L9.378|
0000be  e04f              B        |L9.352|
                  |L9.192|
0000c0  f5b53f80          CMP      r5,#0x10000
0000c4  d02d              BEQ      |L9.290|
0000c6  f5b53f00          CMP      r5,#0x20000
0000ca  d156              BNE      |L9.378|
0000cc  e02f              B        |L9.302|
                  |L9.206|
;;;1215       {
;;;1216         case CAN_IT_TME:
;;;1217                  /* Check CAN_TSR_RQCPx bits */
;;;1218   	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
0000ce  68a0              LDR      r0,[r4,#8]
0000d0  492f              LDR      r1,|L9.400|
0000d2  f7fffffe          BL       CheckITStatus
0000d6  4606              MOV      r6,r0
;;;1219   	      break;
0000d8  e051              B        |L9.382|
                  |L9.218|
;;;1220         case CAN_IT_FMP0:
;;;1221                  /* Check CAN_RF0R_FMP0 bit */
;;;1222   	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
0000da  68e0              LDR      r0,[r4,#0xc]
0000dc  2103              MOVS     r1,#3
0000de  f7fffffe          BL       CheckITStatus
0000e2  4606              MOV      r6,r0
;;;1223   	      break;
0000e4  e04b              B        |L9.382|
                  |L9.230|
;;;1224         case CAN_IT_FF0:
;;;1225                  /* Check CAN_RF0R_FULL0 bit */
;;;1226                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
0000e6  68e0              LDR      r0,[r4,#0xc]
0000e8  2108              MOVS     r1,#8
0000ea  f7fffffe          BL       CheckITStatus
0000ee  4606              MOV      r6,r0
;;;1227   	      break;
0000f0  e045              B        |L9.382|
                  |L9.242|
;;;1228         case CAN_IT_FOV0:
;;;1229                  /* Check CAN_RF0R_FOVR0 bit */
;;;1230                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
0000f2  68e0              LDR      r0,[r4,#0xc]
0000f4  2110              MOVS     r1,#0x10
0000f6  f7fffffe          BL       CheckITStatus
0000fa  4606              MOV      r6,r0
;;;1231   	      break;
0000fc  e03f              B        |L9.382|
                  |L9.254|
;;;1232         case CAN_IT_FMP1:
;;;1233                  /* Check CAN_RF1R_FMP1 bit */
;;;1234                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
0000fe  6920              LDR      r0,[r4,#0x10]
000100  2103              MOVS     r1,#3
000102  f7fffffe          BL       CheckITStatus
000106  4606              MOV      r6,r0
;;;1235   	      break;
000108  e039              B        |L9.382|
                  |L9.266|
;;;1236         case CAN_IT_FF1:
;;;1237                  /* Check CAN_RF1R_FULL1 bit */
;;;1238   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
00010a  6920              LDR      r0,[r4,#0x10]
00010c  2108              MOVS     r1,#8
00010e  f7fffffe          BL       CheckITStatus
000112  4606              MOV      r6,r0
;;;1239   	      break;
000114  e033              B        |L9.382|
                  |L9.278|
;;;1240         case CAN_IT_FOV1:
;;;1241                  /* Check CAN_RF1R_FOVR1 bit */
;;;1242   	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
000116  6920              LDR      r0,[r4,#0x10]
000118  2110              MOVS     r1,#0x10
00011a  f7fffffe          BL       CheckITStatus
00011e  4606              MOV      r6,r0
;;;1243   	      break;
000120  e02d              B        |L9.382|
                  |L9.290|
;;;1244         case CAN_IT_WKU:
;;;1245                  /* Check CAN_MSR_WKUI bit */
;;;1246                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
000122  6860              LDR      r0,[r4,#4]
000124  2108              MOVS     r1,#8
000126  f7fffffe          BL       CheckITStatus
00012a  4606              MOV      r6,r0
;;;1247   	      break;
00012c  e027              B        |L9.382|
                  |L9.302|
;;;1248         case CAN_IT_SLK:
;;;1249                  /* Check CAN_MSR_SLAKI bit */
;;;1250   	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
00012e  6860              LDR      r0,[r4,#4]
000130  2110              MOVS     r1,#0x10
000132  f7fffffe          BL       CheckITStatus
000136  4606              MOV      r6,r0
;;;1251   	      break;
000138  e021              B        |L9.382|
                  |L9.314|
;;;1252         case CAN_IT_EWG:
;;;1253                  /* Check CAN_ESR_EWGF bit */
;;;1254   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
00013a  69a0              LDR      r0,[r4,#0x18]
00013c  2101              MOVS     r1,#1
00013e  f7fffffe          BL       CheckITStatus
000142  4606              MOV      r6,r0
;;;1255   	      break;
000144  e01b              B        |L9.382|
                  |L9.326|
;;;1256         case CAN_IT_EPV:
;;;1257                  /* Check CAN_ESR_EPVF bit */
;;;1258   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
000146  69a0              LDR      r0,[r4,#0x18]
000148  2102              MOVS     r1,#2
00014a  f7fffffe          BL       CheckITStatus
00014e  4606              MOV      r6,r0
;;;1259   	      break;
000150  e015              B        |L9.382|
                  |L9.338|
;;;1260         case CAN_IT_BOF:
;;;1261                  /* Check CAN_ESR_BOFF bit */
;;;1262   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
000152  69a0              LDR      r0,[r4,#0x18]
000154  2104              MOVS     r1,#4
000156  f7fffffe          BL       CheckITStatus
00015a  4606              MOV      r6,r0
;;;1263   	      break;
00015c  e00f              B        |L9.382|
                  |L9.350|
00015e  e00f              B        |L9.384|
                  |L9.352|
;;;1264         case CAN_IT_LEC:
;;;1265                  /* Check CAN_ESR_LEC bit */
;;;1266   	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
000160  69a0              LDR      r0,[r4,#0x18]
000162  2170              MOVS     r1,#0x70
000164  f7fffffe          BL       CheckITStatus
000168  4606              MOV      r6,r0
;;;1267   	      break;
00016a  e008              B        |L9.382|
                  |L9.364|
;;;1268         case CAN_IT_ERR:
;;;1269                  /* Check CAN_MSR_ERRI bit */ 
;;;1270                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
00016c  6860              LDR      r0,[r4,#4]
00016e  2104              MOVS     r1,#4
000170  f7fffffe          BL       CheckITStatus
000174  4606              MOV      r6,r0
;;;1271   	      break;
000176  e002              B        |L9.382|
000178  e7ff              B        |L9.378|
                  |L9.378|
;;;1272         default :
;;;1273                  /* in case of error, return RESET */
;;;1274                 itstatus = RESET;
00017a  2600              MOVS     r6,#0
;;;1275                 break;
00017c  bf00              NOP      
                  |L9.382|
00017e  e000              B        |L9.386|
                  |L9.384|
;;;1276       }
;;;1277     }
;;;1278     else
;;;1279     {
;;;1280      /* in case the Interrupt is not enabled, return RESET */
;;;1281       itstatus  = RESET;
000180  2600              MOVS     r6,#0
                  |L9.386|
;;;1282     }
;;;1283     
;;;1284     /* Return the CAN_IT status */
;;;1285     return  itstatus;
000182  4630              MOV      r0,r6
;;;1286   }
000184  bd70              POP      {r4-r6,pc}
;;;1287   
                          ENDP

000186  0000              DCW      0x0000
                  |L9.392|
                          DCD      0x40006400
                  |L9.396|
                          DCD      0x40006800
                  |L9.400|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=2

                  CAN_GetLSBTransmitErrorCounter PROC
;;;965      */
;;;966    uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;967    {
000002  4604              MOV      r4,r0
;;;968      uint8_t counter=0;
000004  2500              MOVS     r5,#0
;;;969      
;;;970      /* Check the parameters */
;;;971      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4908              LDR      r1,|L10.40|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L10.18|
00000c  4907              LDR      r1,|L10.44|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L10.22|
                  |L10.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L10.24|
                  |L10.22|
000016  2100              MOVS     r1,#0
                  |L10.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;972      
;;;973      /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;974      counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
00001e  69a0              LDR      r0,[r4,#0x18]
000020  f3c04507          UBFX     r5,r0,#16,#8
;;;975      
;;;976      /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;977      return counter;
000024  4628              MOV      r0,r5
;;;978    }
000026  bd70              POP      {r4-r6,pc}
;;;979    
                          ENDP

                  |L10.40|
                          DCD      0x40006400
                  |L10.44|
                          DCD      0x40006800

                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=2

                  CAN_GetLastErrorCode PROC
;;;921     
;;;922    uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;923    {
000002  4604              MOV      r4,r0
;;;924      uint8_t errorcode=0;
000004  2500              MOVS     r5,#0
;;;925      
;;;926      /* Check the parameters */
;;;927      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4908              LDR      r1,|L11.40|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L11.18|
00000c  4907              LDR      r1,|L11.44|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L11.22|
                  |L11.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L11.24|
                  |L11.22|
000016  2100              MOVS     r1,#0
                  |L11.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;928      
;;;929      /* Get the error code*/
;;;930      errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
00001e  69a0              LDR      r0,[r4,#0x18]
000020  f0000570          AND      r5,r0,#0x70
;;;931      
;;;932      /* Return the error code*/
;;;933      return errorcode;
000024  4628              MOV      r0,r5
;;;934    }
000026  bd70              POP      {r4-r6,pc}
;;;935    /**
                          ENDP

                  |L11.40|
                          DCD      0x40006400
                  |L11.44|
                          DCD      0x40006800

                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=2

                  CAN_GetReceiveErrorCounter PROC
;;;945      */
;;;946    uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;947    {
000002  4604              MOV      r4,r0
;;;948      uint8_t counter=0;
000004  2500              MOVS     r5,#0
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4908              LDR      r1,|L12.40|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L12.18|
00000c  4907              LDR      r1,|L12.44|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L12.22|
                  |L12.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L12.24|
                  |L12.22|
000016  2100              MOVS     r1,#0
                  |L12.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;952      
;;;953      /* Get the Receive Error Counter*/
;;;954      counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
00001e  69a0              LDR      r0,[r4,#0x18]
000020  0e05              LSRS     r5,r0,#24
;;;955      
;;;956      /* Return the Receive Error Counter*/
;;;957      return counter;
000022  4628              MOV      r0,r5
;;;958    }
000024  bd70              POP      {r4-r6,pc}
;;;959    
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      0x40006400
                  |L12.44|
                          DCD      0x40006800

                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=2

                  CAN_ITConfig PROC
;;;1002     */
;;;1003   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1004   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;1005     /* Check the parameters */
;;;1006     assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  4923              LDR      r1,|L13.152|
00000a  428d              CMP      r5,r1
00000c  d002              BEQ      |L13.20|
00000e  4923              LDR      r1,|L13.156|
000010  428d              CMP      r5,r1
000012  d101              BNE      |L13.24|
                  |L13.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L13.26|
                  |L13.24|
000018  2100              MOVS     r1,#0
                  |L13.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1007     assert_param(IS_CAN_IT(CAN_IT));
000020  2c01              CMP      r4,#1
000022  d020              BEQ      |L13.102|
000024  2c02              CMP      r4,#2
000026  d01e              BEQ      |L13.102|
000028  2c04              CMP      r4,#4
00002a  d01c              BEQ      |L13.102|
00002c  2c08              CMP      r4,#8
00002e  d01a              BEQ      |L13.102|
000030  2c10              CMP      r4,#0x10
000032  d018              BEQ      |L13.102|
000034  2c20              CMP      r4,#0x20
000036  d016              BEQ      |L13.102|
000038  2c40              CMP      r4,#0x40
00003a  d014              BEQ      |L13.102|
00003c  f5b47f80          CMP      r4,#0x100
000040  d011              BEQ      |L13.102|
000042  f5b47f00          CMP      r4,#0x200
000046  d00e              BEQ      |L13.102|
000048  f5b46f80          CMP      r4,#0x400
00004c  d00b              BEQ      |L13.102|
00004e  f5b46f00          CMP      r4,#0x800
000052  d008              BEQ      |L13.102|
000054  f5b44f00          CMP      r4,#0x8000
000058  d005              BEQ      |L13.102|
00005a  f5b43f80          CMP      r4,#0x10000
00005e  d002              BEQ      |L13.102|
000060  f5b43f00          CMP      r4,#0x20000
000064  d101              BNE      |L13.106|
                  |L13.102|
000066  2101              MOVS     r1,#1
000068  e000              B        |L13.108|
                  |L13.106|
00006a  2100              MOVS     r1,#0
                  |L13.108|
00006c  4608              MOV      r0,r1
00006e  f7fffffe          BL       assert_param
;;;1008     assert_param(IS_FUNCTIONAL_STATE(NewState));
000072  b10e              CBZ      r6,|L13.120|
000074  2e01              CMP      r6,#1
000076  d101              BNE      |L13.124|
                  |L13.120|
000078  2101              MOVS     r1,#1
00007a  e000              B        |L13.126|
                  |L13.124|
00007c  2100              MOVS     r1,#0
                  |L13.126|
00007e  4608              MOV      r0,r1
000080  f7fffffe          BL       assert_param
;;;1009   
;;;1010     if (NewState != DISABLE)
000084  b11e              CBZ      r6,|L13.142|
;;;1011     {
;;;1012       /* Enable the selected CANx interrupt */
;;;1013       CANx->IER |= CAN_IT;
000086  6968              LDR      r0,[r5,#0x14]
000088  4320              ORRS     r0,r0,r4
00008a  6168              STR      r0,[r5,#0x14]
00008c  e002              B        |L13.148|
                  |L13.142|
;;;1014     }
;;;1015     else
;;;1016     {
;;;1017       /* Disable the selected CANx interrupt */
;;;1018       CANx->IER &= ~CAN_IT;
00008e  6968              LDR      r0,[r5,#0x14]
000090  43a0              BICS     r0,r0,r4
000092  6168              STR      r0,[r5,#0x14]
                  |L13.148|
;;;1019     }
;;;1020   }
000094  bd70              POP      {r4-r6,pc}
;;;1021   /**
                          ENDP

000096  0000              DCW      0x0000
                  |L13.152|
                          DCD      0x40006400
                  |L13.156|
                          DCD      0x40006800

                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=2

                  CAN_Init PROC
;;;153      */
;;;154    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;155    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;156      uint8_t InitStatus = CAN_InitStatus_Failed;
000008  2700              MOVS     r7,#0
;;;157      uint32_t wait_ack = 0x00000000;
00000a  2600              MOVS     r6,#0
;;;158      /* Check the parameters */
;;;159      assert_param(IS_CAN_ALL_PERIPH(CANx));
00000c  498b              LDR      r1,|L14.572|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L14.24|
000012  498b              LDR      r1,|L14.576|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L14.28|
                  |L14.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L14.30|
                  |L14.28|
00001c  2100              MOVS     r1,#0
                  |L14.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;160      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
000024  79a9              LDRB     r1,[r5,#6]
000026  b111              CBZ      r1,|L14.46|
000028  79a9              LDRB     r1,[r5,#6]
00002a  2901              CMP      r1,#1
00002c  d101              BNE      |L14.50|
                  |L14.46|
00002e  2101              MOVS     r1,#1
000030  e000              B        |L14.52|
                  |L14.50|
000032  2100              MOVS     r1,#0
                  |L14.52|
000034  4608              MOV      r0,r1
000036  f7fffffe          BL       assert_param
;;;161      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
00003a  79e9              LDRB     r1,[r5,#7]
00003c  b111              CBZ      r1,|L14.68|
00003e  79e9              LDRB     r1,[r5,#7]
000040  2901              CMP      r1,#1
000042  d101              BNE      |L14.72|
                  |L14.68|
000044  2101              MOVS     r1,#1
000046  e000              B        |L14.74|
                  |L14.72|
000048  2100              MOVS     r1,#0
                  |L14.74|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       assert_param
;;;162      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
000050  7a29              LDRB     r1,[r5,#8]
000052  b111              CBZ      r1,|L14.90|
000054  7a29              LDRB     r1,[r5,#8]
000056  2901              CMP      r1,#1
000058  d101              BNE      |L14.94|
                  |L14.90|
00005a  2101              MOVS     r1,#1
00005c  e000              B        |L14.96|
                  |L14.94|
00005e  2100              MOVS     r1,#0
                  |L14.96|
000060  4608              MOV      r0,r1
000062  f7fffffe          BL       assert_param
;;;163      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
000066  7a69              LDRB     r1,[r5,#9]
000068  b111              CBZ      r1,|L14.112|
00006a  7a69              LDRB     r1,[r5,#9]
00006c  2901              CMP      r1,#1
00006e  d101              BNE      |L14.116|
                  |L14.112|
000070  2101              MOVS     r1,#1
000072  e000              B        |L14.118|
                  |L14.116|
000074  2100              MOVS     r1,#0
                  |L14.118|
000076  4608              MOV      r0,r1
000078  f7fffffe          BL       assert_param
;;;164      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
00007c  7aa9              LDRB     r1,[r5,#0xa]
00007e  b111              CBZ      r1,|L14.134|
000080  7aa9              LDRB     r1,[r5,#0xa]
000082  2901              CMP      r1,#1
000084  d101              BNE      |L14.138|
                  |L14.134|
000086  2101              MOVS     r1,#1
000088  e000              B        |L14.140|
                  |L14.138|
00008a  2100              MOVS     r1,#0
                  |L14.140|
00008c  4608              MOV      r0,r1
00008e  f7fffffe          BL       assert_param
;;;165      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
000092  7ae9              LDRB     r1,[r5,#0xb]
000094  b111              CBZ      r1,|L14.156|
000096  7ae9              LDRB     r1,[r5,#0xb]
000098  2901              CMP      r1,#1
00009a  d101              BNE      |L14.160|
                  |L14.156|
00009c  2101              MOVS     r1,#1
00009e  e000              B        |L14.162|
                  |L14.160|
0000a0  2100              MOVS     r1,#0
                  |L14.162|
0000a2  4608              MOV      r0,r1
0000a4  f7fffffe          BL       assert_param
;;;166      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
0000a8  78a9              LDRB     r1,[r5,#2]
0000aa  b141              CBZ      r1,|L14.190|
0000ac  78a9              LDRB     r1,[r5,#2]
0000ae  2901              CMP      r1,#1
0000b0  d005              BEQ      |L14.190|
0000b2  78a9              LDRB     r1,[r5,#2]
0000b4  2902              CMP      r1,#2
0000b6  d002              BEQ      |L14.190|
0000b8  78a9              LDRB     r1,[r5,#2]
0000ba  2903              CMP      r1,#3
0000bc  d101              BNE      |L14.194|
                  |L14.190|
0000be  2101              MOVS     r1,#1
0000c0  e000              B        |L14.196|
                  |L14.194|
0000c2  2100              MOVS     r1,#0
                  |L14.196|
0000c4  4608              MOV      r0,r1
0000c6  f7fffffe          BL       assert_param
;;;167      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
0000ca  78e9              LDRB     r1,[r5,#3]
0000cc  b141              CBZ      r1,|L14.224|
0000ce  78e9              LDRB     r1,[r5,#3]
0000d0  2901              CMP      r1,#1
0000d2  d005              BEQ      |L14.224|
0000d4  78e9              LDRB     r1,[r5,#3]
0000d6  2902              CMP      r1,#2
0000d8  d002              BEQ      |L14.224|
0000da  78e9              LDRB     r1,[r5,#3]
0000dc  2903              CMP      r1,#3
0000de  d101              BNE      |L14.228|
                  |L14.224|
0000e0  2101              MOVS     r1,#1
0000e2  e000              B        |L14.230|
                  |L14.228|
0000e4  2100              MOVS     r1,#0
                  |L14.230|
0000e6  4608              MOV      r0,r1
0000e8  f7fffffe          BL       assert_param
;;;168      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
0000ec  7929              LDRB     r1,[r5,#4]
0000ee  290f              CMP      r1,#0xf
0000f0  dc01              BGT      |L14.246|
0000f2  2101              MOVS     r1,#1
0000f4  e000              B        |L14.248|
                  |L14.246|
0000f6  2100              MOVS     r1,#0
                  |L14.248|
0000f8  4608              MOV      r0,r1
0000fa  f7fffffe          BL       assert_param
;;;169      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
0000fe  7969              LDRB     r1,[r5,#5]
000100  2907              CMP      r1,#7
000102  dc01              BGT      |L14.264|
000104  2101              MOVS     r1,#1
000106  e000              B        |L14.266|
                  |L14.264|
000108  2100              MOVS     r1,#0
                  |L14.266|
00010a  4608              MOV      r0,r1
00010c  f7fffffe          BL       assert_param
;;;170      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
000110  8829              LDRH     r1,[r5,#0]
000112  2901              CMP      r1,#1
000114  db05              BLT      |L14.290|
000116  8829              LDRH     r1,[r5,#0]
000118  f5b16f80          CMP      r1,#0x400
00011c  dc01              BGT      |L14.290|
00011e  2101              MOVS     r1,#1
000120  e000              B        |L14.292|
                  |L14.290|
000122  2100              MOVS     r1,#0
                  |L14.292|
000124  4608              MOV      r0,r1
000126  f7fffffe          BL       assert_param
;;;171    
;;;172      /* Exit from sleep mode */
;;;173      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
00012a  6820              LDR      r0,[r4,#0]
00012c  f0200002          BIC      r0,r0,#2
000130  6020              STR      r0,[r4,#0]
;;;174    
;;;175      /* Request initialisation */
;;;176      CANx->MCR |= CAN_MCR_INRQ ;
000132  6820              LDR      r0,[r4,#0]
000134  f0400001          ORR      r0,r0,#1
000138  6020              STR      r0,[r4,#0]
;;;177    
;;;178      /* Wait the acknowledge */
;;;179      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
00013a  e000              B        |L14.318|
                  |L14.316|
;;;180      {
;;;181        wait_ack++;
00013c  1c76              ADDS     r6,r6,#1
                  |L14.318|
00013e  6860              LDR      r0,[r4,#4]            ;179
000140  f0000001          AND      r0,r0,#1              ;179
000144  b918              CBNZ     r0,|L14.334|
000146  f64f70ff          MOV      r0,#0xffff            ;179
00014a  4286              CMP      r6,r0                 ;179
00014c  d1f6              BNE      |L14.316|
                  |L14.334|
;;;182      }
;;;183    
;;;184      /* Check acknowledge */
;;;185      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
00014e  6860              LDR      r0,[r4,#4]
000150  f0000001          AND      r0,r0,#1
000154  b908              CBNZ     r0,|L14.346|
;;;186      {
;;;187        InitStatus = CAN_InitStatus_Failed;
000156  2700              MOVS     r7,#0
000158  e06c              B        |L14.564|
                  |L14.346|
;;;188      }
;;;189      else 
;;;190      {
;;;191        /* Set the time triggered communication mode */
;;;192        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00015a  79a8              LDRB     r0,[r5,#6]
00015c  2801              CMP      r0,#1
00015e  d104              BNE      |L14.362|
;;;193        {
;;;194          CANx->MCR |= CAN_MCR_TTCM;
000160  6820              LDR      r0,[r4,#0]
000162  f0400080          ORR      r0,r0,#0x80
000166  6020              STR      r0,[r4,#0]
000168  e003              B        |L14.370|
                  |L14.362|
;;;195        }
;;;196        else
;;;197        {
;;;198          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
00016a  6820              LDR      r0,[r4,#0]
00016c  f0200080          BIC      r0,r0,#0x80
000170  6020              STR      r0,[r4,#0]
                  |L14.370|
;;;199        }
;;;200    
;;;201        /* Set the automatic bus-off management */
;;;202        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000172  79e8              LDRB     r0,[r5,#7]
000174  2801              CMP      r0,#1
000176  d104              BNE      |L14.386|
;;;203        {
;;;204          CANx->MCR |= CAN_MCR_ABOM;
000178  6820              LDR      r0,[r4,#0]
00017a  f0400040          ORR      r0,r0,#0x40
00017e  6020              STR      r0,[r4,#0]
000180  e003              B        |L14.394|
                  |L14.386|
;;;205        }
;;;206        else
;;;207        {
;;;208          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000182  6820              LDR      r0,[r4,#0]
000184  f0200040          BIC      r0,r0,#0x40
000188  6020              STR      r0,[r4,#0]
                  |L14.394|
;;;209        }
;;;210    
;;;211        /* Set the automatic wake-up mode */
;;;212        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00018a  7a28              LDRB     r0,[r5,#8]
00018c  2801              CMP      r0,#1
00018e  d104              BNE      |L14.410|
;;;213        {
;;;214          CANx->MCR |= CAN_MCR_AWUM;
000190  6820              LDR      r0,[r4,#0]
000192  f0400020          ORR      r0,r0,#0x20
000196  6020              STR      r0,[r4,#0]
000198  e003              B        |L14.418|
                  |L14.410|
;;;215        }
;;;216        else
;;;217        {
;;;218          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
00019a  6820              LDR      r0,[r4,#0]
00019c  f0200020          BIC      r0,r0,#0x20
0001a0  6020              STR      r0,[r4,#0]
                  |L14.418|
;;;219        }
;;;220    
;;;221        /* Set the no automatic retransmission */
;;;222        if (CAN_InitStruct->CAN_NART == ENABLE)
0001a2  7a68              LDRB     r0,[r5,#9]
0001a4  2801              CMP      r0,#1
0001a6  d104              BNE      |L14.434|
;;;223        {
;;;224          CANx->MCR |= CAN_MCR_NART;
0001a8  6820              LDR      r0,[r4,#0]
0001aa  f0400010          ORR      r0,r0,#0x10
0001ae  6020              STR      r0,[r4,#0]
0001b0  e003              B        |L14.442|
                  |L14.434|
;;;225        }
;;;226        else
;;;227        {
;;;228          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
0001b2  6820              LDR      r0,[r4,#0]
0001b4  f0200010          BIC      r0,r0,#0x10
0001b8  6020              STR      r0,[r4,#0]
                  |L14.442|
;;;229        }
;;;230    
;;;231        /* Set the receive FIFO locked mode */
;;;232        if (CAN_InitStruct->CAN_RFLM == ENABLE)
0001ba  7aa8              LDRB     r0,[r5,#0xa]
0001bc  2801              CMP      r0,#1
0001be  d104              BNE      |L14.458|
;;;233        {
;;;234          CANx->MCR |= CAN_MCR_RFLM;
0001c0  6820              LDR      r0,[r4,#0]
0001c2  f0400008          ORR      r0,r0,#8
0001c6  6020              STR      r0,[r4,#0]
0001c8  e003              B        |L14.466|
                  |L14.458|
;;;235        }
;;;236        else
;;;237        {
;;;238          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0001ca  6820              LDR      r0,[r4,#0]
0001cc  f0200008          BIC      r0,r0,#8
0001d0  6020              STR      r0,[r4,#0]
                  |L14.466|
;;;239        }
;;;240    
;;;241        /* Set the transmit FIFO priority */
;;;242        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0001d2  7ae8              LDRB     r0,[r5,#0xb]
0001d4  2801              CMP      r0,#1
0001d6  d104              BNE      |L14.482|
;;;243        {
;;;244          CANx->MCR |= CAN_MCR_TXFP;
0001d8  6820              LDR      r0,[r4,#0]
0001da  f0400004          ORR      r0,r0,#4
0001de  6020              STR      r0,[r4,#0]
0001e0  e003              B        |L14.490|
                  |L14.482|
;;;245        }
;;;246        else
;;;247        {
;;;248          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0001e2  6820              LDR      r0,[r4,#0]
0001e4  f0200004          BIC      r0,r0,#4
0001e8  6020              STR      r0,[r4,#0]
                  |L14.490|
;;;249        }
;;;250    
;;;251        /* Set the bit timing register */
;;;252        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
0001ea  78a8              LDRB     r0,[r5,#2]
0001ec  0780              LSLS     r0,r0,#30
0001ee  78e9              LDRB     r1,[r5,#3]
0001f0  ea406001          ORR      r0,r0,r1,LSL #24
0001f4  7929              LDRB     r1,[r5,#4]
0001f6  ea404001          ORR      r0,r0,r1,LSL #16
0001fa  7969              LDRB     r1,[r5,#5]
0001fc  ea405001          ORR      r0,r0,r1,LSL #20
000200  8829              LDRH     r1,[r5,#0]
000202  1e49              SUBS     r1,r1,#1
000204  4308              ORRS     r0,r0,r1
000206  61e0              STR      r0,[r4,#0x1c]
;;;253                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;254                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;255                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;256                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;257    
;;;258        /* Request leave initialisation */
;;;259        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
000208  6820              LDR      r0,[r4,#0]
00020a  f0200001          BIC      r0,r0,#1
00020e  6020              STR      r0,[r4,#0]
;;;260    
;;;261       /* Wait the acknowledge */
;;;262       wait_ack = 0;
000210  2600              MOVS     r6,#0
;;;263    
;;;264       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000212  e000              B        |L14.534|
                  |L14.532|
;;;265       {
;;;266         wait_ack++;
000214  1c76              ADDS     r6,r6,#1
                  |L14.534|
000216  6860              LDR      r0,[r4,#4]            ;264
000218  f0000001          AND      r0,r0,#1              ;264
00021c  b118              CBZ      r0,|L14.550|
00021e  f64f70ff          MOV      r0,#0xffff            ;264
000222  4286              CMP      r6,r0                 ;264
000224  d1f6              BNE      |L14.532|
                  |L14.550|
;;;267       }
;;;268    
;;;269        /* ...and check acknowledged */
;;;270        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
000226  6860              LDR      r0,[r4,#4]
000228  f0000001          AND      r0,r0,#1
00022c  b108              CBZ      r0,|L14.562|
;;;271        {
;;;272          InitStatus = CAN_InitStatus_Failed;
00022e  2700              MOVS     r7,#0
000230  e000              B        |L14.564|
                  |L14.562|
;;;273        }
;;;274        else
;;;275        {
;;;276          InitStatus = CAN_InitStatus_Success ;
000232  2701              MOVS     r7,#1
                  |L14.564|
;;;277        }
;;;278      }
;;;279    
;;;280      /* At this step, return the status of initialization */
;;;281      return InitStatus;
000234  4638              MOV      r0,r7
;;;282    }
000236  e8bd81f0          POP      {r4-r8,pc}
;;;283    
                          ENDP

00023a  0000              DCW      0x0000
                  |L14.572|
                          DCD      0x40006400
                  |L14.576|
                          DCD      0x40006800

                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=2

                  CAN_MessagePending PROC
;;;742      */
;;;743    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b570              PUSH     {r4-r6,lr}
;;;744    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;745      uint8_t message_pending=0;
000006  2600              MOVS     r6,#0
;;;746      /* Check the parameters */
;;;747      assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  4911              LDR      r1,|L15.80|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L15.20|
00000e  4911              LDR      r1,|L15.84|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L15.24|
                  |L15.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L15.26|
                  |L15.24|
000018  2100              MOVS     r1,#0
                  |L15.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;748      assert_param(IS_CAN_FIFO(FIFONumber));
000020  b10d              CBZ      r5,|L15.38|
000022  2d01              CMP      r5,#1
000024  d101              BNE      |L15.42|
                  |L15.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L15.44|
                  |L15.42|
00002a  2100              MOVS     r1,#0
                  |L15.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;749      if (FIFONumber == CAN_FIFO0)
000032  b91d              CBNZ     r5,|L15.60|
;;;750      {
;;;751        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000034  68e0              LDR      r0,[r4,#0xc]
000036  f0000603          AND      r6,r0,#3
00003a  e006              B        |L15.74|
                  |L15.60|
;;;752      }
;;;753      else if (FIFONumber == CAN_FIFO1)
00003c  2d01              CMP      r5,#1
00003e  d103              BNE      |L15.72|
;;;754      {
;;;755        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000040  6920              LDR      r0,[r4,#0x10]
000042  f0000603          AND      r6,r0,#3
000046  e000              B        |L15.74|
                  |L15.72|
;;;756      }
;;;757      else
;;;758      {
;;;759        message_pending = 0;
000048  2600              MOVS     r6,#0
                  |L15.74|
;;;760      }
;;;761      return message_pending;
00004a  4630              MOV      r0,r6
;;;762    }
00004c  bd70              POP      {r4-r6,pc}
;;;763    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      0x40006400
                  |L15.84|
                          DCD      0x40006800

                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=2

                  CAN_OperatingModeRequest PROC
;;;773      */
;;;774    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;775    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;776      uint8_t status = CAN_ModeStatus_Failed;
000008  2700              MOVS     r7,#0
;;;777      
;;;778      /* Timeout for INAK or also for SLAK bits*/
;;;779      uint32_t timeout = INAK_TIMEOUT; 
00000a  f64f76ff          MOV      r6,#0xffff
;;;780    
;;;781      /* Check the parameters */
;;;782      assert_param(IS_CAN_ALL_PERIPH(CANx));
00000e  4932              LDR      r1,|L16.216|
000010  428c              CMP      r4,r1
000012  d002              BEQ      |L16.26|
000014  4931              LDR      r1,|L16.220|
000016  428c              CMP      r4,r1
000018  d101              BNE      |L16.30|
                  |L16.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L16.32|
                  |L16.30|
00001e  2100              MOVS     r1,#0
                  |L16.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;783      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
000026  b11d              CBZ      r5,|L16.48|
000028  2d01              CMP      r5,#1
00002a  d001              BEQ      |L16.48|
00002c  2d02              CMP      r5,#2
00002e  d101              BNE      |L16.52|
                  |L16.48|
000030  2101              MOVS     r1,#1
000032  e000              B        |L16.54|
                  |L16.52|
000034  2100              MOVS     r1,#0
                  |L16.54|
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       assert_param
;;;784    
;;;785      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
00003c  b9bd              CBNZ     r5,|L16.110|
;;;786      {
;;;787        /* Request initialisation */
;;;788        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
00003e  6820              LDR      r0,[r4,#0]
000040  f0200002          BIC      r0,r0,#2
000044  f0400001          ORR      r0,r0,#1
000048  6020              STR      r0,[r4,#0]
;;;789    
;;;790        /* Wait the acknowledge */
;;;791        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
00004a  e000              B        |L16.78|
                  |L16.76|
;;;792        {
;;;793          timeout--;
00004c  1e76              SUBS     r6,r6,#1
                  |L16.78|
00004e  6860              LDR      r0,[r4,#4]            ;791
000050  f0000003          AND      r0,r0,#3              ;791
000054  2801              CMP      r0,#1                 ;791
000056  d001              BEQ      |L16.92|
000058  2e00              CMP      r6,#0                 ;791
00005a  d1f7              BNE      |L16.76|
                  |L16.92|
;;;794        }
;;;795        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
00005c  6860              LDR      r0,[r4,#4]
00005e  f0000003          AND      r0,r0,#3
000062  2801              CMP      r0,#1
000064  d001              BEQ      |L16.106|
;;;796        {
;;;797          status = CAN_ModeStatus_Failed;
000066  2700              MOVS     r7,#0
000068  e032              B        |L16.208|
                  |L16.106|
;;;798        }
;;;799        else
;;;800        {
;;;801          status = CAN_ModeStatus_Success;
00006a  2701              MOVS     r7,#1
00006c  e030              B        |L16.208|
                  |L16.110|
;;;802        }
;;;803      }
;;;804      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
00006e  2d01              CMP      r5,#1
000070  d113              BNE      |L16.154|
;;;805      {
;;;806        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;807        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
000072  6820              LDR      r0,[r4,#0]
000074  f0200003          BIC      r0,r0,#3
000078  6020              STR      r0,[r4,#0]
;;;808    
;;;809        /* Wait the acknowledge */
;;;810        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
00007a  e000              B        |L16.126|
                  |L16.124|
;;;811        {
;;;812          timeout--;
00007c  1e76              SUBS     r6,r6,#1
                  |L16.126|
00007e  6860              LDR      r0,[r4,#4]            ;810
000080  f0000003          AND      r0,r0,#3              ;810
000084  b108              CBZ      r0,|L16.138|
000086  2e00              CMP      r6,#0                 ;810
000088  d1f8              BNE      |L16.124|
                  |L16.138|
;;;813        }
;;;814        if ((CANx->MSR & CAN_MODE_MASK) != 0)
00008a  6860              LDR      r0,[r4,#4]
00008c  f0000003          AND      r0,r0,#3
000090  b108              CBZ      r0,|L16.150|
;;;815        {
;;;816          status = CAN_ModeStatus_Failed;
000092  2700              MOVS     r7,#0
000094  e01c              B        |L16.208|
                  |L16.150|
;;;817        }
;;;818        else
;;;819        {
;;;820          status = CAN_ModeStatus_Success;
000096  2701              MOVS     r7,#1
000098  e01a              B        |L16.208|
                  |L16.154|
;;;821        }
;;;822      }
;;;823      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00009a  2d02              CMP      r5,#2
00009c  d117              BNE      |L16.206|
;;;824      {
;;;825        /* Request Sleep mode */
;;;826        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00009e  6820              LDR      r0,[r4,#0]
0000a0  f0200001          BIC      r0,r0,#1
0000a4  f0400002          ORR      r0,r0,#2
0000a8  6020              STR      r0,[r4,#0]
;;;827    
;;;828        /* Wait the acknowledge */
;;;829        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
0000aa  e000              B        |L16.174|
                  |L16.172|
;;;830        {
;;;831          timeout--;
0000ac  1e76              SUBS     r6,r6,#1
                  |L16.174|
0000ae  6860              LDR      r0,[r4,#4]            ;829
0000b0  f0000003          AND      r0,r0,#3              ;829
0000b4  2802              CMP      r0,#2                 ;829
0000b6  d001              BEQ      |L16.188|
0000b8  2e00              CMP      r6,#0                 ;829
0000ba  d1f7              BNE      |L16.172|
                  |L16.188|
;;;832        }
;;;833        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
0000bc  6860              LDR      r0,[r4,#4]
0000be  f0000003          AND      r0,r0,#3
0000c2  2802              CMP      r0,#2
0000c4  d001              BEQ      |L16.202|
;;;834        {
;;;835          status = CAN_ModeStatus_Failed;
0000c6  2700              MOVS     r7,#0
0000c8  e002              B        |L16.208|
                  |L16.202|
;;;836        }
;;;837        else
;;;838        {
;;;839          status = CAN_ModeStatus_Success;
0000ca  2701              MOVS     r7,#1
0000cc  e000              B        |L16.208|
                  |L16.206|
;;;840        }
;;;841      }
;;;842      else
;;;843      {
;;;844        status = CAN_ModeStatus_Failed;
0000ce  2700              MOVS     r7,#0
                  |L16.208|
;;;845      }
;;;846    
;;;847      return  (uint8_t) status;
0000d0  4638              MOV      r0,r7
;;;848    }
0000d2  e8bd81f0          POP      {r4-r8,pc}
;;;849    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L16.216|
                          DCD      0x40006400
                  |L16.220|
                          DCD      0x40006800

                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=2

                  CAN_Receive PROC
;;;670      */
;;;671    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b570              PUSH     {r4-r6,lr}
;;;672    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;673      /* Check the parameters */
;;;674      assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  4945              LDR      r1,|L17.288|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L17.20|
00000e  4945              LDR      r1,|L17.292|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L17.24|
                  |L17.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L17.26|
                  |L17.24|
000018  2100              MOVS     r1,#0
                  |L17.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;675      assert_param(IS_CAN_FIFO(FIFONumber));
000020  b10d              CBZ      r5,|L17.38|
000022  2d01              CMP      r5,#1
000024  d101              BNE      |L17.42|
                  |L17.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L17.44|
                  |L17.42|
00002a  2100              MOVS     r1,#0
                  |L17.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;676      /* Get the Id */
;;;677      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000032  f50470d8          ADD      r0,r4,#0x1b0
000036  eb001005          ADD      r0,r0,r5,LSL #4
00003a  6800              LDR      r0,[r0,#0]
00003c  f0000004          AND      r0,r0,#4
000040  7230              STRB     r0,[r6,#8]
;;;678      if (RxMessage->IDE == CAN_Id_Standard)
000042  7a30              LDRB     r0,[r6,#8]
000044  b950              CBNZ     r0,|L17.92|
;;;679      {
;;;680        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
000046  f50470d8          ADD      r0,r4,#0x1b0
00004a  eb001005          ADD      r0,r0,r5,LSL #4
00004e  6800              LDR      r0,[r0,#0]
000050  f24071ff          MOV      r1,#0x7ff
000054  ea015050          AND      r0,r1,r0,LSR #21
000058  6030              STR      r0,[r6,#0]
00005a  e009              B        |L17.112|
                  |L17.92|
;;;681      }
;;;682      else
;;;683      {
;;;684        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
00005c  f50470d8          ADD      r0,r4,#0x1b0
000060  eb001005          ADD      r0,r0,r5,LSL #4
000064  6800              LDR      r0,[r0,#0]
000066  f06f4160          MVN      r1,#0xe0000000
00006a  ea0100d0          AND      r0,r1,r0,LSR #3
00006e  6070              STR      r0,[r6,#4]
                  |L17.112|
;;;685      }
;;;686      
;;;687      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000070  f50470d8          ADD      r0,r4,#0x1b0
000074  eb001005          ADD      r0,r0,r5,LSL #4
000078  6800              LDR      r0,[r0,#0]
00007a  f0000002          AND      r0,r0,#2
00007e  7270              STRB     r0,[r6,#9]
;;;688      /* Get the DLC */
;;;689      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000080  f50470d8          ADD      r0,r4,#0x1b0
000084  eb001005          ADD      r0,r0,r5,LSL #4
000088  6840              LDR      r0,[r0,#4]
00008a  f000000f          AND      r0,r0,#0xf
00008e  72b0              STRB     r0,[r6,#0xa]
;;;690      /* Get the FMI */
;;;691      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000090  f50470d8          ADD      r0,r4,#0x1b0
000094  eb001005          ADD      r0,r0,r5,LSL #4
000098  6840              LDR      r0,[r0,#4]
00009a  0a00              LSRS     r0,r0,#8
00009c  74f0              STRB     r0,[r6,#0x13]
;;;692      /* Get the data field */
;;;693      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
00009e  f50470d8          ADD      r0,r4,#0x1b0
0000a2  eb001005          ADD      r0,r0,r5,LSL #4
0000a6  6880              LDR      r0,[r0,#8]
0000a8  72f0              STRB     r0,[r6,#0xb]
;;;694      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
0000aa  f50470d8          ADD      r0,r4,#0x1b0
0000ae  eb001005          ADD      r0,r0,r5,LSL #4
0000b2  6880              LDR      r0,[r0,#8]
0000b4  0a01              LSRS     r1,r0,#8
0000b6  7331              STRB     r1,[r6,#0xc]
;;;695      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
0000b8  f50470d8          ADD      r0,r4,#0x1b0
0000bc  eb001005          ADD      r0,r0,r5,LSL #4
0000c0  6880              LDR      r0,[r0,#8]
0000c2  0c01              LSRS     r1,r0,#16
0000c4  7371              STRB     r1,[r6,#0xd]
;;;696      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
0000c6  f50470d8          ADD      r0,r4,#0x1b0
0000ca  eb001005          ADD      r0,r0,r5,LSL #4
0000ce  6880              LDR      r0,[r0,#8]
0000d0  0e00              LSRS     r0,r0,#24
0000d2  73b0              STRB     r0,[r6,#0xe]
;;;697      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0000d4  f50470d8          ADD      r0,r4,#0x1b0
0000d8  eb001005          ADD      r0,r0,r5,LSL #4
0000dc  68c0              LDR      r0,[r0,#0xc]
0000de  73f0              STRB     r0,[r6,#0xf]
;;;698      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0000e0  f50470d8          ADD      r0,r4,#0x1b0
0000e4  eb001005          ADD      r0,r0,r5,LSL #4
0000e8  68c0              LDR      r0,[r0,#0xc]
0000ea  0a01              LSRS     r1,r0,#8
0000ec  7431              STRB     r1,[r6,#0x10]
;;;699      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0000ee  f50470d8          ADD      r0,r4,#0x1b0
0000f2  eb001005          ADD      r0,r0,r5,LSL #4
0000f6  68c0              LDR      r0,[r0,#0xc]
0000f8  0c01              LSRS     r1,r0,#16
0000fa  7471              STRB     r1,[r6,#0x11]
;;;700      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000fc  f50470d8          ADD      r0,r4,#0x1b0
000100  eb001005          ADD      r0,r0,r5,LSL #4
000104  68c0              LDR      r0,[r0,#0xc]
000106  0e00              LSRS     r0,r0,#24
000108  74b0              STRB     r0,[r6,#0x12]
;;;701      /* Release the FIFO */
;;;702      /* Release FIFO0 */
;;;703      if (FIFONumber == CAN_FIFO0)
00010a  b925              CBNZ     r5,|L17.278|
;;;704      {
;;;705        CANx->RF0R |= CAN_RF0R_RFOM0;
00010c  68e0              LDR      r0,[r4,#0xc]
00010e  f0400020          ORR      r0,r0,#0x20
000112  60e0              STR      r0,[r4,#0xc]
000114  e003              B        |L17.286|
                  |L17.278|
;;;706      }
;;;707      /* Release FIFO1 */
;;;708      else /* FIFONumber == CAN_FIFO1 */
;;;709      {
;;;710        CANx->RF1R |= CAN_RF1R_RFOM1;
000116  6920              LDR      r0,[r4,#0x10]
000118  f0400020          ORR      r0,r0,#0x20
00011c  6120              STR      r0,[r4,#0x10]
                  |L17.286|
;;;711      }
;;;712    }
00011e  bd70              POP      {r4-r6,pc}
;;;713    
                          ENDP

                  |L17.288|
                          DCD      0x40006400
                  |L17.292|
                          DCD      0x40006800

                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;427      */
;;;428    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  b510              PUSH     {r4,lr}
;;;429    {
000002  4604              MOV      r4,r0
;;;430      /* Check the parameters */
;;;431      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
000004  2c01              CMP      r4,#1
000006  db03              BLT      |L18.16|
000008  2c1b              CMP      r4,#0x1b
00000a  dc01              BGT      |L18.16|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L18.18|
                  |L18.16|
000010  2100              MOVS     r1,#0
                  |L18.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;432      
;;;433      /* Enter Initialisation mode for the filter */
;;;434      CAN1->FMR |= FMR_FINIT;
000018  480b              LDR      r0,|L18.72|
00001a  6800              LDR      r0,[r0,#0]
00001c  f0400001          ORR      r0,r0,#1
000020  4909              LDR      r1,|L18.72|
000022  6008              STR      r0,[r1,#0]
;;;435      
;;;436      /* Select the start slave bank */
;;;437      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f643710e          MOV      r1,#0x3f0e
00002c  4388              BICS     r0,r0,r1
00002e  4906              LDR      r1,|L18.72|
000030  6008              STR      r0,[r1,#0]
;;;438      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]
000036  ea402004          ORR      r0,r0,r4,LSL #8
00003a  6008              STR      r0,[r1,#0]
;;;439      
;;;440      /* Leave Initialisation mode for the filter */
;;;441      CAN1->FMR &= ~FMR_FINIT;
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f0200001          BIC      r0,r0,#1
000044  6008              STR      r0,[r1,#0]
;;;442    }
000046  bd10              POP      {r4,pc}
;;;443    
                          ENDP

                  |L18.72|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=2

                  CAN_Sleep PROC
;;;855      */
;;;856    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;857    {
000002  4604              MOV      r4,r0
;;;858      uint8_t sleepstatus = CAN_Sleep_Failed;
000004  2500              MOVS     r5,#0
;;;859      
;;;860      /* Check the parameters */
;;;861      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  490d              LDR      r1,|L19.60|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L19.18|
00000c  490c              LDR      r1,|L19.64|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L19.22|
                  |L19.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L19.24|
                  |L19.22|
000016  2100              MOVS     r1,#0
                  |L19.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;862        
;;;863      /* Request Sleep mode */
;;;864       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00001e  6820              LDR      r0,[r4,#0]
000020  f0200001          BIC      r0,r0,#1
000024  f0400002          ORR      r0,r0,#2
000028  6020              STR      r0,[r4,#0]
;;;865       
;;;866      /* Sleep mode status */
;;;867      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
00002a  6860              LDR      r0,[r4,#4]
00002c  f0000003          AND      r0,r0,#3
000030  2802              CMP      r0,#2
000032  d100              BNE      |L19.54|
;;;868      {
;;;869        /* Sleep mode not entered */
;;;870        sleepstatus =  CAN_Sleep_Ok;
000034  2501              MOVS     r5,#1
                  |L19.54|
;;;871      }
;;;872      /* return sleep mode status */
;;;873       return (uint8_t)sleepstatus;
000036  4628              MOV      r0,r5
;;;874    }
000038  bd70              POP      {r4-r6,pc}
;;;875    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      0x40006400
                  |L19.64|
                          DCD      0x40006800

                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;383      */
;;;384    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;385    {
;;;386      /* Reset CAN init structure parameters values */
;;;387      
;;;388      /* Initialize the time triggered communication mode */
;;;389      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;390      
;;;391      /* Initialize the automatic bus-off management */
;;;392      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;393      
;;;394      /* Initialize the automatic wake-up mode */
;;;395      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;396      
;;;397      /* Initialize the no automatic retransmission */
;;;398      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;399      
;;;400      /* Initialize the receive FIFO locked mode */
;;;401      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;402      
;;;403      /* Initialize the transmit FIFO priority */
;;;404      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;405      
;;;406      /* Initialize the CAN_Mode member */
;;;407      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;408      
;;;409      /* Initialize the CAN_SJW member */
;;;410      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;411      
;;;412      /* Initialize the CAN_BS1 member */
;;;413      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;414      
;;;415      /* Initialize the CAN_BS2 member */
;;;416      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;417      
;;;418      /* Initialize the CAN_Prescaler member */
;;;419      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;420    }
00001e  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=2

                  CAN_TTComModeCmd PROC
;;;480      */
;;;481    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;483      /* Check the parameters */
;;;484      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4924              LDR      r1,|L21.152|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L21.18|
00000c  4923              LDR      r1,|L21.156|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L21.22|
                  |L21.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L21.24|
                  |L21.22|
000016  2100              MOVS     r1,#0
                  |L21.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L21.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L21.40|
                  |L21.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L21.42|
                  |L21.40|
000028  2100              MOVS     r1,#0
                  |L21.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;486      if (NewState != DISABLE)
000030  b1c5              CBZ      r5,|L21.100|
;;;487      {
;;;488        /* Enable the TTCM mode */
;;;489        CANx->MCR |= CAN_MCR_TTCM;
000032  6820              LDR      r0,[r4,#0]
000034  f0400080          ORR      r0,r0,#0x80
000038  6020              STR      r0,[r4,#0]
;;;490    
;;;491        /* Set TGT bits */
;;;492        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
00003a  f44f70c2          MOV      r0,#0x184
00003e  5900              LDR      r0,[r0,r4]
000040  f4407180          ORR      r1,r0,#0x100
000044  f44f70c2          MOV      r0,#0x184
000048  5101              STR      r1,[r0,r4]
;;;493        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
00004a  f8d40194          LDR      r0,[r4,#0x194]
00004e  f4407180          ORR      r1,r0,#0x100
000052  f8c41194          STR      r1,[r4,#0x194]
;;;494        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
000056  f8d401a4          LDR      r0,[r4,#0x1a4]
00005a  f4407180          ORR      r1,r0,#0x100
00005e  f8c411a4          STR      r1,[r4,#0x1a4]
000062  e017              B        |L21.148|
                  |L21.100|
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Disable the TTCM mode */
;;;499        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000064  6820              LDR      r0,[r4,#0]
000066  f0200080          BIC      r0,r0,#0x80
00006a  6020              STR      r0,[r4,#0]
;;;500    
;;;501        /* Reset TGT bits */
;;;502        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
00006c  f44f70c2          MOV      r0,#0x184
000070  5900              LDR      r0,[r0,r4]
000072  f4207180          BIC      r1,r0,#0x100
000076  f44f70c2          MOV      r0,#0x184
00007a  5101              STR      r1,[r0,r4]
;;;503        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
00007c  f8d40194          LDR      r0,[r4,#0x194]
000080  f4207180          BIC      r1,r0,#0x100
000084  f8c41194          STR      r1,[r4,#0x194]
;;;504        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
000088  f8d401a4          LDR      r0,[r4,#0x1a4]
00008c  f4207180          BIC      r1,r0,#0x100
000090  f8c411a4          STR      r1,[r4,#0x1a4]
                  |L21.148|
;;;505      }
;;;506    }
000094  bd70              POP      {r4-r6,pc}
;;;507    /**
                          ENDP

000096  0000              DCW      0x0000
                  |L21.152|
                          DCD      0x40006400
                  |L21.156|
                          DCD      0x40006800

                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=2

                  CAN_Transmit PROC
;;;514      */
;;;515    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b570              PUSH     {r4-r6,lr}
;;;516    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;517      uint8_t transmit_mailbox = 0;
000006  2600              MOVS     r6,#0
;;;518      /* Check the parameters */
;;;519      assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  4969              LDR      r1,|L22.432|
00000a  428d              CMP      r5,r1
00000c  d002              BEQ      |L22.20|
00000e  4969              LDR      r1,|L22.436|
000010  428d              CMP      r5,r1
000012  d101              BNE      |L22.24|
                  |L22.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L22.26|
                  |L22.24|
000018  2100              MOVS     r1,#0
                  |L22.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;520      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
000020  7a21              LDRB     r1,[r4,#8]
000022  b111              CBZ      r1,|L22.42|
000024  7a21              LDRB     r1,[r4,#8]
000026  2904              CMP      r1,#4
000028  d101              BNE      |L22.46|
                  |L22.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L22.48|
                  |L22.46|
00002e  2100              MOVS     r1,#0
                  |L22.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;521      assert_param(IS_CAN_RTR(TxMessage->RTR));
000036  7a61              LDRB     r1,[r4,#9]
000038  b111              CBZ      r1,|L22.64|
00003a  7a61              LDRB     r1,[r4,#9]
00003c  2902              CMP      r1,#2
00003e  d101              BNE      |L22.68|
                  |L22.64|
000040  2101              MOVS     r1,#1
000042  e000              B        |L22.70|
                  |L22.68|
000044  2100              MOVS     r1,#0
                  |L22.70|
000046  4608              MOV      r0,r1
000048  f7fffffe          BL       assert_param
;;;522      assert_param(IS_CAN_DLC(TxMessage->DLC));
00004c  7aa1              LDRB     r1,[r4,#0xa]
00004e  2908              CMP      r1,#8
000050  dc01              BGT      |L22.86|
000052  2101              MOVS     r1,#1
000054  e000              B        |L22.88|
                  |L22.86|
000056  2100              MOVS     r1,#0
                  |L22.88|
000058  4608              MOV      r0,r1
00005a  f7fffffe          BL       assert_param
;;;523    
;;;524      /* Select one empty transmit mailbox */
;;;525      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
00005e  68a8              LDR      r0,[r5,#8]
000060  f0006080          AND      r0,r0,#0x4000000
000064  f1b06f80          CMP      r0,#0x4000000
000068  d101              BNE      |L22.110|
;;;526      {
;;;527        transmit_mailbox = 0;
00006a  2600              MOVS     r6,#0
00006c  e010              B        |L22.144|
                  |L22.110|
;;;528      }
;;;529      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
00006e  68a8              LDR      r0,[r5,#8]
000070  f0006000          AND      r0,r0,#0x8000000
000074  f1b06f00          CMP      r0,#0x8000000
000078  d101              BNE      |L22.126|
;;;530      {
;;;531        transmit_mailbox = 1;
00007a  2601              MOVS     r6,#1
00007c  e008              B        |L22.144|
                  |L22.126|
;;;532      }
;;;533      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
00007e  68a8              LDR      r0,[r5,#8]
000080  f0005080          AND      r0,r0,#0x10000000
000084  f1b05f80          CMP      r0,#0x10000000
000088  d101              BNE      |L22.142|
;;;534      {
;;;535        transmit_mailbox = 2;
00008a  2602              MOVS     r6,#2
00008c  e000              B        |L22.144|
                  |L22.142|
;;;536      }
;;;537      else
;;;538      {
;;;539        transmit_mailbox = CAN_TxStatus_NoMailBox;
00008e  2604              MOVS     r6,#4
                  |L22.144|
;;;540      }
;;;541    
;;;542      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
000090  2e04              CMP      r6,#4
000092  d07d              BEQ      |L22.400|
;;;543      {
;;;544        /* Set up the Id */
;;;545        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
000094  f50570c0          ADD      r0,r5,#0x180
000098  eb001006          ADD      r0,r0,r6,LSL #4
00009c  6800              LDR      r0,[r0,#0]
00009e  f0000101          AND      r1,r0,#1
0000a2  f50570c0          ADD      r0,r5,#0x180
0000a6  eb001006          ADD      r0,r0,r6,LSL #4
0000aa  6001              STR      r1,[r0,#0]
;;;546        if (TxMessage->IDE == CAN_Id_Standard)
0000ac  7a20              LDRB     r0,[r4,#8]
0000ae  b9c8              CBNZ     r0,|L22.228|
;;;547        {
;;;548          assert_param(IS_CAN_STDID(TxMessage->StdId));  
0000b0  6821              LDR      r1,[r4,#0]
0000b2  f5b16f00          CMP      r1,#0x800
0000b6  d201              BCS      |L22.188|
0000b8  2101              MOVS     r1,#1
0000ba  e000              B        |L22.190|
                  |L22.188|
0000bc  2100              MOVS     r1,#0
                  |L22.190|
0000be  4608              MOV      r0,r1
0000c0  f7fffffe          BL       assert_param
;;;549          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
0000c4  7a60              LDRB     r0,[r4,#9]
0000c6  8821              LDRH     r1,[r4,#0]
0000c8  ea405041          ORR      r0,r0,r1,LSL #21
0000cc  f50571c0          ADD      r1,r5,#0x180
0000d0  eb011106          ADD      r1,r1,r6,LSL #4
0000d4  6809              LDR      r1,[r1,#0]
0000d6  4308              ORRS     r0,r0,r1
0000d8  f50571c0          ADD      r1,r5,#0x180
0000dc  eb011106          ADD      r1,r1,r6,LSL #4
0000e0  6008              STR      r0,[r1,#0]
0000e2  e01a              B        |L22.282|
                  |L22.228|
;;;550                                                      TxMessage->RTR);
;;;551        }
;;;552        else
;;;553        {
;;;554          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
0000e4  6861              LDR      r1,[r4,#4]
0000e6  f1b15f00          CMP      r1,#0x20000000
0000ea  d201              BCS      |L22.240|
0000ec  2101              MOVS     r1,#1
0000ee  e000              B        |L22.242|
                  |L22.240|
0000f0  2100              MOVS     r1,#0
                  |L22.242|
0000f2  4608              MOV      r0,r1
0000f4  f7fffffe          BL       assert_param
;;;555          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
0000f8  7a20              LDRB     r0,[r4,#8]
0000fa  6861              LDR      r1,[r4,#4]
0000fc  ea4000c1          ORR      r0,r0,r1,LSL #3
000100  7a61              LDRB     r1,[r4,#9]
000102  4308              ORRS     r0,r0,r1
000104  f50571c0          ADD      r1,r5,#0x180
000108  eb011106          ADD      r1,r1,r6,LSL #4
00010c  6809              LDR      r1,[r1,#0]
00010e  4308              ORRS     r0,r0,r1
000110  f50571c0          ADD      r1,r5,#0x180
000114  eb011106          ADD      r1,r1,r6,LSL #4
000118  6008              STR      r0,[r1,#0]
                  |L22.282|
;;;556                                                      TxMessage->IDE | \
;;;557                                                      TxMessage->RTR);
;;;558        }
;;;559        
;;;560        /* Set up the DLC */
;;;561        TxMessage->DLC &= (uint8_t)0x0000000F;
00011a  7aa0              LDRB     r0,[r4,#0xa]
00011c  f000000f          AND      r0,r0,#0xf
000120  72a0              STRB     r0,[r4,#0xa]
;;;562        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
000122  f50570c0          ADD      r0,r5,#0x180
000126  eb001006          ADD      r0,r0,r6,LSL #4
00012a  6840              LDR      r0,[r0,#4]
00012c  f020010f          BIC      r1,r0,#0xf
000130  f50570c0          ADD      r0,r5,#0x180
000134  eb001006          ADD      r0,r0,r6,LSL #4
000138  6041              STR      r1,[r0,#4]
;;;563        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
00013a  f50570c0          ADD      r0,r5,#0x180
00013e  eb001006          ADD      r0,r0,r6,LSL #4
000142  6840              LDR      r0,[r0,#4]
000144  7aa1              LDRB     r1,[r4,#0xa]
000146  4308              ORRS     r0,r0,r1
000148  f50571c0          ADD      r1,r5,#0x180
00014c  eb011106          ADD      r1,r1,r6,LSL #4
000150  6048              STR      r0,[r1,#4]
;;;564    
;;;565        /* Set up the data field */
;;;566        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000152  7ba0              LDRB     r0,[r4,#0xe]
000154  0601              LSLS     r1,r0,#24
000156  7b60              LDRB     r0,[r4,#0xd]
000158  ea414100          ORR      r1,r1,r0,LSL #16
00015c  7b20              LDRB     r0,[r4,#0xc]
00015e  ea412000          ORR      r0,r1,r0,LSL #8
000162  7ae1              LDRB     r1,[r4,#0xb]
000164  4308              ORRS     r0,r0,r1
000166  f50571c0          ADD      r1,r5,#0x180
00016a  eb011106          ADD      r1,r1,r6,LSL #4
00016e  6088              STR      r0,[r1,#8]
;;;567                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;568                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;569                                                 ((uint32_t)TxMessage->Data[0]));
;;;570        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000170  7ca0              LDRB     r0,[r4,#0x12]
000172  0601              LSLS     r1,r0,#24
000174  7c60              LDRB     r0,[r4,#0x11]
000176  ea414100          ORR      r1,r1,r0,LSL #16
00017a  7c20              LDRB     r0,[r4,#0x10]
00017c  ea412000          ORR      r0,r1,r0,LSL #8
000180  7be1              LDRB     r1,[r4,#0xf]
000182  4308              ORRS     r0,r0,r1
000184  f50571c0          ADD      r1,r5,#0x180
000188  eb011106          ADD      r1,r1,r6,LSL #4
00018c  60c8              STR      r0,[r1,#0xc]
;;;571                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;572                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;573                                                 ((uint32_t)TxMessage->Data[4]));
;;;574        /* Request transmission */
;;;575        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00018e  e000              B        |L22.402|
                  |L22.400|
000190  e00b              B        |L22.426|
                  |L22.402|
000192  f50570c0          ADD      r0,r5,#0x180
000196  eb001006          ADD      r0,r0,r6,LSL #4
00019a  6800              LDR      r0,[r0,#0]
00019c  f0400101          ORR      r1,r0,#1
0001a0  f50570c0          ADD      r0,r5,#0x180
0001a4  eb001006          ADD      r0,r0,r6,LSL #4
0001a8  6001              STR      r1,[r0,#0]
                  |L22.426|
;;;576      }
;;;577      return transmit_mailbox;
0001aa  4630              MOV      r0,r6
;;;578    }
0001ac  bd70              POP      {r4-r6,pc}
;;;579    
                          ENDP

0001ae  0000              DCW      0x0000
                  |L22.432|
                          DCD      0x40006400
                  |L22.436|
                          DCD      0x40006800

                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;588      */
;;;589    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  b570              PUSH     {r4-r6,lr}
;;;590    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;591      uint32_t state = 0;
000006  2600              MOVS     r6,#0
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  492a              LDR      r1,|L23.180|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L23.20|
00000e  492a              LDR      r1,|L23.184|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L23.24|
                  |L23.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L23.26|
                  |L23.24|
000018  2100              MOVS     r1,#0
                  |L23.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;595      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
000020  2d02              CMP      r5,#2
000022  dc01              BGT      |L23.40|
000024  2101              MOVS     r1,#1
000026  e000              B        |L23.42|
                  |L23.40|
000028  2100              MOVS     r1,#0
                  |L23.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;596     
;;;597      switch (TransmitMailbox)
000030  b125              CBZ      r5,|L23.60|
000032  2d01              CMP      r5,#1
000034  d007              BEQ      |L23.70|
000036  2d02              CMP      r5,#2
000038  d10f              BNE      |L23.90|
00003a  e009              B        |L23.80|
                  |L23.60|
;;;598      {
;;;599        case (CAN_TXMAILBOX_0): 
;;;600          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
00003c  68a0              LDR      r0,[r4,#8]
00003e  491f              LDR      r1,|L23.188|
000040  ea000601          AND      r6,r0,r1
;;;601          break;
000044  e00b              B        |L23.94|
                  |L23.70|
;;;602        case (CAN_TXMAILBOX_1): 
;;;603          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000046  68a0              LDR      r0,[r4,#8]
000048  491d              LDR      r1,|L23.192|
00004a  ea000601          AND      r6,r0,r1
;;;604          break;
00004e  e006              B        |L23.94|
                  |L23.80|
;;;605        case (CAN_TXMAILBOX_2): 
;;;606          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
000050  68a0              LDR      r0,[r4,#8]
000052  491c              LDR      r1,|L23.196|
000054  ea000601          AND      r6,r0,r1
;;;607          break;
000058  e001              B        |L23.94|
                  |L23.90|
;;;608        default:
;;;609          state = CAN_TxStatus_Failed;
00005a  2600              MOVS     r6,#0
;;;610          break;
00005c  bf00              NOP      
                  |L23.94|
00005e  bf00              NOP                            ;601
;;;611      }
;;;612      switch (state)
000060  4919              LDR      r1,|L23.200|
000062  1a70              SUBS     r0,r6,r1
000064  428e              CMP      r6,r1
000066  d016              BEQ      |L23.150|
000068  dc07              BGT      |L23.122|
00006a  b186              CBZ      r6,|L23.142|
00006c  f06f6080          MVN      r0,#0x4000000
000070  4430              ADD      r0,r0,r6
000072  b170              CBZ      r0,|L23.146|
000074  2802              CMP      r0,#2
000076  d118              BNE      |L23.170|
000078  e011              B        |L23.158|
                  |L23.122|
00007a  f5b07f00          CMP      r0,#0x200
00007e  d010              BEQ      |L23.162|
000080  4912              LDR      r1,|L23.204|
000082  4408              ADD      r0,r0,r1
000084  b148              CBZ      r0,|L23.154|
000086  f5b03f00          CMP      r0,#0x20000
00008a  d10e              BNE      |L23.170|
00008c  e00b              B        |L23.166|
                  |L23.142|
;;;613      {
;;;614          /* transmit pending  */
;;;615        case (0x0): state = CAN_TxStatus_Pending;
00008e  2602              MOVS     r6,#2
;;;616          break;
000090  e00d              B        |L23.174|
                  |L23.146|
;;;617          /* transmit failed  */
;;;618         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
000092  2600              MOVS     r6,#0
;;;619          break;
000094  e00b              B        |L23.174|
                  |L23.150|
;;;620         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
000096  2600              MOVS     r6,#0
;;;621          break;
000098  e009              B        |L23.174|
                  |L23.154|
;;;622         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
00009a  2600              MOVS     r6,#0
;;;623          break;
00009c  e007              B        |L23.174|
                  |L23.158|
;;;624          /* transmit succeeded  */
;;;625        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
00009e  2601              MOVS     r6,#1
;;;626          break;
0000a0  e005              B        |L23.174|
                  |L23.162|
;;;627        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
0000a2  2601              MOVS     r6,#1
;;;628          break;
0000a4  e003              B        |L23.174|
                  |L23.166|
;;;629        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
0000a6  2601              MOVS     r6,#1
;;;630          break;
0000a8  e001              B        |L23.174|
                  |L23.170|
;;;631        default: state = CAN_TxStatus_Failed;
0000aa  2600              MOVS     r6,#0
;;;632          break;
0000ac  bf00              NOP      
                  |L23.174|
0000ae  bf00              NOP                            ;616
;;;633      }
;;;634      return (uint8_t) state;
0000b0  b2f0              UXTB     r0,r6
;;;635    }
0000b2  bd70              POP      {r4-r6,pc}
;;;636    
                          ENDP

                  |L23.180|
                          DCD      0x40006400
                  |L23.184|
                          DCD      0x40006800
                  |L23.188|
                          DCD      0x04000003
                  |L23.192|
                          DCD      0x08000300
                  |L23.196|
                          DCD      0x10030000
                  |L23.200|
                          DCD      0x08000100
                  |L23.204|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  CAN_WakeUp PROC
;;;881      */
;;;882    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;883    {
000002  4604              MOV      r4,r0
;;;884      uint32_t wait_slak = SLAK_TIMEOUT;
000004  f64f75ff          MOV      r5,#0xffff
;;;885      uint8_t wakeupstatus = CAN_WakeUp_Failed;
000008  2600              MOVS     r6,#0
;;;886      
;;;887      /* Check the parameters */
;;;888      assert_param(IS_CAN_ALL_PERIPH(CANx));
00000a  4910              LDR      r1,|L24.76|
00000c  428c              CMP      r4,r1
00000e  d002              BEQ      |L24.22|
000010  490f              LDR      r1,|L24.80|
000012  428c              CMP      r4,r1
000014  d101              BNE      |L24.26|
                  |L24.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L24.28|
                  |L24.26|
00001a  2100              MOVS     r1,#0
                  |L24.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;889        
;;;890      /* Wake up request */
;;;891      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000022  6820              LDR      r0,[r4,#0]
000024  f0200002          BIC      r0,r0,#2
000028  6020              STR      r0,[r4,#0]
;;;892        
;;;893      /* Sleep mode status */
;;;894      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
00002a  e000              B        |L24.46|
                  |L24.44|
;;;895      {
;;;896       wait_slak--;
00002c  1e6d              SUBS     r5,r5,#1
                  |L24.46|
00002e  6860              LDR      r0,[r4,#4]            ;894
000030  f0000002          AND      r0,r0,#2              ;894
000034  2802              CMP      r0,#2                 ;894
000036  d101              BNE      |L24.60|
000038  2d00              CMP      r5,#0                 ;894
00003a  d1f7              BNE      |L24.44|
                  |L24.60|
;;;897      }
;;;898      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00003c  6860              LDR      r0,[r4,#4]
00003e  f0000002          AND      r0,r0,#2
000042  2802              CMP      r0,#2
000044  d000              BEQ      |L24.72|
;;;899      {
;;;900       /* wake up done : Sleep mode exited */
;;;901        wakeupstatus = CAN_WakeUp_Ok;
000046  2601              MOVS     r6,#1
                  |L24.72|
;;;902      }
;;;903      /* return wakeup status */
;;;904      return (uint8_t)wakeupstatus;
000048  4630              MOV      r0,r6
;;;905    }
00004a  bd70              POP      {r4-r6,pc}
;;;906    
                          ENDP

                  |L24.76|
                          DCD      0x40006400
                  |L24.80|
                          DCD      0x40006800

                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1384     */
;;;1385   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1386   {
;;;1387     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1388     
;;;1389     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  ea020301          AND      r3,r2,r1
000008  b10b              CBZ      r3,|L25.14|
;;;1390     {
;;;1391       /* CAN_IT is set */
;;;1392       pendingbitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L25.16|
                  |L25.14|
;;;1393     }
;;;1394     else
;;;1395     {
;;;1396       /* CAN_IT is reset */
;;;1397       pendingbitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L25.16|
;;;1398     }
;;;1399     return pendingbitstatus;
;;;1400   }
000010  4770              BX       lr
;;;1401   
                          ENDP

