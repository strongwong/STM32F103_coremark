; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_flash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_flash.crf ..\Chip\Hal_lib\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1442     */
;;;1443   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1444   {
000002  4604              MOV      r4,r0
;;;1445   #ifdef STM32F10X_XL
;;;1446     /* Check the parameters */
;;;1447     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1448   
;;;1449     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1450     {
;;;1451       /* Clear the flags */
;;;1452       FLASH->SR2 = FLASH_FLAG;
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       /* Clear the flags */
;;;1457       FLASH->SR = FLASH_FLAG;
;;;1458     }  
;;;1459   
;;;1460   #else
;;;1461     /* Check the parameters */
;;;1462     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
000004  f0240135          BIC      r1,r4,#0x35
000008  b911              CBNZ     r1,|L1.16|
00000a  b10c              CBZ      r4,|L1.16|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L1.18|
                  |L1.16|
000010  2100              MOVS     r1,#0
                  |L1.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;1463     
;;;1464     /* Clear the flags */
;;;1465     FLASH->SR = FLASH_FLAG;
000018  4801              LDR      r0,|L1.32|
00001a  60c4              STR      r4,[r0,#0xc]
;;;1466   #endif /* STM32F10X_XL */
;;;1467   }
00001c  bd10              POP      {r4,pc}
;;;1468   
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;974      */
;;;975    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;976    {
000004  4604              MOV      r4,r0
;;;977      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;978      
;;;979      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;980      
;;;981      /* Check the parameters */
;;;982      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
000012  b10c              CBZ      r4,|L2.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L2.26|
                  |L2.24|
000018  2100              MOVS     r1,#0
                  |L2.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;983      
;;;984      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000020  43e4              MVNS     r4,r4
;;;985      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000022  b2e6              UXTB     r6,r4
;;;986      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000024  f3c42707          UBFX     r7,r4,#8,#8
;;;987      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
000028  f3c44807          UBFX     r8,r4,#16,#8
;;;988      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00002c  ea4f6914          LSR      r9,r4,#24
;;;989      
;;;990      /* Wait for last operation to be completed */
;;;991      status = FLASH_WaitForLastOperation(ProgramTimeout);
000030  f44f5000          MOV      r0,#0x2000
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;992      
;;;993      if(status == FLASH_COMPLETE)
00003a  2d04              CMP      r5,#4
00003c  d13f              BNE      |L2.190|
;;;994      {
;;;995        /* Authorizes the small information block programming */
;;;996        FLASH->OPTKEYR = FLASH_KEY1;
00003e  4821              LDR      r0,|L2.196|
000040  4921              LDR      r1,|L2.200|
000042  6088              STR      r0,[r1,#8]
;;;997        FLASH->OPTKEYR = FLASH_KEY2;
000044  4821              LDR      r0,|L2.204|
000046  6088              STR      r0,[r1,#8]
;;;998        FLASH->CR |= CR_OPTPG_Set;
000048  4608              MOV      r0,r1
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f0400010          ORR      r0,r0,#0x10
000050  6108              STR      r0,[r1,#0x10]
;;;999        if(WRP0_Data != 0xFF)
000052  2eff              CMP      r6,#0xff
000054  d005              BEQ      |L2.98|
;;;1000       {
;;;1001         OB->WRP0 = WRP0_Data;
000056  481e              LDR      r0,|L2.208|
000058  8006              STRH     r6,[r0,#0]
;;;1002         
;;;1003         /* Wait for last operation to be completed */
;;;1004         status = FLASH_WaitForLastOperation(ProgramTimeout);
00005a  02e8              LSLS     r0,r5,#11
00005c  f7fffffe          BL       FLASH_WaitForLastOperation
000060  4605              MOV      r5,r0
                  |L2.98|
;;;1005       }
;;;1006       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000062  2d04              CMP      r5,#4
000064  d108              BNE      |L2.120|
000066  2fff              CMP      r7,#0xff
000068  d006              BEQ      |L2.120|
;;;1007       {
;;;1008         OB->WRP1 = WRP1_Data;
00006a  4819              LDR      r0,|L2.208|
00006c  1c80              ADDS     r0,r0,#2
00006e  8007              STRH     r7,[r0,#0]
;;;1009         
;;;1010         /* Wait for last operation to be completed */
;;;1011         status = FLASH_WaitForLastOperation(ProgramTimeout);
000070  02e8              LSLS     r0,r5,#11
000072  f7fffffe          BL       FLASH_WaitForLastOperation
000076  4605              MOV      r5,r0
                  |L2.120|
;;;1012       }
;;;1013       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000078  2d04              CMP      r5,#4
00007a  d10a              BNE      |L2.146|
00007c  f1b80fff          CMP      r8,#0xff
000080  d007              BEQ      |L2.146|
;;;1014       {
;;;1015         OB->WRP2 = WRP2_Data;
000082  4813              LDR      r0,|L2.208|
000084  1d00              ADDS     r0,r0,#4
000086  f8a08000          STRH     r8,[r0,#0]
;;;1016         
;;;1017         /* Wait for last operation to be completed */
;;;1018         status = FLASH_WaitForLastOperation(ProgramTimeout);
00008a  02e8              LSLS     r0,r5,#11
00008c  f7fffffe          BL       FLASH_WaitForLastOperation
000090  4605              MOV      r5,r0
                  |L2.146|
;;;1019       }
;;;1020       
;;;1021       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000092  2d04              CMP      r5,#4
000094  d10a              BNE      |L2.172|
000096  f1b90fff          CMP      r9,#0xff
00009a  d007              BEQ      |L2.172|
;;;1022       {
;;;1023         OB->WRP3 = WRP3_Data;
00009c  480c              LDR      r0,|L2.208|
00009e  1d80              ADDS     r0,r0,#6
0000a0  f8a09000          STRH     r9,[r0,#0]
;;;1024        
;;;1025         /* Wait for last operation to be completed */
;;;1026         status = FLASH_WaitForLastOperation(ProgramTimeout);
0000a4  02e8              LSLS     r0,r5,#11
0000a6  f7fffffe          BL       FLASH_WaitForLastOperation
0000aa  4605              MOV      r5,r0
                  |L2.172|
;;;1027       }
;;;1028             
;;;1029       if(status != FLASH_TIMEOUT)
0000ac  2d05              CMP      r5,#5
0000ae  d006              BEQ      |L2.190|
;;;1030       {
;;;1031         /* if the program operation is completed, disable the OPTPG Bit */
;;;1032         FLASH->CR &= CR_OPTPG_Reset;
0000b0  4805              LDR      r0,|L2.200|
0000b2  6900              LDR      r0,[r0,#0x10]
0000b4  f64171ef          MOV      r1,#0x1fef
0000b8  4008              ANDS     r0,r0,r1
0000ba  4903              LDR      r1,|L2.200|
0000bc  6108              STR      r0,[r1,#0x10]
                  |L2.190|
;;;1033       }
;;;1034     } 
;;;1035     /* Return the write protection operation Status */
;;;1036     return status;       
0000be  4628              MOV      r0,r5
;;;1037   }
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;1038   
                          ENDP

                  |L2.196|
                          DCD      0x45670123
                  |L2.200|
                          DCD      0x40022000
                  |L2.204|
                          DCD      0xcdef89ab
                  |L2.208|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;554      */
;;;555    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;556    {
;;;557      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;558      /* Wait for last operation to be completed */
;;;559      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;560      
;;;561      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L3.64|
;;;562      {
;;;563        /* if the previous operation is completed, proceed to erase all pages */
;;;564         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L3.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L3.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;565         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;566        
;;;567        /* Wait for last operation to be completed */
;;;568        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;569        
;;;570        /* Disable the MER Bit */
;;;571        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L3.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L3.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L3.64|
;;;572      }    
;;;573      /* Return the Erase Status */
;;;574      return status;
000040  4620              MOV      r0,r4
;;;575    }
000042  bd10              POP      {r4,pc}
;;;576    
                          ENDP

                  |L3.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;491      */
;;;492    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;493    {
;;;494      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;495    
;;;496    #ifdef STM32F10X_XL
;;;497      /* Wait for last operation to be completed */
;;;498      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;499      
;;;500      if(status == FLASH_COMPLETE)
;;;501      {
;;;502        /* if the previous operation is completed, proceed to erase all pages */
;;;503         FLASH->CR |= CR_MER_Set;
;;;504         FLASH->CR |= CR_STRT_Set;
;;;505        
;;;506        /* Wait for last operation to be completed */
;;;507        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;508        
;;;509        /* Disable the MER Bit */
;;;510        FLASH->CR &= CR_MER_Reset;
;;;511      }    
;;;512      if(status == FLASH_COMPLETE)
;;;513      {
;;;514        /* if the previous operation is completed, proceed to erase all pages */
;;;515         FLASH->CR2 |= CR_MER_Set;
;;;516         FLASH->CR2 |= CR_STRT_Set;
;;;517        
;;;518        /* Wait for last operation to be completed */
;;;519        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;520        
;;;521        /* Disable the MER Bit */
;;;522        FLASH->CR2 &= CR_MER_Reset;
;;;523      }
;;;524    #else
;;;525      /* Wait for last operation to be completed */
;;;526      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;527      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L4.64|
;;;528      {
;;;529        /* if the previous operation is completed, proceed to erase all pages */
;;;530         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L4.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L4.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;531         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;532        
;;;533        /* Wait for last operation to be completed */
;;;534        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;535    
;;;536        /* Disable the MER Bit */
;;;537        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L4.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L4.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;538      }
;;;539    #endif /* STM32F10X_XL */
;;;540    
;;;541      /* Return the Erase Status */
;;;542      return status;
000040  4620              MOV      r0,r4
;;;543    }
000042  bd10              POP      {r4,pc}
;;;544    
                          ENDP

                  |L4.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;615      */
;;;616    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;617    {
;;;618      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;619    
;;;620      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;621    
;;;622      /* Get the actual read protection Option Byte value */ 
;;;623      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;624      {
;;;625        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;626      }
;;;627    
;;;628      /* Wait for last operation to be completed */
;;;629      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;630      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13a              BNE      |L5.146|
;;;631      {
;;;632        /* Authorize the small information block programming */
;;;633        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;634        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;635        
;;;636        /* if the previous operation is completed, proceed to erase the option bytes */
;;;637        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;638        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;639        /* Wait for last operation to be completed */
;;;640        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;641        
;;;642        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11b              BNE      |L5.128|
;;;643        {
;;;644          /* if the erase operation is completed, disable the OPTER Bit */
;;;645          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;646           
;;;647          /* Enable the Option Bytes Programming operation */
;;;648          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;649          /* Restore the last read protection Option Byte value */
;;;650          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;651          /* Wait for last operation to be completed */
;;;652          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  02e0              LSLS     r0,r4,#11
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4604              MOV      r4,r0
;;;653     
;;;654          if(status != FLASH_TIMEOUT)
00006c  2c05              CMP      r4,#5
00006e  d010              BEQ      |L5.146|
;;;655          {
;;;656            /* if the program operation is completed, disable the OPTPG Bit */
;;;657            FLASH->CR &= CR_OPTPG_Reset;
000070  480a              LDR      r0,|L5.156|
000072  6900              LDR      r0,[r0,#0x10]
000074  f64171ef          MOV      r1,#0x1fef
000078  4008              ANDS     r0,r0,r1
00007a  4908              LDR      r1,|L5.156|
00007c  6108              STR      r0,[r1,#0x10]
00007e  e008              B        |L5.146|
                  |L5.128|
;;;658          }
;;;659        }
;;;660        else
;;;661        {
;;;662          if (status != FLASH_TIMEOUT)
000080  2c05              CMP      r4,#5
000082  d006              BEQ      |L5.146|
;;;663          {
;;;664            /* Disable the OPTPG Bit */
;;;665            FLASH->CR &= CR_OPTPG_Reset;
000084  4805              LDR      r0,|L5.156|
000086  6900              LDR      r0,[r0,#0x10]
000088  f64171ef          MOV      r1,#0x1fef
00008c  4008              ANDS     r0,r0,r1
00008e  4903              LDR      r1,|L5.156|
000090  6108              STR      r0,[r1,#0x10]
                  |L5.146|
;;;666          }
;;;667        }  
;;;668      }
;;;669      /* Return the erase status */
;;;670      return status;
000092  4620              MOV      r0,r4
;;;671    }
000094  bd30              POP      {r4,r5,pc}
;;;672    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;418      */
;;;419    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;422      /* Check the parameters */
;;;423      assert_param(IS_FLASH_ADDRESS(Page_Address));
000006  f1b46f00          CMP      r4,#0x8000000
00000a  d304              BCC      |L6.22|
00000c  4914              LDR      r1,|L6.96|
00000e  428c              CMP      r4,r1
000010  d201              BCS      |L6.22|
000012  2101              MOVS     r1,#1
000014  e000              B        |L6.24|
                  |L6.22|
000016  2100              MOVS     r1,#0
                  |L6.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;424    
;;;425    #ifdef STM32F10X_XL
;;;426      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;427      {
;;;428        /* Wait for last operation to be completed */
;;;429        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;430        if(status == FLASH_COMPLETE)
;;;431        { 
;;;432          /* if the previous operation is completed, proceed to erase the page */
;;;433          FLASH->CR|= CR_PER_Set;
;;;434          FLASH->AR = Page_Address; 
;;;435          FLASH->CR|= CR_STRT_Set;
;;;436        
;;;437          /* Wait for last operation to be completed */
;;;438          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;439    
;;;440          /* Disable the PER Bit */
;;;441          FLASH->CR &= CR_PER_Reset;
;;;442        }
;;;443      }
;;;444      else
;;;445      {
;;;446        /* Wait for last operation to be completed */
;;;447        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;448        if(status == FLASH_COMPLETE)
;;;449        { 
;;;450          /* if the previous operation is completed, proceed to erase the page */
;;;451          FLASH->CR2|= CR_PER_Set;
;;;452          FLASH->AR2 = Page_Address; 
;;;453          FLASH->CR2|= CR_STRT_Set;
;;;454        
;;;455          /* Wait for last operation to be completed */
;;;456          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;457          
;;;458          /* Disable the PER Bit */
;;;459          FLASH->CR2 &= CR_PER_Reset;
;;;460        }
;;;461      }
;;;462    #else
;;;463      /* Wait for last operation to be completed */
;;;464      status = FLASH_WaitForLastOperation(EraseTimeout);
00001e  f44f2030          MOV      r0,#0xb0000
000022  f7fffffe          BL       FLASH_WaitForLastOperation
000026  4605              MOV      r5,r0
;;;465      
;;;466      if(status == FLASH_COMPLETE)
000028  2d04              CMP      r5,#4
00002a  d117              BNE      |L6.92|
;;;467      { 
;;;468        /* if the previous operation is completed, proceed to erase the page */
;;;469        FLASH->CR|= CR_PER_Set;
00002c  480d              LDR      r0,|L6.100|
00002e  6900              LDR      r0,[r0,#0x10]
000030  f0400002          ORR      r0,r0,#2
000034  490b              LDR      r1,|L6.100|
000036  6108              STR      r0,[r1,#0x10]
;;;470        FLASH->AR = Page_Address; 
000038  4608              MOV      r0,r1
00003a  6144              STR      r4,[r0,#0x14]
;;;471        FLASH->CR|= CR_STRT_Set;
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f0400040          ORR      r0,r0,#0x40
000042  6108              STR      r0,[r1,#0x10]
;;;472        
;;;473        /* Wait for last operation to be completed */
;;;474        status = FLASH_WaitForLastOperation(EraseTimeout);
000044  f44f2030          MOV      r0,#0xb0000
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4605              MOV      r5,r0
;;;475        
;;;476        /* Disable the PER Bit */
;;;477        FLASH->CR &= CR_PER_Reset;
00004e  4805              LDR      r0,|L6.100|
000050  6900              LDR      r0,[r0,#0x10]
000052  f64171fd          MOV      r1,#0x1ffd
000056  4008              ANDS     r0,r0,r1
000058  4902              LDR      r1,|L6.100|
00005a  6108              STR      r0,[r1,#0x10]
                  |L6.92|
;;;478      }
;;;479    #endif /* STM32F10X_XL */
;;;480    
;;;481      /* Return the Erase Status */
;;;482      return status;
00005c  4628              MOV      r0,r5
;;;483    }
00005e  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

                  |L6.96|
                          DCD      0x080fffff
                  |L6.100|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1514     */
;;;1515   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1516   {
;;;1517     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1518     
;;;1519     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L7.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L7.16|
;;;1520     {
;;;1521       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L7.46|
                  |L7.16|
;;;1522     }
;;;1523     else 
;;;1524     {  
;;;1525       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000010  4907              LDR      r1,|L7.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L7.30|
;;;1526       { 
;;;1527         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1528       }
;;;1529       else 
;;;1530       {
;;;1531         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L7.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L7.44|
;;;1532         {
;;;1533           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L7.46|
                  |L7.44|
;;;1534         }
;;;1535         else
;;;1536         {
;;;1537           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L7.46|
;;;1538         }
;;;1539       }
;;;1540     }
;;;1541     /* Return the Flash Status */
;;;1542     return flashstatus;
;;;1543   }
00002e  4770              BX       lr
;;;1544   
                          ENDP

                  |L7.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1356     */
;;;1357   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1358   {
000002  4604              MOV      r4,r0
;;;1359     FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;1360   
;;;1361   #ifdef STM32F10X_XL
;;;1362     /* Check the parameters */
;;;1363     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1364     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1365     {
;;;1366       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1367       {
;;;1368         bitstatus = SET;
;;;1369       }
;;;1370       else
;;;1371       {
;;;1372         bitstatus = RESET;
;;;1373       }
;;;1374     }
;;;1375     else
;;;1376     {
;;;1377       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1378       {
;;;1379         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1380         {
;;;1381           bitstatus = SET;
;;;1382         }
;;;1383         else
;;;1384         {
;;;1385           bitstatus = RESET;
;;;1386         }
;;;1387       }
;;;1388       else
;;;1389       {
;;;1390         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1391         {
;;;1392           bitstatus = SET;
;;;1393         }
;;;1394         else
;;;1395         {
;;;1396           bitstatus = RESET;
;;;1397         }
;;;1398       }
;;;1399     }
;;;1400   #else
;;;1401     /* Check the parameters */
;;;1402     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
000006  2c01              CMP      r4,#1
000008  d00f              BEQ      |L8.42|
00000a  2c20              CMP      r4,#0x20
00000c  d00d              BEQ      |L8.42|
00000e  2c04              CMP      r4,#4
000010  d00b              BEQ      |L8.42|
000012  2c10              CMP      r4,#0x10
000014  d009              BEQ      |L8.42|
000016  2c01              CMP      r4,#1
000018  d007              BEQ      |L8.42|
00001a  2c20              CMP      r4,#0x20
00001c  d005              BEQ      |L8.42|
00001e  2c04              CMP      r4,#4
000020  d003              BEQ      |L8.42|
000022  2c10              CMP      r4,#0x10
000024  d001              BEQ      |L8.42|
000026  2c01              CMP      r4,#1
000028  d101              BNE      |L8.46|
                  |L8.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L8.48|
                  |L8.46|
00002e  2100              MOVS     r1,#0
                  |L8.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;1403     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000036  2c01              CMP      r4,#1
000038  d108              BNE      |L8.76|
;;;1404     {
;;;1405       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
00003a  4809              LDR      r0,|L8.96|
00003c  69c0              LDR      r0,[r0,#0x1c]
00003e  f0000001          AND      r0,r0,#1
000042  b108              CBZ      r0,|L8.72|
;;;1406       {
;;;1407         bitstatus = SET;
000044  2501              MOVS     r5,#1
000046  e008              B        |L8.90|
                  |L8.72|
;;;1408       }
;;;1409       else
;;;1410       {
;;;1411         bitstatus = RESET;
000048  2500              MOVS     r5,#0
00004a  e006              B        |L8.90|
                  |L8.76|
;;;1412       }
;;;1413     }
;;;1414     else
;;;1415     {
;;;1416      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00004c  4804              LDR      r0,|L8.96|
00004e  68c0              LDR      r0,[r0,#0xc]
000050  4020              ANDS     r0,r0,r4
000052  b108              CBZ      r0,|L8.88|
;;;1417       {
;;;1418         bitstatus = SET;
000054  2501              MOVS     r5,#1
000056  e000              B        |L8.90|
                  |L8.88|
;;;1419       }
;;;1420       else
;;;1421       {
;;;1422         bitstatus = RESET;
000058  2500              MOVS     r5,#0
                  |L8.90|
;;;1423       }
;;;1424     }
;;;1425   #endif /* STM32F10X_XL */
;;;1426   
;;;1427     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1428     return bitstatus;
00005a  4628              MOV      r0,r5
;;;1429   }
00005c  bd70              POP      {r4-r6,pc}
;;;1430   
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1259     */
;;;1260   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1261   {
;;;1262     FlagStatus bitstatus = RESET;
;;;1263     
;;;1264     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L9.16|
;;;1265     {
;;;1266       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1267     }
;;;1268     else
;;;1269     {
;;;1270       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1271     }
;;;1272     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1273     return bitstatus; 
;;;1274   }
000012  4770              BX       lr
;;;1275   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1239     */
;;;1240   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1241   {
;;;1242     FlagStatus readoutstatus = RESET;
;;;1243     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L10.16|
;;;1244     {
;;;1245       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1246     }
;;;1247     else
;;;1248     {
;;;1249       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1250     }
;;;1251     return readoutstatus;
;;;1252   }
000012  4770              BX       lr
;;;1253   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1476     */
;;;1477   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1478   {
;;;1479     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1480     
;;;1481     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L11.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L11.16|
;;;1482     {
;;;1483       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L11.46|
                  |L11.16|
;;;1484     }
;;;1485     else 
;;;1486     {  
;;;1487       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L11.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L11.30|
;;;1488       { 
;;;1489         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L11.46|
                  |L11.30|
;;;1490       }
;;;1491       else 
;;;1492       {
;;;1493         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L11.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L11.44|
;;;1494         {
;;;1495           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L11.46|
                  |L11.44|
;;;1496         }
;;;1497         else
;;;1498         {
;;;1499           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L11.46|
;;;1500         }
;;;1501       }
;;;1502     }
;;;1503     /* Return the Flash Status */
;;;1504     return flashstatus;
;;;1505   }
00002e  4770              BX       lr
;;;1506   
                          ENDP

                  |L11.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1215     */
;;;1216   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1217   {
;;;1218     /* Return the User Option Byte */
;;;1219     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1220   }
000006  4770              BX       lr
;;;1221   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1227     */
;;;1228   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1229   {
;;;1230     /* Return the Flash write protection Register value */
;;;1231     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1232   }
000004  4770              BX       lr
;;;1233   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;280      */
;;;281    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  b510              PUSH     {r4,lr}
;;;282    {
000002  4604              MOV      r4,r0
;;;283      /* Check the parameters */
;;;284      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
000004  2c08              CMP      r4,#8
000006  d000              BEQ      |L14.10|
000008  b90c              CBNZ     r4,|L14.14|
                  |L14.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L14.16|
                  |L14.14|
00000e  2100              MOVS     r1,#0
                  |L14.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;285      
;;;286      /* Enable or disable the Half cycle access */
;;;287      FLASH->ACR &= ACR_HLFCYA_Mask;
000016  4805              LDR      r0,|L14.44|
000018  6800              LDR      r0,[r0,#0]
00001a  f0200008          BIC      r0,r0,#8
00001e  4903              LDR      r1,|L14.44|
000020  6008              STR      r0,[r1,#0]
;;;288      FLASH->ACR |= FLASH_HalfCycleAccess;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  4320              ORRS     r0,r0,r4
000028  6008              STR      r0,[r1,#0]
;;;289    }
00002a  bd10              POP      {r4,pc}
;;;290    
                          ENDP

                  |L14.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1289     */
;;;1290   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1291   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1292   #ifdef STM32F10X_XL
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1295     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1296   
;;;1297     if((FLASH_IT & 0x80000000) != 0x0)
;;;1298     {
;;;1299       if(NewState != DISABLE)
;;;1300       {
;;;1301         /* Enable the interrupt sources */
;;;1302         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1303       }
;;;1304       else
;;;1305       {
;;;1306         /* Disable the interrupt sources */
;;;1307         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1308       }
;;;1309     }
;;;1310     else
;;;1311     {
;;;1312       if(NewState != DISABLE)
;;;1313       {
;;;1314         /* Enable the interrupt sources */
;;;1315         FLASH->CR |= FLASH_IT;
;;;1316       }
;;;1317       else
;;;1318       {
;;;1319         /* Disable the interrupt sources */
;;;1320         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1321       }
;;;1322     }
;;;1323   #else
;;;1324     /* Check the parameters */
;;;1325     assert_param(IS_FLASH_IT(FLASH_IT)); 
000006  f42451a0          BIC      r1,r4,#0x1400
00000a  b911              CBNZ     r1,|L15.18|
00000c  b10c              CBZ      r4,|L15.18|
00000e  2101              MOVS     r1,#1
000010  e000              B        |L15.20|
                  |L15.18|
000012  2100              MOVS     r1,#0
                  |L15.20|
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       assert_param
;;;1326     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L15.32|
00001c  2d01              CMP      r5,#1
00001e  d101              BNE      |L15.36|
                  |L15.32|
000020  2101              MOVS     r1,#1
000022  e000              B        |L15.38|
                  |L15.36|
000024  2100              MOVS     r1,#0
                  |L15.38|
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       assert_param
;;;1327   
;;;1328     if(NewState != DISABLE)
00002c  b12d              CBZ      r5,|L15.58|
;;;1329     {
;;;1330       /* Enable the interrupt sources */
;;;1331       FLASH->CR |= FLASH_IT;
00002e  4806              LDR      r0,|L15.72|
000030  6900              LDR      r0,[r0,#0x10]
000032  4320              ORRS     r0,r0,r4
000034  4904              LDR      r1,|L15.72|
000036  6108              STR      r0,[r1,#0x10]
000038  e004              B        |L15.68|
                  |L15.58|
;;;1332     }
;;;1333     else
;;;1334     {
;;;1335       /* Disable the interrupt sources */
;;;1336       FLASH->CR &= ~(uint32_t)FLASH_IT;
00003a  4803              LDR      r0,|L15.72|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  43a0              BICS     r0,r0,r4
000040  4901              LDR      r1,|L15.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L15.68|
;;;1337     }
;;;1338   #endif /* STM32F10X_XL */
;;;1339   }
000044  bd70              POP      {r4-r6,pc}
;;;1340   
                          ENDP

000046  0000              DCW      0x0000
                  |L15.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;371      */
;;;372    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;373    {
;;;374      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;375      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;376    
;;;377    #ifdef STM32F10X_XL
;;;378      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;379      FLASH->CR2 |= CR_LOCK_Set;
;;;380    #endif /* STM32F10X_XL */
;;;381    }
00000c  4770              BX       lr
;;;382    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;391      */
;;;392    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;393    {
;;;394      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;395      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;396    }
00000c  4770              BX       lr
;;;397    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;299      */
;;;300    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  b510              PUSH     {r4,lr}
;;;301    {
000002  4604              MOV      r4,r0
;;;302      /* Check the parameters */
;;;303      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
000004  2c10              CMP      r4,#0x10
000006  d000              BEQ      |L18.10|
000008  b90c              CBNZ     r4,|L18.14|
                  |L18.10|
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L18.16|
                  |L18.14|
00000e  2100              MOVS     r1,#0
                  |L18.16|
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       assert_param
;;;304      
;;;305      /* Enable or disable the Prefetch Buffer */
;;;306      FLASH->ACR &= ACR_PRFTBE_Mask;
000016  4805              LDR      r0,|L18.44|
000018  6800              LDR      r0,[r0,#0]
00001a  f0200010          BIC      r0,r0,#0x10
00001e  4903              LDR      r1,|L18.44|
000020  6008              STR      r0,[r1,#0]
;;;307      FLASH->ACR |= FLASH_PrefetchBuffer;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  4320              ORRS     r0,r0,r4
000028  6008              STR      r0,[r1,#0]
;;;308    }
00002a  bd10              POP      {r4,pc}
;;;309    
                          ENDP

                  |L18.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;857      */
;;;858    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;859    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;860      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;861      /* Check the parameters */
;;;862      assert_param(IS_FLASH_ADDRESS(Address));
000008  f1b46f00          CMP      r4,#0x8000000
00000c  d304              BCC      |L19.24|
00000e  4912              LDR      r1,|L19.88|
000010  428c              CMP      r4,r1
000012  d201              BCS      |L19.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L19.26|
                  |L19.24|
000018  2100              MOVS     r1,#0
                  |L19.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;863    
;;;864    #ifdef STM32F10X_XL
;;;865      /* Wait for last operation to be completed */
;;;866      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;867      
;;;868      if(Address < FLASH_BANK1_END_ADDRESS)
;;;869      {
;;;870        if(status == FLASH_COMPLETE)
;;;871        {
;;;872          /* if the previous operation is completed, proceed to program the new data */
;;;873          FLASH->CR |= CR_PG_Set;
;;;874      
;;;875          *(__IO uint16_t*)Address = Data;
;;;876          /* Wait for last operation to be completed */
;;;877          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;878    
;;;879          /* Disable the PG Bit */
;;;880          FLASH->CR &= CR_PG_Reset;
;;;881        }
;;;882      }
;;;883      else
;;;884      {
;;;885        if(status == FLASH_COMPLETE)
;;;886        {
;;;887          /* if the previous operation is completed, proceed to program the new data */
;;;888          FLASH->CR2 |= CR_PG_Set;
;;;889      
;;;890          *(__IO uint16_t*)Address = Data;
;;;891          /* Wait for last operation to be completed */
;;;892          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;893    
;;;894          /* Disable the PG Bit */
;;;895          FLASH->CR2 &= CR_PG_Reset;
;;;896        }
;;;897      }
;;;898    #else
;;;899      /* Wait for last operation to be completed */
;;;900      status = FLASH_WaitForLastOperation(ProgramTimeout);
000020  f44f5000          MOV      r0,#0x2000
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4606              MOV      r6,r0
;;;901      
;;;902      if(status == FLASH_COMPLETE)
00002a  2e04              CMP      r6,#4
00002c  d111              BNE      |L19.82|
;;;903      {
;;;904        /* if the previous operation is completed, proceed to program the new data */
;;;905        FLASH->CR |= CR_PG_Set;
00002e  480b              LDR      r0,|L19.92|
000030  6900              LDR      r0,[r0,#0x10]
000032  f0400001          ORR      r0,r0,#1
000036  4909              LDR      r1,|L19.92|
000038  6108              STR      r0,[r1,#0x10]
;;;906      
;;;907        *(__IO uint16_t*)Address = Data;
00003a  8025              STRH     r5,[r4,#0]
;;;908        /* Wait for last operation to be completed */
;;;909        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  02f0              LSLS     r0,r6,#11
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4606              MOV      r6,r0
;;;910        
;;;911        /* Disable the PG Bit */
;;;912        FLASH->CR &= CR_PG_Reset;
000044  4805              LDR      r0,|L19.92|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171fe          MOV      r1,#0x1ffe
00004c  4008              ANDS     r0,r0,r1
00004e  4903              LDR      r1,|L19.92|
000050  6108              STR      r0,[r1,#0x10]
                  |L19.82|
;;;913      } 
;;;914    #endif  /* STM32F10X_XL */
;;;915      
;;;916      /* Return the Program Status */
;;;917      return status;
000052  4630              MOV      r0,r6
;;;918    }
000054  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      0x080fffff
                  |L19.92|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;928      */
;;;929    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;930    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;931      FLASH_Status status = FLASH_COMPLETE;
000006  2504              MOVS     r5,#4
;;;932      /* Check the parameters */
;;;933      assert_param(IS_OB_DATA_ADDRESS(Address));
000008  4916              LDR      r1,|L20.100|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L20.20|
00000e  1c89              ADDS     r1,r1,#2
000010  428c              CMP      r4,r1
000012  d101              BNE      |L20.24|
                  |L20.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L20.26|
                  |L20.24|
000018  2100              MOVS     r1,#0
                  |L20.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;934      status = FLASH_WaitForLastOperation(ProgramTimeout);
000020  f44f5000          MOV      r0,#0x2000
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;935    
;;;936      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d117              BNE      |L20.94|
;;;937      {
;;;938        /* Authorize the small information block programming */
;;;939        FLASH->OPTKEYR = FLASH_KEY1;
00002e  480e              LDR      r0,|L20.104|
000030  490e              LDR      r1,|L20.108|
000032  6088              STR      r0,[r1,#8]
;;;940        FLASH->OPTKEYR = FLASH_KEY2;
000034  480e              LDR      r0,|L20.112|
000036  6088              STR      r0,[r1,#8]
;;;941        /* Enables the Option Bytes Programming operation */
;;;942        FLASH->CR |= CR_OPTPG_Set; 
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;943        *(__IO uint16_t*)Address = Data;
000042  8026              STRH     r6,[r4,#0]
;;;944        
;;;945        /* Wait for last operation to be completed */
;;;946        status = FLASH_WaitForLastOperation(ProgramTimeout);
000044  02e8              LSLS     r0,r5,#11
000046  f7fffffe          BL       FLASH_WaitForLastOperation
00004a  4605              MOV      r5,r0
;;;947        if(status != FLASH_TIMEOUT)
00004c  2d05              CMP      r5,#5
00004e  d006              BEQ      |L20.94|
;;;948        {
;;;949          /* if the program operation is completed, disable the OPTPG Bit */
;;;950          FLASH->CR &= CR_OPTPG_Reset;
000050  4806              LDR      r0,|L20.108|
000052  6900              LDR      r0,[r0,#0x10]
000054  f64171ef          MOV      r1,#0x1fef
000058  4008              ANDS     r0,r0,r1
00005a  4904              LDR      r1,|L20.108|
00005c  6108              STR      r0,[r1,#0x10]
                  |L20.94|
;;;951        }
;;;952      }
;;;953      /* Return the Option Byte Data Program Status */
;;;954      return status;
00005e  4628              MOV      r0,r5
;;;955    }
000060  bd70              POP      {r4-r6,pc}
;;;956    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      0x1ffff804
                  |L20.104|
                          DCD      0x45670123
                  |L20.108|
                          DCD      0x40022000
                  |L20.112|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;680      */
;;;681    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;682    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;683      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;684      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;685    
;;;686      /* Check the parameters */
;;;687      assert_param(IS_FLASH_ADDRESS(Address));
00000c  f1b46f00          CMP      r4,#0x8000000
000010  d304              BCC      |L21.28|
000012  491b              LDR      r1,|L21.128|
000014  428c              CMP      r4,r1
000016  d201              BCS      |L21.28|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L21.30|
                  |L21.28|
00001c  2100              MOVS     r1,#0
                  |L21.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;688    
;;;689    #ifdef STM32F10X_XL
;;;690      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;691      { 
;;;692        /* Wait for last operation to be completed */
;;;693        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;694        if(status == FLASH_COMPLETE)
;;;695        {
;;;696          /* if the previous operation is completed, proceed to program the new first 
;;;697            half word */
;;;698          FLASH->CR |= CR_PG_Set;
;;;699      
;;;700          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;701          /* Wait for last operation to be completed */
;;;702          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;703     
;;;704          if(status == FLASH_COMPLETE)
;;;705          {
;;;706            /* if the previous operation is completed, proceed to program the new second 
;;;707            half word */
;;;708            tmp = Address + 2;
;;;709    
;;;710            *(__IO uint16_t*) tmp = Data >> 16;
;;;711        
;;;712            /* Wait for last operation to be completed */
;;;713            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;714            
;;;715            /* Disable the PG Bit */
;;;716            FLASH->CR &= CR_PG_Reset;
;;;717          }
;;;718          else
;;;719          {
;;;720            /* Disable the PG Bit */
;;;721            FLASH->CR &= CR_PG_Reset;
;;;722           }
;;;723        }
;;;724      }
;;;725      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;726      {
;;;727        /* Wait for last operation to be completed */
;;;728        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;729    
;;;730        if(status == FLASH_COMPLETE)
;;;731        {
;;;732          /* if the previous operation is completed, proceed to program the new first 
;;;733            half word */
;;;734          FLASH->CR |= CR_PG_Set;
;;;735      
;;;736          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;737    
;;;738          /* Wait for last operation to be completed */
;;;739          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;740          
;;;741    	  /* Disable the PG Bit */
;;;742          FLASH->CR &= CR_PG_Reset;
;;;743        }
;;;744        else
;;;745        {
;;;746          /* Disable the PG Bit */
;;;747          FLASH->CR &= CR_PG_Reset;
;;;748        }
;;;749    
;;;750        /* Wait for last operation to be completed */
;;;751        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;752    
;;;753        if(status == FLASH_COMPLETE)
;;;754        {
;;;755          /* if the previous operation is completed, proceed to program the new second 
;;;756          half word */
;;;757          FLASH->CR2 |= CR_PG_Set;
;;;758          tmp = Address + 2;
;;;759    
;;;760          *(__IO uint16_t*) tmp = Data >> 16;
;;;761        
;;;762          /* Wait for last operation to be completed */
;;;763          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;764            
;;;765          /* Disable the PG Bit */
;;;766          FLASH->CR2 &= CR_PG_Reset;
;;;767        }
;;;768        else
;;;769        {
;;;770          /* Disable the PG Bit */
;;;771          FLASH->CR2 &= CR_PG_Reset;
;;;772        }
;;;773      }
;;;774      else
;;;775      {
;;;776        /* Wait for last operation to be completed */
;;;777        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;778    
;;;779        if(status == FLASH_COMPLETE)
;;;780        {
;;;781          /* if the previous operation is completed, proceed to program the new first 
;;;782            half word */
;;;783          FLASH->CR2 |= CR_PG_Set;
;;;784      
;;;785          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;786          /* Wait for last operation to be completed */
;;;787          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;788     
;;;789          if(status == FLASH_COMPLETE)
;;;790          {
;;;791            /* if the previous operation is completed, proceed to program the new second 
;;;792            half word */
;;;793            tmp = Address + 2;
;;;794    
;;;795            *(__IO uint16_t*) tmp = Data >> 16;
;;;796        
;;;797            /* Wait for last operation to be completed */
;;;798            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;799            
;;;800            /* Disable the PG Bit */
;;;801            FLASH->CR2 &= CR_PG_Reset;
;;;802          }
;;;803          else
;;;804          {
;;;805            /* Disable the PG Bit */
;;;806            FLASH->CR2 &= CR_PG_Reset;
;;;807          }
;;;808        }
;;;809      }
;;;810    #else
;;;811      /* Wait for last operation to be completed */
;;;812      status = FLASH_WaitForLastOperation(ProgramTimeout);
000024  f44f5000          MOV      r0,#0x2000
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4606              MOV      r6,r0
;;;813      
;;;814      if(status == FLASH_COMPLETE)
00002e  2e04              CMP      r6,#4
000030  d124              BNE      |L21.124|
;;;815      {
;;;816        /* if the previous operation is completed, proceed to program the new first 
;;;817        half word */
;;;818        FLASH->CR |= CR_PG_Set;
000032  4814              LDR      r0,|L21.132|
000034  6900              LDR      r0,[r0,#0x10]
000036  f0400001          ORR      r0,r0,#1
00003a  4912              LDR      r1,|L21.132|
00003c  6108              STR      r0,[r1,#0x10]
;;;819      
;;;820        *(__IO uint16_t*)Address = (uint16_t)Data;
00003e  8025              STRH     r5,[r4,#0]
;;;821        /* Wait for last operation to be completed */
;;;822        status = FLASH_WaitForLastOperation(ProgramTimeout);
000040  02f0              LSLS     r0,r6,#11
000042  f7fffffe          BL       FLASH_WaitForLastOperation
000046  4606              MOV      r6,r0
;;;823     
;;;824        if(status == FLASH_COMPLETE)
000048  2e04              CMP      r6,#4
00004a  d110              BNE      |L21.110|
;;;825        {
;;;826          /* if the previous operation is completed, proceed to program the new second 
;;;827          half word */
;;;828          tmp = Address + 2;
00004c  1ca0              ADDS     r0,r4,#2
00004e  9000              STR      r0,[sp,#0]
;;;829    
;;;830          *(__IO uint16_t*) tmp = Data >> 16;
000050  0c28              LSRS     r0,r5,#16
000052  9900              LDR      r1,[sp,#0]
000054  8008              STRH     r0,[r1,#0]
;;;831        
;;;832          /* Wait for last operation to be completed */
;;;833          status = FLASH_WaitForLastOperation(ProgramTimeout);
000056  02f0              LSLS     r0,r6,#11
000058  f7fffffe          BL       FLASH_WaitForLastOperation
00005c  4606              MOV      r6,r0
;;;834            
;;;835          /* Disable the PG Bit */
;;;836          FLASH->CR &= CR_PG_Reset;
00005e  4809              LDR      r0,|L21.132|
000060  6900              LDR      r0,[r0,#0x10]
000062  f64171fe          MOV      r1,#0x1ffe
000066  4008              ANDS     r0,r0,r1
000068  4906              LDR      r1,|L21.132|
00006a  6108              STR      r0,[r1,#0x10]
00006c  e006              B        |L21.124|
                  |L21.110|
;;;837        }
;;;838        else
;;;839        {
;;;840          /* Disable the PG Bit */
;;;841          FLASH->CR &= CR_PG_Reset;
00006e  4805              LDR      r0,|L21.132|
000070  6900              LDR      r0,[r0,#0x10]
000072  f64171fe          MOV      r1,#0x1ffe
000076  4008              ANDS     r0,r0,r1
000078  4902              LDR      r1,|L21.132|
00007a  6108              STR      r0,[r1,#0x10]
                  |L21.124|
;;;842        }
;;;843      }         
;;;844    #endif /* STM32F10X_XL */
;;;845       
;;;846      /* Return the Program Status */
;;;847      return status;
00007c  4630              MOV      r0,r6
;;;848    }
00007e  bdf8              POP      {r3-r7,pc}
;;;849    
                          ENDP

                  |L21.128|
                          DCD      0x080fffff
                  |L21.132|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1048     */
;;;1049   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1050   {
000002  4605              MOV      r5,r0
;;;1051     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1052     /* Check the parameters */
;;;1053     assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  b10d              CBZ      r5,|L22.12|
000008  2d01              CMP      r5,#1
00000a  d101              BNE      |L22.16|
                  |L22.12|
00000c  2101              MOVS     r1,#1
00000e  e000              B        |L22.18|
                  |L22.16|
000010  2100              MOVS     r1,#0
                  |L22.18|
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       assert_param
;;;1054     status = FLASH_WaitForLastOperation(EraseTimeout);
000018  f44f2030          MOV      r0,#0xb0000
00001c  f7fffffe          BL       FLASH_WaitForLastOperation
000020  4604              MOV      r4,r0
;;;1055     if(status == FLASH_COMPLETE)
000022  2c04              CMP      r4,#4
000024  d141              BNE      |L22.170|
;;;1056     {
;;;1057       /* Authorizes the small information block programming */
;;;1058       FLASH->OPTKEYR = FLASH_KEY1;
000026  4822              LDR      r0,|L22.176|
000028  4922              LDR      r1,|L22.180|
00002a  6088              STR      r0,[r1,#8]
;;;1059       FLASH->OPTKEYR = FLASH_KEY2;
00002c  4822              LDR      r0,|L22.184|
00002e  6088              STR      r0,[r1,#8]
;;;1060       FLASH->CR |= CR_OPTER_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400020          ORR      r0,r0,#0x20
000038  6108              STR      r0,[r1,#0x10]
;;;1061       FLASH->CR |= CR_STRT_Set;
00003a  4608              MOV      r0,r1
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f0400040          ORR      r0,r0,#0x40
000042  6108              STR      r0,[r1,#0x10]
;;;1062       /* Wait for last operation to be completed */
;;;1063       status = FLASH_WaitForLastOperation(EraseTimeout);
000044  f44f2030          MOV      r0,#0xb0000
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4604              MOV      r4,r0
;;;1064       if(status == FLASH_COMPLETE)
00004e  2c04              CMP      r4,#4
000050  d122              BNE      |L22.152|
;;;1065       {
;;;1066         /* if the erase operation is completed, disable the OPTER Bit */
;;;1067         FLASH->CR &= CR_OPTER_Reset;
000052  4818              LDR      r0,|L22.180|
000054  6900              LDR      r0,[r0,#0x10]
000056  f64171df          MOV      r1,#0x1fdf
00005a  4008              ANDS     r0,r0,r1
00005c  4915              LDR      r1,|L22.180|
00005e  6108              STR      r0,[r1,#0x10]
;;;1068         /* Enable the Option Bytes Programming operation */
;;;1069         FLASH->CR |= CR_OPTPG_Set; 
000060  4608              MOV      r0,r1
000062  6900              LDR      r0,[r0,#0x10]
000064  f0400010          ORR      r0,r0,#0x10
000068  6108              STR      r0,[r1,#0x10]
;;;1070         if(NewState != DISABLE)
00006a  b11d              CBZ      r5,|L22.116|
;;;1071         {
;;;1072           OB->RDP = 0x00;
00006c  2000              MOVS     r0,#0
00006e  4913              LDR      r1,|L22.188|
000070  8008              STRH     r0,[r1,#0]
000072  e002              B        |L22.122|
                  |L22.116|
;;;1073         }
;;;1074         else
;;;1075         {
;;;1076           OB->RDP = RDP_Key;  
000074  20a5              MOVS     r0,#0xa5
000076  4911              LDR      r1,|L22.188|
000078  8008              STRH     r0,[r1,#0]
                  |L22.122|
;;;1077         }
;;;1078         /* Wait for last operation to be completed */
;;;1079         status = FLASH_WaitForLastOperation(EraseTimeout); 
00007a  f44f2030          MOV      r0,#0xb0000
00007e  f7fffffe          BL       FLASH_WaitForLastOperation
000082  4604              MOV      r4,r0
;;;1080       
;;;1081         if(status != FLASH_TIMEOUT)
000084  2c05              CMP      r4,#5
000086  d010              BEQ      |L22.170|
;;;1082         {
;;;1083           /* if the program operation is completed, disable the OPTPG Bit */
;;;1084           FLASH->CR &= CR_OPTPG_Reset;
000088  480a              LDR      r0,|L22.180|
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f64171ef          MOV      r1,#0x1fef
000090  4008              ANDS     r0,r0,r1
000092  4908              LDR      r1,|L22.180|
000094  6108              STR      r0,[r1,#0x10]
000096  e008              B        |L22.170|
                  |L22.152|
;;;1085         }
;;;1086       }
;;;1087       else 
;;;1088       {
;;;1089         if(status != FLASH_TIMEOUT)
000098  2c05              CMP      r4,#5
00009a  d006              BEQ      |L22.170|
;;;1090         {
;;;1091           /* Disable the OPTER Bit */
;;;1092           FLASH->CR &= CR_OPTER_Reset;
00009c  4805              LDR      r0,|L22.180|
00009e  6900              LDR      r0,[r0,#0x10]
0000a0  f64171df          MOV      r1,#0x1fdf
0000a4  4008              ANDS     r0,r0,r1
0000a6  4903              LDR      r1,|L22.180|
0000a8  6108              STR      r0,[r1,#0x10]
                  |L22.170|
;;;1093         }
;;;1094       }
;;;1095     }
;;;1096     /* Return the protection operation Status */
;;;1097     return status;       
0000aa  4620              MOV      r0,r4
;;;1098   }
0000ac  bd70              POP      {r4-r6,pc}
;;;1099   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L22.176|
                          DCD      0x45670123
                  |L22.180|
                          DCD      0x40022000
                  |L22.184|
                          DCD      0xcdef89ab
                  |L22.188|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;253      */
;;;254    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  b570              PUSH     {r4-r6,lr}
;;;255    {
000002  4604              MOV      r4,r0
;;;256      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;257      
;;;258      /* Check the parameters */
;;;259      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
000006  b11c              CBZ      r4,|L23.16|
000008  2c01              CMP      r4,#1
00000a  d001              BEQ      |L23.16|
00000c  2c02              CMP      r4,#2
00000e  d101              BNE      |L23.20|
                  |L23.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L23.22|
                  |L23.20|
000014  2100              MOVS     r1,#0
                  |L23.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;260      
;;;261      /* Read the ACR register */
;;;262      tmpreg = FLASH->ACR;  
00001c  4803              LDR      r0,|L23.44|
00001e  6805              LDR      r5,[r0,#0]
;;;263      
;;;264      /* Sets the Latency value */
;;;265      tmpreg &= ACR_LATENCY_Mask;
000020  f0050538          AND      r5,r5,#0x38
;;;266      tmpreg |= FLASH_Latency;
000024  4325              ORRS     r5,r5,r4
;;;267      
;;;268      /* Write the ACR register */
;;;269      FLASH->ACR = tmpreg;
000026  6005              STR      r5,[r0,#0]
;;;270    }
000028  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

00002a  0000              DCW      0x0000
                  |L23.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;318      */
;;;319    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;320    {
;;;321      /* Authorize the FPEC of Bank1 Access */
;;;322      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;323      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;324    
;;;325    #ifdef STM32F10X_XL
;;;326      /* Authorize the FPEC of Bank2 Access */
;;;327      FLASH->KEYR2 = FLASH_KEY1;
;;;328      FLASH->KEYR2 = FLASH_KEY2;
;;;329    #endif /* STM32F10X_XL */
;;;330    }
00000a  4770              BX       lr
;;;331    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;339      */
;;;340    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;341    {
;;;342      /* Authorize the FPEC of Bank1 Access */
;;;343      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;344      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;345    }
00000a  4770              BX       lr
;;;346    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1117     */
;;;1118   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1119   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1120     FLASH_Status status = FLASH_COMPLETE; 
00000a  2704              MOVS     r7,#4
;;;1121   
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
00000c  2c01              CMP      r4,#1
00000e  d000              BEQ      |L26.18|
000010  b90c              CBNZ     r4,|L26.22|
                  |L26.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L26.24|
                  |L26.22|
000016  2100              MOVS     r1,#0
                  |L26.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;1124     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
00001e  2d02              CMP      r5,#2
000020  d000              BEQ      |L26.36|
000022  b90d              CBNZ     r5,|L26.40|
                  |L26.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L26.42|
                  |L26.40|
000028  2100              MOVS     r1,#0
                  |L26.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;1125     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
000030  2e04              CMP      r6,#4
000032  d000              BEQ      |L26.54|
000034  b90e              CBNZ     r6,|L26.58|
                  |L26.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L26.60|
                  |L26.58|
00003a  2100              MOVS     r1,#0
                  |L26.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;1126   
;;;1127     /* Authorize the small information block programming */
;;;1128     FLASH->OPTKEYR = FLASH_KEY1;
000042  4814              LDR      r0,|L26.148|
000044  4914              LDR      r1,|L26.152|
000046  6088              STR      r0,[r1,#8]
;;;1129     FLASH->OPTKEYR = FLASH_KEY2;
000048  4814              LDR      r0,|L26.156|
00004a  6088              STR      r0,[r1,#8]
;;;1130     
;;;1131     /* Wait for last operation to be completed */
;;;1132     status = FLASH_WaitForLastOperation(ProgramTimeout);
00004c  f44f5000          MOV      r0,#0x2000
000050  f7fffffe          BL       FLASH_WaitForLastOperation
000054  4607              MOV      r7,r0
;;;1133     
;;;1134     if(status == FLASH_COMPLETE)
000056  2f04              CMP      r7,#4
000058  d118              BNE      |L26.140|
;;;1135     {  
;;;1136       /* Enable the Option Bytes Programming operation */
;;;1137       FLASH->CR |= CR_OPTPG_Set; 
00005a  480f              LDR      r0,|L26.152|
00005c  6900              LDR      r0,[r0,#0x10]
00005e  f0400010          ORR      r0,r0,#0x10
000062  490d              LDR      r1,|L26.152|
000064  6108              STR      r0,[r1,#0x10]
;;;1138              
;;;1139       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
000066  f04600f8          ORR      r0,r6,#0xf8
00006a  4328              ORRS     r0,r0,r5
00006c  4320              ORRS     r0,r0,r4
00006e  490c              LDR      r1,|L26.160|
000070  8008              STRH     r0,[r1,#0]
;;;1140     
;;;1141       /* Wait for last operation to be completed */
;;;1142       status = FLASH_WaitForLastOperation(ProgramTimeout);
000072  02f8              LSLS     r0,r7,#11
000074  f7fffffe          BL       FLASH_WaitForLastOperation
000078  4607              MOV      r7,r0
;;;1143       if(status != FLASH_TIMEOUT)
00007a  2f05              CMP      r7,#5
00007c  d006              BEQ      |L26.140|
;;;1144       {
;;;1145         /* if the program operation is completed, disable the OPTPG Bit */
;;;1146         FLASH->CR &= CR_OPTPG_Reset;
00007e  4806              LDR      r0,|L26.152|
000080  6900              LDR      r0,[r0,#0x10]
000082  f64171ef          MOV      r1,#0x1fef
000086  4008              ANDS     r0,r0,r1
000088  4903              LDR      r1,|L26.152|
00008a  6108              STR      r0,[r1,#0x10]
                  |L26.140|
;;;1147       }
;;;1148     }    
;;;1149     /* Return the Option Byte program Status */
;;;1150     return status;
00008c  4638              MOV      r0,r7
;;;1151   }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;1152   
                          ENDP

000092  0000              DCW      0x0000
                  |L26.148|
                          DCD      0x45670123
                  |L26.152|
                          DCD      0x40022000
                  |L26.156|
                          DCD      0xcdef89ab
                  |L26.160|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1622     */
;;;1623   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1624   { 
000002  4602              MOV      r2,r0
;;;1625     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1626      
;;;1627     /* Check for the Flash Status */
;;;1628     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1629     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1630     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1631     {
;;;1632       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1633       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1630
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1630
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1634     }
;;;1635     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1636     {
;;;1637       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1638     }
;;;1639     /* Return the operation status */
;;;1640     return status;
000022  4618              MOV      r0,r3
;;;1641   }
000024  bd00              POP      {pc}
;;;1642   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1594     */
;;;1595   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1596   { 
000002  4602              MOV      r2,r0
;;;1597     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1598      
;;;1599     /* Check for the Flash Status */
;;;1600     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1601     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1602     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1603     {
;;;1604       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1605       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1602
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1602
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1606     }
;;;1607     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1608     {
;;;1609       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1610     }
;;;1611     /* Return the operation status */
;;;1612     return status;
000022  4618              MOV      r0,r3
;;;1613   }
000024  bd00              POP      {pc}
;;;1614   
                          ENDP

