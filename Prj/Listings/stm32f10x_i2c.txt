; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_i2c.crf ..\Chip\Hal_lib\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=2

                  I2C_ARPCmd PROC
;;;839      */
;;;840    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;841    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;842      /* Check the parameters */
;;;843      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L1.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L1.18|
00000c  490f              LDR      r1,|L1.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L1.22|
                  |L1.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L1.24|
                  |L1.22|
000016  2100              MOVS     r1,#0
                  |L1.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;844      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L1.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L1.40|
                  |L1.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L1.42|
                  |L1.40|
000028  2100              MOVS     r1,#0
                  |L1.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;845      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L1.60|
;;;846      {
;;;847        /* Enable the selected I2C ARP */
;;;848        I2Cx->CR1 |= CR1_ENARP_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400010          ORR      r0,r0,#0x10
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L1.70|
                  |L1.60|
;;;849      }
;;;850      else
;;;851      {
;;;852        /* Disable the selected I2C ARP */
;;;853        I2Cx->CR1 &= CR1_ENARP_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f71ef          MOV      r1,#0xffef
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L1.70|
;;;854      }
;;;855    }
000046  bd70              POP      {r4-r6,pc}
;;;856    
                          ENDP

                  |L1.72|
                          DCD      0x40005400
                  |L1.76|
                          DCD      0x40005800

                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=2

                  I2C_AcknowledgeConfig PROC
;;;441      */
;;;442    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;444      /* Check the parameters */
;;;445      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L2.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L2.18|
00000c  490f              LDR      r1,|L2.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L2.22|
                  |L2.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L2.24|
                  |L2.22|
000016  2100              MOVS     r1,#0
                  |L2.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;446      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L2.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L2.40|
                  |L2.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L2.42|
                  |L2.40|
000028  2100              MOVS     r1,#0
                  |L2.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;447      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L2.60|
;;;448      {
;;;449        /* Enable the acknowledgement */
;;;450        I2Cx->CR1 |= CR1_ACK_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f4406080          ORR      r0,r0,#0x400
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L2.70|
                  |L2.60|
;;;451      }
;;;452      else
;;;453      {
;;;454        /* Disable the acknowledgement */
;;;455        I2Cx->CR1 &= CR1_ACK_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f31ff          MOV      r1,#0xfbff
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L2.70|
;;;456      }
;;;457    }
000046  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

                  |L2.72|
                          DCD      0x40005400
                  |L2.76|
                          DCD      0x40005800

                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=2

                  I2C_CalculatePEC PROC
;;;802      */
;;;803    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;804    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;805      /* Check the parameters */
;;;806      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L3.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L3.18|
00000c  490f              LDR      r1,|L3.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L3.22|
                  |L3.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L3.24|
                  |L3.22|
000016  2100              MOVS     r1,#0
                  |L3.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;807      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L3.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L3.40|
                  |L3.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L3.42|
                  |L3.40|
000028  2100              MOVS     r1,#0
                  |L3.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;808      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L3.60|
;;;809      {
;;;810        /* Enable the selected I2C PEC calculation */
;;;811        I2Cx->CR1 |= CR1_ENPEC_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400020          ORR      r0,r0,#0x20
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L3.70|
                  |L3.60|
;;;812      }
;;;813      else
;;;814      {
;;;815        /* Disable the selected I2C PEC calculation */
;;;816        I2Cx->CR1 &= CR1_ENPEC_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f71df          MOV      r1,#0xffdf
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L3.70|
;;;817      }
;;;818    }
000046  bd70              POP      {r4-r6,pc}
;;;819    
                          ENDP

                  |L3.72|
                          DCD      0x40005400
                  |L3.76|
                          DCD      0x40005800

                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=2

                  I2C_CheckEvent PROC
;;;1029     */
;;;1030   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1031   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1032     uint32_t lastevent = 0;
000008  2700              MOVS     r7,#0
;;;1033     uint32_t flag1 = 0, flag2 = 0;
00000a  46b8              MOV      r8,r7
00000c  2600              MOVS     r6,#0
;;;1034     ErrorStatus status = ERROR;
00000e  46b1              MOV      r9,r6
;;;1035   
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000010  4933              LDR      r1,|L4.224|
000012  428d              CMP      r5,r1
000014  d002              BEQ      |L4.28|
000016  4933              LDR      r1,|L4.228|
000018  428d              CMP      r5,r1
00001a  d101              BNE      |L4.32|
                  |L4.28|
00001c  2101              MOVS     r1,#1
00001e  e000              B        |L4.34|
                  |L4.32|
000020  2100              MOVS     r1,#0
                  |L4.34|
000022  4608              MOV      r0,r1
000024  f7fffffe          BL       assert_param
;;;1038     assert_param(IS_I2C_EVENT(I2C_EVENT));
000028  492f              LDR      r1,|L4.232|
00002a  428c              CMP      r4,r1
00002c  d03d              BEQ      |L4.170|
00002e  f1b41f02          CMP      r4,#0x20002
000032  d03a              BEQ      |L4.170|
000034  492d              LDR      r1,|L4.236|
000036  428c              CMP      r4,r1
000038  d037              BEQ      |L4.170|
00003a  f5b40f02          CMP      r4,#0x820000
00003e  d034              BEQ      |L4.170|
000040  f5b41f90          CMP      r4,#0x120000
000044  d031              BEQ      |L4.170|
000046  492a              LDR      r1,|L4.240|
000048  428c              CMP      r4,r1
00004a  d02e              BEQ      |L4.170|
00004c  4929              LDR      r1,|L4.244|
00004e  428c              CMP      r4,r1
000050  d02b              BEQ      |L4.170|
000052  4929              LDR      r1,|L4.248|
000054  428c              CMP      r4,r1
000056  d028              BEQ      |L4.170|
000058  4923              LDR      r1,|L4.232|
00005a  1c89              ADDS     r1,r1,#2
00005c  428c              CMP      r4,r1
00005e  d024              BEQ      |L4.170|
000060  4922              LDR      r1,|L4.236|
000062  1d09              ADDS     r1,r1,#4
000064  428c              CMP      r4,r1
000066  d020              BEQ      |L4.170|
000068  4924              LDR      r1,|L4.252|
00006a  428c              CMP      r4,r1
00006c  d01d              BEQ      |L4.170|
00006e  2c10              CMP      r4,#0x10
000070  d01b              BEQ      |L4.170|
000072  4923              LDR      r1,|L4.256|
000074  428c              CMP      r4,r1
000076  d018              BEQ      |L4.170|
000078  4922              LDR      r1,|L4.260|
00007a  428c              CMP      r4,r1
00007c  d015              BEQ      |L4.170|
00007e  4920              LDR      r1,|L4.256|
000080  1c49              ADDS     r1,r1,#1
000082  428c              CMP      r4,r1
000084  d011              BEQ      |L4.170|
000086  491e              LDR      r1,|L4.256|
000088  313f              ADDS     r1,r1,#0x3f
00008a  428c              CMP      r4,r1
00008c  d00d              BEQ      |L4.170|
00008e  491d              LDR      r1,|L4.260|
000090  1c89              ADDS     r1,r1,#2
000092  428c              CMP      r4,r1
000094  d009              BEQ      |L4.170|
000096  1f09              SUBS     r1,r1,#4
000098  428c              CMP      r4,r1
00009a  d006              BEQ      |L4.170|
00009c  4918              LDR      r1,|L4.256|
00009e  1dc9              ADDS     r1,r1,#7
0000a0  428c              CMP      r4,r1
0000a2  d002              BEQ      |L4.170|
0000a4  f5b46f80          CMP      r4,#0x400
0000a8  d101              BNE      |L4.174|
                  |L4.170|
0000aa  2101              MOVS     r1,#1
0000ac  e000              B        |L4.176|
                  |L4.174|
0000ae  2100              MOVS     r1,#0
                  |L4.176|
0000b0  4608              MOV      r0,r1
0000b2  f7fffffe          BL       assert_param
;;;1039   
;;;1040     /* Read the I2Cx status register */
;;;1041     flag1 = I2Cx->SR1;
0000b6  f8b58014          LDRH     r8,[r5,#0x14]
;;;1042     flag2 = I2Cx->SR2;
0000ba  8b2e              LDRH     r6,[r5,#0x18]
;;;1043     flag2 = flag2 << 16;
0000bc  0436              LSLS     r6,r6,#16
;;;1044   
;;;1045     /* Get the last event value from I2C status register */
;;;1046     lastevent = (flag1 | flag2) & FLAG_Mask;
0000be  ea480006          ORR      r0,r8,r6
0000c2  f020477f          BIC      r7,r0,#0xff000000
;;;1047   
;;;1048     /* Check whether the last event contains the I2C_EVENT */
;;;1049     if ((lastevent & I2C_EVENT) == I2C_EVENT)
0000c6  ea070004          AND      r0,r7,r4
0000ca  42a0              CMP      r0,r4
0000cc  d102              BNE      |L4.212|
;;;1050     {
;;;1051       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1052       status = SUCCESS;
0000ce  f04f0901          MOV      r9,#1
0000d2  e001              B        |L4.216|
                  |L4.212|
;;;1053     }
;;;1054     else
;;;1055     {
;;;1056       /* ERROR: last event is different from I2C_EVENT */
;;;1057       status = ERROR;
0000d4  f04f0900          MOV      r9,#0
                  |L4.216|
;;;1058     }
;;;1059     /* Return status */
;;;1060     return status;
0000d8  4648              MOV      r0,r9
;;;1061   }
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;1062   
                          ENDP

0000de  0000              DCW      0x0000
                  |L4.224|
                          DCD      0x40005400
                  |L4.228|
                          DCD      0x40005800
                  |L4.232|
                          DCD      0x00060082
                  |L4.236|
                          DCD      0x00860080
                  |L4.240|
                          DCD      0x00020040
                  |L4.244|
                          DCD      0x00820040
                  |L4.248|
                          DCD      0x00120040
                  |L4.252|
                          DCD      0x00160084
                  |L4.256|
                          DCD      0x00030001
                  |L4.260|
                          DCD      0x00070082

                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=2

                  I2C_ClearFlag PROC
;;;1211     */
;;;1212   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1213   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1214     uint32_t flagpos = 0;
000006  2600              MOVS     r6,#0
;;;1215     /* Check the parameters */
;;;1216     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000008  490d              LDR      r1,|L5.64|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L5.20|
00000e  490d              LDR      r1,|L5.68|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L5.24|
                  |L5.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L5.26|
                  |L5.24|
000018  2100              MOVS     r1,#0
                  |L5.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1217     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
000020  f24201ff          MOV      r1,#0x20ff
000024  4029              ANDS     r1,r1,r5
000026  b911              CBNZ     r1,|L5.46|
000028  b10d              CBZ      r5,|L5.46|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L5.48|
                  |L5.46|
00002e  2100              MOVS     r1,#0
                  |L5.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;1218     /* Get the I2C flag position */
;;;1219     flagpos = I2C_FLAG & FLAG_Mask;
000036  f025467f          BIC      r6,r5,#0xff000000
;;;1220     /* Clear the selected I2C flag */
;;;1221     I2Cx->SR1 = (uint16_t)~flagpos;
00003a  43f0              MVNS     r0,r6
00003c  82a0              STRH     r0,[r4,#0x14]
;;;1222   }
00003e  bd70              POP      {r4-r6,pc}
;;;1223   
                          ENDP

                  |L5.64|
                          DCD      0x40005400
                  |L5.68|
                          DCD      0x40005800

                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  I2C_ClearITPendingBit PROC
;;;1306     */
;;;1307   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1308   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1309     uint32_t flagpos = 0;
000006  2600              MOVS     r6,#0
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000008  490d              LDR      r1,|L6.64|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L6.20|
00000e  490d              LDR      r1,|L6.68|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L6.24|
                  |L6.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L6.26|
                  |L6.24|
000018  2100              MOVS     r1,#0
                  |L6.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;1312     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
000020  f24201ff          MOV      r1,#0x20ff
000024  4029              ANDS     r1,r1,r5
000026  b911              CBNZ     r1,|L6.46|
000028  b10d              CBZ      r5,|L6.46|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L6.48|
                  |L6.46|
00002e  2100              MOVS     r1,#0
                  |L6.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;1313     /* Get the I2C flag position */
;;;1314     flagpos = I2C_IT & FLAG_Mask;
000036  f025467f          BIC      r6,r5,#0xff000000
;;;1315     /* Clear the selected I2C flag */
;;;1316     I2Cx->SR1 = (uint16_t)~flagpos;
00003a  43f0              MVNS     r0,r6
00003c  82a0              STRH     r0,[r4,#0x14]
;;;1317   }
00003e  bd70              POP      {r4-r6,pc}
;;;1318   
                          ENDP

                  |L6.64|
                          DCD      0x40005400
                  |L6.68|
                          DCD      0x40005800

                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=2

                  I2C_Cmd PROC
;;;321      */
;;;322    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;323    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;324      /* Check the parameters */
;;;325      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L7.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L7.18|
00000c  490f              LDR      r1,|L7.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L7.22|
                  |L7.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L7.24|
                  |L7.22|
000016  2100              MOVS     r1,#0
                  |L7.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;326      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L7.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L7.40|
                  |L7.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L7.42|
                  |L7.40|
000028  2100              MOVS     r1,#0
                  |L7.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;327      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L7.60|
;;;328      {
;;;329        /* Enable the selected I2C peripheral */
;;;330        I2Cx->CR1 |= CR1_PE_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400001          ORR      r0,r0,#1
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L7.70|
                  |L7.60|
;;;331      }
;;;332      else
;;;333      {
;;;334        /* Disable the selected I2C peripheral */
;;;335        I2Cx->CR1 &= CR1_PE_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f71fe          MOV      r1,#0xfffe
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L7.70|
;;;336      }
;;;337    }
000046  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP

                  |L7.72|
                          DCD      0x40005400
                  |L7.76|
                          DCD      0x40005800

                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=2

                  I2C_DMACmd PROC
;;;345      */
;;;346    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;347    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;348      /* Check the parameters */
;;;349      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L8.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L8.18|
00000c  490f              LDR      r1,|L8.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L8.22|
                  |L8.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L8.24|
                  |L8.22|
000016  2100              MOVS     r1,#0
                  |L8.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;350      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L8.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L8.40|
                  |L8.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L8.42|
                  |L8.40|
000028  2100              MOVS     r1,#0
                  |L8.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;351      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L8.60|
;;;352      {
;;;353        /* Enable the selected I2C DMA requests */
;;;354        I2Cx->CR2 |= CR2_DMAEN_Set;
000032  88a0              LDRH     r0,[r4,#4]
000034  f4406000          ORR      r0,r0,#0x800
000038  80a0              STRH     r0,[r4,#4]
00003a  e004              B        |L8.70|
                  |L8.60|
;;;355      }
;;;356      else
;;;357      {
;;;358        /* Disable the selected I2C DMA requests */
;;;359        I2Cx->CR2 &= CR2_DMAEN_Reset;
00003c  88a0              LDRH     r0,[r4,#4]
00003e  f24f71ff          MOV      r1,#0xf7ff
000042  4008              ANDS     r0,r0,r1
000044  80a0              STRH     r0,[r4,#4]
                  |L8.70|
;;;360      }
;;;361    }
000046  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP

                  |L8.72|
                          DCD      0x40005400
                  |L8.76|
                          DCD      0x40005800

                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=2

                  I2C_DMALastTransferCmd PROC
;;;369      */
;;;370    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;371    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;372      /* Check the parameters */
;;;373      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L9.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L9.18|
00000c  490f              LDR      r1,|L9.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L9.22|
                  |L9.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L9.24|
                  |L9.22|
000016  2100              MOVS     r1,#0
                  |L9.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;374      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L9.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L9.40|
                  |L9.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L9.42|
                  |L9.40|
000028  2100              MOVS     r1,#0
                  |L9.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;375      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L9.60|
;;;376      {
;;;377        /* Next DMA transfer is the last transfer */
;;;378        I2Cx->CR2 |= CR2_LAST_Set;
000032  88a0              LDRH     r0,[r4,#4]
000034  f4405080          ORR      r0,r0,#0x1000
000038  80a0              STRH     r0,[r4,#4]
00003a  e004              B        |L9.70|
                  |L9.60|
;;;379      }
;;;380      else
;;;381      {
;;;382        /* Next DMA transfer is not the last transfer */
;;;383        I2Cx->CR2 &= CR2_LAST_Reset;
00003c  88a0              LDRH     r0,[r4,#4]
00003e  f64e71ff          MOV      r1,#0xefff
000042  4008              ANDS     r0,r0,r1
000044  80a0              STRH     r0,[r4,#4]
                  |L9.70|
;;;384      }
;;;385    }
000046  bd70              POP      {r4-r6,pc}
;;;386    
                          ENDP

                  |L9.72|
                          DCD      0x40005400
                  |L9.76|
                          DCD      0x40005800

                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;161      */
;;;162    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164      /* Check the parameters */
;;;165      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4911              LDR      r1,|L10.76|
000006  428c              CMP      r4,r1
000008  d002              BEQ      |L10.16|
00000a  4911              LDR      r1,|L10.80|
00000c  428c              CMP      r4,r1
00000e  d101              BNE      |L10.20|
                  |L10.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L10.22|
                  |L10.20|
000014  2100              MOVS     r1,#0
                  |L10.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;166    
;;;167      if (I2Cx == I2C1)
00001c  480b              LDR      r0,|L10.76|
00001e  4284              CMP      r4,r0
000020  d109              BNE      |L10.54|
;;;168      {
;;;169        /* Enable I2C1 reset state */
;;;170        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000022  2101              MOVS     r1,#1
000024  0548              LSLS     r0,r1,#21
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171        /* Release I2C1 from reset state */
;;;172        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  f44f1000          MOV      r0,#0x200000
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  e008              B        |L10.72|
                  |L10.54|
;;;173      }
;;;174      else
;;;175      {
;;;176        /* Enable I2C2 reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000036  2101              MOVS     r1,#1
000038  0588              LSLS     r0,r1,#22
00003a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;178        /* Release I2C2 from reset state */
;;;179        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00003e  2100              MOVS     r1,#0
000040  f44f0080          MOV      r0,#0x400000
000044  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L10.72|
;;;180      }
;;;181    }
000048  bd10              POP      {r4,pc}
;;;182    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      0x40005400
                  |L10.80|
                          DCD      0x40005800

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=2

                  I2C_DualAddressCmd PROC
;;;491      */
;;;492    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;493    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;494      /* Check the parameters */
;;;495      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L11.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L11.18|
00000c  490f              LDR      r1,|L11.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L11.22|
                  |L11.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L11.24|
                  |L11.22|
000016  2100              MOVS     r1,#0
                  |L11.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L11.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L11.40|
                  |L11.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L11.42|
                  |L11.40|
000028  2100              MOVS     r1,#0
                  |L11.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;497      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L11.60|
;;;498      {
;;;499        /* Enable dual addressing mode */
;;;500        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000032  89a0              LDRH     r0,[r4,#0xc]
000034  f0400001          ORR      r0,r0,#1
000038  81a0              STRH     r0,[r4,#0xc]
00003a  e004              B        |L11.70|
                  |L11.60|
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Disable dual addressing mode */
;;;505        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00003c  89a0              LDRH     r0,[r4,#0xc]
00003e  f64f71fe          MOV      r1,#0xfffe
000042  4008              ANDS     r0,r0,r1
000044  81a0              STRH     r0,[r4,#0xc]
                  |L11.70|
;;;506      }
;;;507    }
000046  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  |L11.72|
                          DCD      0x40005400
                  |L11.76|
                          DCD      0x40005800

                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=2

                  I2C_FastModeDutyCycleConfig PROC
;;;889      */
;;;890    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  b570              PUSH     {r4-r6,lr}
;;;891    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;892      /* Check the parameters */
;;;893      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4913              LDR      r1,|L12.84|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L12.18|
00000c  4912              LDR      r1,|L12.88|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L12.22|
                  |L12.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L12.24|
                  |L12.22|
000016  2100              MOVS     r1,#0
                  |L12.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;894      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
00001e  f5b54f80          CMP      r5,#0x4000
000022  d003              BEQ      |L12.44|
000024  f64b71ff          MOV      r1,#0xbfff
000028  428d              CMP      r5,r1
00002a  d101              BNE      |L12.48|
                  |L12.44|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L12.50|
                  |L12.48|
000030  2100              MOVS     r1,#0
                  |L12.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;895      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000038  f5b54f80          CMP      r5,#0x4000
00003c  d005              BEQ      |L12.74|
;;;896      {
;;;897        /* I2C fast mode Tlow/Thigh=2 */
;;;898        I2Cx->CCR &= I2C_DutyCycle_2;
00003e  8ba0              LDRH     r0,[r4,#0x1c]
000040  f64b71ff          MOV      r1,#0xbfff
000044  4008              ANDS     r0,r0,r1
000046  83a0              STRH     r0,[r4,#0x1c]
000048  e003              B        |L12.82|
                  |L12.74|
;;;899      }
;;;900      else
;;;901      {
;;;902        /* I2C fast mode Tlow/Thigh=16/9 */
;;;903        I2Cx->CCR |= I2C_DutyCycle_16_9;
00004a  8ba0              LDRH     r0,[r4,#0x1c]
00004c  f4404080          ORR      r0,r0,#0x4000
000050  83a0              STRH     r0,[r4,#0x1c]
                  |L12.82|
;;;904      }
;;;905    }
000052  bd70              POP      {r4-r6,pc}
;;;906    
                          ENDP

                  |L12.84|
                          DCD      0x40005400
                  |L12.88|
                          DCD      0x40005800

                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=2

                  I2C_GeneralCallCmd PROC
;;;515      */
;;;516    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;518      /* Check the parameters */
;;;519      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L13.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L13.18|
00000c  490f              LDR      r1,|L13.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L13.22|
                  |L13.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L13.24|
                  |L13.22|
000016  2100              MOVS     r1,#0
                  |L13.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L13.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L13.40|
                  |L13.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L13.42|
                  |L13.40|
000028  2100              MOVS     r1,#0
                  |L13.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;521      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L13.60|
;;;522      {
;;;523        /* Enable generall call */
;;;524        I2Cx->CR1 |= CR1_ENGC_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400040          ORR      r0,r0,#0x40
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L13.70|
                  |L13.60|
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Disable generall call */
;;;529        I2Cx->CR1 &= CR1_ENGC_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f71bf          MOV      r1,#0xffbf
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L13.70|
;;;530      }
;;;531    }
000046  bd70              POP      {r4-r6,pc}
;;;532    
                          ENDP

                  |L13.72|
                          DCD      0x40005400
                  |L13.76|
                          DCD      0x40005800

                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=2

                  I2C_GenerateSTART PROC
;;;393      */
;;;394    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;395    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;396      /* Check the parameters */
;;;397      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L14.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L14.18|
00000c  490f              LDR      r1,|L14.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L14.22|
                  |L14.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L14.24|
                  |L14.22|
000016  2100              MOVS     r1,#0
                  |L14.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;398      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L14.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L14.40|
                  |L14.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L14.42|
                  |L14.40|
000028  2100              MOVS     r1,#0
                  |L14.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;399      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L14.60|
;;;400      {
;;;401        /* Generate a START condition */
;;;402        I2Cx->CR1 |= CR1_START_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f4407080          ORR      r0,r0,#0x100
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L14.70|
                  |L14.60|
;;;403      }
;;;404      else
;;;405      {
;;;406        /* Disable the START condition generation */
;;;407        I2Cx->CR1 &= CR1_START_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f61ff          MOV      r1,#0xfeff
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L14.70|
;;;408      }
;;;409    }
000046  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  |L14.72|
                          DCD      0x40005400
                  |L14.76|
                          DCD      0x40005800

                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=2

                  I2C_GenerateSTOP PROC
;;;417      */
;;;418    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;419    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;420      /* Check the parameters */
;;;421      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L15.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L15.18|
00000c  490f              LDR      r1,|L15.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L15.22|
                  |L15.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L15.24|
                  |L15.22|
000016  2100              MOVS     r1,#0
                  |L15.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;422      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L15.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L15.40|
                  |L15.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L15.42|
                  |L15.40|
000028  2100              MOVS     r1,#0
                  |L15.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;423      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L15.60|
;;;424      {
;;;425        /* Generate a STOP condition */
;;;426        I2Cx->CR1 |= CR1_STOP_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f4407000          ORR      r0,r0,#0x200
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L15.70|
                  |L15.60|
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the STOP condition generation */
;;;431        I2Cx->CR1 &= CR1_STOP_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f51ff          MOV      r1,#0xfdff
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L15.70|
;;;432      }
;;;433    }
000046  bd70              POP      {r4-r6,pc}
;;;434    
                          ENDP

                  |L15.72|
                          DCD      0x40005400
                  |L15.76|
                          DCD      0x40005800

                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  I2C_GetFlagStatus PROC
;;;1132     */
;;;1133   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b57c              PUSH     {r2-r6,lr}
;;;1134   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1135     FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;1136     __IO uint32_t i2creg = 0, i2cxbase = 0;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
00000c  9000              STR      r0,[sp,#0]
;;;1137   
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
00000e  4936              LDR      r1,|L16.232|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L16.26|
000014  4935              LDR      r1,|L16.236|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L16.30|
                  |L16.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L16.32|
                  |L16.30|
00001e  2100              MOVS     r1,#0
                  |L16.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;1140     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
000026  f5b40f00          CMP      r4,#0x800000
00002a  d03f              BEQ      |L16.172|
00002c  f5b40f80          CMP      r4,#0x400000
000030  d03c              BEQ      |L16.172|
000032  f5b41f00          CMP      r4,#0x200000
000036  d039              BEQ      |L16.172|
000038  f5b41f80          CMP      r4,#0x100000
00003c  d036              BEQ      |L16.172|
00003e  f5b42f80          CMP      r4,#0x40000
000042  d033              BEQ      |L16.172|
000044  f5b43f00          CMP      r4,#0x20000
000048  d030              BEQ      |L16.172|
00004a  f5b43f80          CMP      r4,#0x10000
00004e  d02d              BEQ      |L16.172|
000050  4927              LDR      r1,|L16.240|
000052  428c              CMP      r4,r1
000054  d02a              BEQ      |L16.172|
000056  4927              LDR      r1,|L16.244|
000058  428c              CMP      r4,r1
00005a  d027              BEQ      |L16.172|
00005c  f1b42f10          CMP      r4,#0x10001000
000060  d024              BEQ      |L16.172|
000062  4925              LDR      r1,|L16.248|
000064  428c              CMP      r4,r1
000066  d021              BEQ      |L16.172|
000068  4924              LDR      r1,|L16.252|
00006a  428c              CMP      r4,r1
00006c  d01e              BEQ      |L16.172|
00006e  4924              LDR      r1,|L16.256|
000070  428c              CMP      r4,r1
000072  d01b              BEQ      |L16.172|
000074  4923              LDR      r1,|L16.260|
000076  428c              CMP      r4,r1
000078  d018              BEQ      |L16.172|
00007a  4922              LDR      r1,|L16.260|
00007c  3980              SUBS     r1,r1,#0x80
00007e  428c              CMP      r4,r1
000080  d014              BEQ      |L16.172|
000082  4920              LDR      r1,|L16.260|
000084  39c0              SUBS     r1,r1,#0xc0
000086  428c              CMP      r4,r1
000088  d010              BEQ      |L16.172|
00008a  491e              LDR      r1,|L16.260|
00008c  39f0              SUBS     r1,r1,#0xf0
00008e  428c              CMP      r4,r1
000090  d00c              BEQ      |L16.172|
000092  491c              LDR      r1,|L16.260|
000094  39f8              SUBS     r1,r1,#0xf8
000096  428c              CMP      r4,r1
000098  d008              BEQ      |L16.172|
00009a  1f09              SUBS     r1,r1,#4
00009c  428c              CMP      r4,r1
00009e  d005              BEQ      |L16.172|
0000a0  1e89              SUBS     r1,r1,#2
0000a2  428c              CMP      r4,r1
0000a4  d002              BEQ      |L16.172|
0000a6  1e49              SUBS     r1,r1,#1
0000a8  428c              CMP      r4,r1
0000aa  d101              BNE      |L16.176|
                  |L16.172|
0000ac  2101              MOVS     r1,#1
0000ae  e000              B        |L16.178|
                  |L16.176|
0000b0  2100              MOVS     r1,#0
                  |L16.178|
0000b2  4608              MOV      r0,r1
0000b4  f7fffffe          BL       assert_param
;;;1141   
;;;1142     /* Get the I2Cx peripheral base address */
;;;1143     i2cxbase = (uint32_t)I2Cx;
0000b8  9500              STR      r5,[sp,#0]
;;;1144     
;;;1145     /* Read flag register index */
;;;1146     i2creg = I2C_FLAG >> 28;
0000ba  0f20              LSRS     r0,r4,#28
0000bc  9001              STR      r0,[sp,#4]
;;;1147     
;;;1148     /* Get bit[23:0] of the flag */
;;;1149     I2C_FLAG &= FLAG_Mask;
0000be  f024447f          BIC      r4,r4,#0xff000000
;;;1150     
;;;1151     if(i2creg != 0)
0000c2  9801              LDR      r0,[sp,#4]
0000c4  b118              CBZ      r0,|L16.206|
;;;1152     {
;;;1153       /* Get the I2Cx SR1 register address */
;;;1154       i2cxbase += 0x14;
0000c6  9800              LDR      r0,[sp,#0]
0000c8  3014              ADDS     r0,r0,#0x14
0000ca  9000              STR      r0,[sp,#0]
0000cc  e003              B        |L16.214|
                  |L16.206|
;;;1155     }
;;;1156     else
;;;1157     {
;;;1158       /* Flag in I2Cx SR2 Register */
;;;1159       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
0000ce  0c24              LSRS     r4,r4,#16
;;;1160       /* Get the I2Cx SR2 register address */
;;;1161       i2cxbase += 0x18;
0000d0  9800              LDR      r0,[sp,#0]
0000d2  3018              ADDS     r0,r0,#0x18
0000d4  9000              STR      r0,[sp,#0]
                  |L16.214|
;;;1162     }
;;;1163     
;;;1164     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
0000d6  9800              LDR      r0,[sp,#0]
0000d8  6800              LDR      r0,[r0,#0]
0000da  4020              ANDS     r0,r0,r4
0000dc  b108              CBZ      r0,|L16.226|
;;;1165     {
;;;1166       /* I2C_FLAG is set */
;;;1167       bitstatus = SET;
0000de  2601              MOVS     r6,#1
0000e0  e000              B        |L16.228|
                  |L16.226|
;;;1168     }
;;;1169     else
;;;1170     {
;;;1171       /* I2C_FLAG is reset */
;;;1172       bitstatus = RESET;
0000e2  2600              MOVS     r6,#0
                  |L16.228|
;;;1173     }
;;;1174     
;;;1175     /* Return the I2C_FLAG status */
;;;1176     return  bitstatus;
0000e4  4630              MOV      r0,r6
;;;1177   }
0000e6  bd7c              POP      {r2-r6,pc}
;;;1178   
                          ENDP

                  |L16.232|
                          DCD      0x40005400
                  |L16.236|
                          DCD      0x40005800
                  |L16.240|
                          DCD      0x10008000
                  |L16.244|
                          DCD      0x10004000
                  |L16.248|
                          DCD      0x10000800
                  |L16.252|
                          DCD      0x10000400
                  |L16.256|
                          DCD      0x10000200
                  |L16.260|
                          DCD      0x10000100

                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=2

                  I2C_GetITStatus PROC
;;;1245     */
;;;1246   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1247   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1248     ITStatus bitstatus = RESET;
000008  2600              MOVS     r6,#0
;;;1249     uint32_t enablestatus = 0;
00000a  2700              MOVS     r7,#0
;;;1250   
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
00000c  4927              LDR      r1,|L17.172|
00000e  428d              CMP      r5,r1
000010  d002              BEQ      |L17.24|
000012  4927              LDR      r1,|L17.176|
000014  428d              CMP      r5,r1
000016  d101              BNE      |L17.28|
                  |L17.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L17.30|
                  |L17.28|
00001c  2100              MOVS     r1,#0
                  |L17.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;1253     assert_param(IS_I2C_GET_IT(I2C_IT));
000024  4923              LDR      r1,|L17.180|
000026  428c              CMP      r4,r1
000028  d028              BEQ      |L17.124|
00002a  4923              LDR      r1,|L17.184|
00002c  428c              CMP      r4,r1
00002e  d025              BEQ      |L17.124|
000030  4922              LDR      r1,|L17.188|
000032  428c              CMP      r4,r1
000034  d022              BEQ      |L17.124|
000036  4922              LDR      r1,|L17.192|
000038  428c              CMP      r4,r1
00003a  d01f              BEQ      |L17.124|
00003c  4921              LDR      r1,|L17.196|
00003e  428c              CMP      r4,r1
000040  d01c              BEQ      |L17.124|
000042  4921              LDR      r1,|L17.200|
000044  428c              CMP      r4,r1
000046  d019              BEQ      |L17.124|
000048  f1b42f01          CMP      r4,#0x1000100
00004c  d016              BEQ      |L17.124|
00004e  491f              LDR      r1,|L17.204|
000050  428c              CMP      r4,r1
000052  d013              BEQ      |L17.124|
000054  491d              LDR      r1,|L17.204|
000056  3940              SUBS     r1,r1,#0x40
000058  428c              CMP      r4,r1
00005a  d00f              BEQ      |L17.124|
00005c  491c              LDR      r1,|L17.208|
00005e  428c              CMP      r4,r1
000060  d00c              BEQ      |L17.124|
000062  491b              LDR      r1,|L17.208|
000064  3908              SUBS     r1,r1,#8
000066  428c              CMP      r4,r1
000068  d008              BEQ      |L17.124|
00006a  1f09              SUBS     r1,r1,#4
00006c  428c              CMP      r4,r1
00006e  d005              BEQ      |L17.124|
000070  1e89              SUBS     r1,r1,#2
000072  428c              CMP      r4,r1
000074  d002              BEQ      |L17.124|
000076  1e49              SUBS     r1,r1,#1
000078  428c              CMP      r4,r1
00007a  d101              BNE      |L17.128|
                  |L17.124|
00007c  2101              MOVS     r1,#1
00007e  e000              B        |L17.130|
                  |L17.128|
000080  2100              MOVS     r1,#0
                  |L17.130|
000082  4608              MOV      r0,r1
000084  f7fffffe          BL       assert_param
;;;1254   
;;;1255     /* Check if the interrupt source is enabled or not */
;;;1256     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
000088  88a8              LDRH     r0,[r5,#4]
00008a  f00461e0          AND      r1,r4,#0x7000000
00008e  ea004711          AND      r7,r0,r1,LSR #16
;;;1257     
;;;1258     /* Get bit[23:0] of the flag */
;;;1259     I2C_IT &= FLAG_Mask;
000092  f024447f          BIC      r4,r4,#0xff000000
;;;1260   
;;;1261     /* Check the status of the specified I2C flag */
;;;1262     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000096  8aa8              LDRH     r0,[r5,#0x14]
000098  4020              ANDS     r0,r0,r4
00009a  b110              CBZ      r0,|L17.162|
00009c  b10f              CBZ      r7,|L17.162|
;;;1263     {
;;;1264       /* I2C_IT is set */
;;;1265       bitstatus = SET;
00009e  2601              MOVS     r6,#1
0000a0  e000              B        |L17.164|
                  |L17.162|
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       /* I2C_IT is reset */
;;;1270       bitstatus = RESET;
0000a2  2600              MOVS     r6,#0
                  |L17.164|
;;;1271     }
;;;1272     /* Return the I2C_IT status */
;;;1273     return  bitstatus;
0000a4  4630              MOV      r0,r6
;;;1274   }
0000a6  e8bd81f0          POP      {r4-r8,pc}
;;;1275   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
                          DCD      0x40005400
                  |L17.176|
                          DCD      0x40005800
                  |L17.180|
                          DCD      0x01008000
                  |L17.184|
                          DCD      0x01004000
                  |L17.188|
                          DCD      0x01001000
                  |L17.192|
                          DCD      0x01000800
                  |L17.196|
                          DCD      0x01000400
                  |L17.200|
                          DCD      0x01000200
                  |L17.204|
                          DCD      0x06000080
                  |L17.208|
                          DCD      0x02000010

                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=2

                  I2C_GetLastEvent PROC
;;;1077     */
;;;1078   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1079   {
000004  4604              MOV      r4,r0
;;;1080     uint32_t lastevent = 0;
000006  2600              MOVS     r6,#0
;;;1081     uint32_t flag1 = 0, flag2 = 0;
000008  2700              MOVS     r7,#0
00000a  2500              MOVS     r5,#0
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
00000c  490a              LDR      r1,|L18.56|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L18.24|
000012  490a              LDR      r1,|L18.60|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L18.28|
                  |L18.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L18.30|
                  |L18.28|
00001c  2100              MOVS     r1,#0
                  |L18.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;1085   
;;;1086     /* Read the I2Cx status register */
;;;1087     flag1 = I2Cx->SR1;
000024  8aa7              LDRH     r7,[r4,#0x14]
;;;1088     flag2 = I2Cx->SR2;
000026  8b25              LDRH     r5,[r4,#0x18]
;;;1089     flag2 = flag2 << 16;
000028  042d              LSLS     r5,r5,#16
;;;1090   
;;;1091     /* Get the last event value from I2C status register */
;;;1092     lastevent = (flag1 | flag2) & FLAG_Mask;
00002a  ea470005          ORR      r0,r7,r5
00002e  f020467f          BIC      r6,r0,#0xff000000
;;;1093   
;;;1094     /* Return status */
;;;1095     return lastevent;
000032  4630              MOV      r0,r6
;;;1096   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1097   
                          ENDP

                  |L18.56|
                          DCD      0x40005400
                  |L18.60|
                          DCD      0x40005800

                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=2

                  I2C_GetPEC PROC
;;;824      */
;;;825    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;826    {
000002  4604              MOV      r4,r0
;;;827      /* Check the parameters */
;;;828      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4907              LDR      r1,|L19.36|
000006  428c              CMP      r4,r1
000008  d002              BEQ      |L19.16|
00000a  4907              LDR      r1,|L19.40|
00000c  428c              CMP      r4,r1
00000e  d101              BNE      |L19.20|
                  |L19.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L19.22|
                  |L19.20|
000014  2100              MOVS     r1,#0
                  |L19.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;829      /* Return the selected I2C PEC value */
;;;830      return ((I2Cx->SR2) >> 8);
00001c  8b20              LDRH     r0,[r4,#0x18]
00001e  1200              ASRS     r0,r0,#8
;;;831    }
000020  bd10              POP      {r4,pc}
;;;832    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      0x40005400
                  |L19.40|
                          DCD      0x40005800

                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=2

                  I2C_ITConfig PROC
;;;544      */
;;;545    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;546    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;547      /* Check the parameters */
;;;548      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000008  4914              LDR      r1,|L20.92|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L20.20|
00000e  4914              LDR      r1,|L20.96|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L20.24|
                  |L20.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L20.26|
                  |L20.24|
000018  2100              MOVS     r1,#0
                  |L20.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
000020  b10e              CBZ      r6,|L20.38|
000022  2e01              CMP      r6,#1
000024  d101              BNE      |L20.42|
                  |L20.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L20.44|
                  |L20.42|
00002a  2100              MOVS     r1,#0
                  |L20.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;550      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
000032  f64f01ff          MOV      r1,#0xf8ff
000036  4029              ANDS     r1,r1,r5
000038  b911              CBNZ     r1,|L20.64|
00003a  b10d              CBZ      r5,|L20.64|
00003c  2101              MOVS     r1,#1
00003e  e000              B        |L20.66|
                  |L20.64|
000040  2100              MOVS     r1,#0
                  |L20.66|
000042  4608              MOV      r0,r1
000044  f7fffffe          BL       assert_param
;;;551      
;;;552      if (NewState != DISABLE)
000048  b11e              CBZ      r6,|L20.82|
;;;553      {
;;;554        /* Enable the selected I2C interrupts */
;;;555        I2Cx->CR2 |= I2C_IT;
00004a  88a0              LDRH     r0,[r4,#4]
00004c  4328              ORRS     r0,r0,r5
00004e  80a0              STRH     r0,[r4,#4]
000050  e002              B        |L20.88|
                  |L20.82|
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Disable the selected I2C interrupts */
;;;560        I2Cx->CR2 &= (uint16_t)~I2C_IT;
000052  88a0              LDRH     r0,[r4,#4]
000054  43a8              BICS     r0,r0,r5
000056  80a0              STRH     r0,[r4,#4]
                  |L20.88|
;;;561      }
;;;562    }
000058  bd70              POP      {r4-r6,pc}
;;;563    
                          ENDP

00005a  0000              DCW      0x0000
                  |L20.92|
                          DCD      0x40005400
                  |L20.96|
                          DCD      0x40005800

                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;190      */
;;;191    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;192    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;193      uint16_t tmpreg = 0, freqrange = 0;
00000a  2600              MOVS     r6,#0
00000c  46b1              MOV      r9,r6
;;;194      uint16_t result = 0x04;
00000e  2704              MOVS     r7,#4
;;;195      uint32_t pclk1 = 8000000;
000010  f8df817c          LDR      r8,|L21.400|
;;;196      RCC_ClocksTypeDef  rcc_clocks;
;;;197      /* Check the parameters */
;;;198      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000014  495f              LDR      r1,|L21.404|
000016  428d              CMP      r5,r1
000018  d002              BEQ      |L21.32|
00001a  495f              LDR      r1,|L21.408|
00001c  428d              CMP      r5,r1
00001e  d101              BNE      |L21.36|
                  |L21.32|
000020  2101              MOVS     r1,#1
000022  e000              B        |L21.38|
                  |L21.36|
000024  2100              MOVS     r1,#0
                  |L21.38|
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       assert_param
;;;199      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
00002c  6821              LDR      r1,[r4,#0]
00002e  b129              CBZ      r1,|L21.60|
000030  4a5a              LDR      r2,|L21.412|
000032  6821              LDR      r1,[r4,#0]
000034  4291              CMP      r1,r2
000036  d801              BHI      |L21.60|
000038  2101              MOVS     r1,#1
00003a  e000              B        |L21.62|
                  |L21.60|
00003c  2100              MOVS     r1,#0
                  |L21.62|
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       assert_param
;;;200      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
000044  88a1              LDRH     r1,[r4,#4]
000046  b129              CBZ      r1,|L21.84|
000048  88a1              LDRH     r1,[r4,#4]
00004a  2902              CMP      r1,#2
00004c  d002              BEQ      |L21.84|
00004e  88a1              LDRH     r1,[r4,#4]
000050  290a              CMP      r1,#0xa
000052  d101              BNE      |L21.88|
                  |L21.84|
000054  2101              MOVS     r1,#1
000056  e000              B        |L21.90|
                  |L21.88|
000058  2100              MOVS     r1,#0
                  |L21.90|
00005a  4608              MOV      r0,r1
00005c  f7fffffe          BL       assert_param
;;;201      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
000060  88e1              LDRH     r1,[r4,#6]
000062  f5b14f80          CMP      r1,#0x4000
000066  d004              BEQ      |L21.114|
000068  88e1              LDRH     r1,[r4,#6]
00006a  f64b72ff          MOV      r2,#0xbfff
00006e  4291              CMP      r1,r2
000070  d101              BNE      |L21.118|
                  |L21.114|
000072  2101              MOVS     r1,#1
000074  e000              B        |L21.120|
                  |L21.118|
000076  2100              MOVS     r1,#0
                  |L21.120|
000078  4608              MOV      r0,r1
00007a  f7fffffe          BL       assert_param
;;;202      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
00007e  8921              LDRH     r1,[r4,#8]
000080  f5b16f80          CMP      r1,#0x400
000084  da01              BGE      |L21.138|
000086  2101              MOVS     r1,#1
000088  e000              B        |L21.140|
                  |L21.138|
00008a  2100              MOVS     r1,#0
                  |L21.140|
00008c  4608              MOV      r0,r1
00008e  f7fffffe          BL       assert_param
;;;203      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
000092  8961              LDRH     r1,[r4,#0xa]
000094  f5b16f80          CMP      r1,#0x400
000098  d001              BEQ      |L21.158|
00009a  8961              LDRH     r1,[r4,#0xa]
00009c  b909              CBNZ     r1,|L21.162|
                  |L21.158|
00009e  2101              MOVS     r1,#1
0000a0  e000              B        |L21.164|
                  |L21.162|
0000a2  2100              MOVS     r1,#0
                  |L21.164|
0000a4  4608              MOV      r0,r1
0000a6  f7fffffe          BL       assert_param
;;;204      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
0000aa  89a1              LDRH     r1,[r4,#0xc]
0000ac  f5b14f80          CMP      r1,#0x4000
0000b0  d003              BEQ      |L21.186|
0000b2  89a1              LDRH     r1,[r4,#0xc]
0000b4  f5b14f40          CMP      r1,#0xc000
0000b8  d101              BNE      |L21.190|
                  |L21.186|
0000ba  2101              MOVS     r1,#1
0000bc  e000              B        |L21.192|
                  |L21.190|
0000be  2100              MOVS     r1,#0
                  |L21.192|
0000c0  4608              MOV      r0,r1
0000c2  f7fffffe          BL       assert_param
;;;205    
;;;206    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;207      /* Get the I2Cx CR2 value */
;;;208      tmpreg = I2Cx->CR2;
0000c6  88ae              LDRH     r6,[r5,#4]
;;;209      /* Clear frequency FREQ[5:0] bits */
;;;210      tmpreg &= CR2_FREQ_Reset;
0000c8  f64f70c0          MOV      r0,#0xffc0
0000cc  4006              ANDS     r6,r6,r0
;;;211      /* Get pclk1 frequency value */
;;;212      RCC_GetClocksFreq(&rcc_clocks);
0000ce  4668              MOV      r0,sp
0000d0  f7fffffe          BL       RCC_GetClocksFreq
;;;213      pclk1 = rcc_clocks.PCLK1_Frequency;
0000d4  f8dd8008          LDR      r8,[sp,#8]
;;;214      /* Set frequency bits depending on pclk1 value */
;;;215      freqrange = (uint16_t)(pclk1 / 1000000);
0000d8  4831              LDR      r0,|L21.416|
0000da  fbb8f0f0          UDIV     r0,r8,r0
0000de  fa1ff980          UXTH     r9,r0
;;;216      tmpreg |= freqrange;
0000e2  ea460609          ORR      r6,r6,r9
;;;217      /* Write to I2Cx CR2 */
;;;218      I2Cx->CR2 = tmpreg;
0000e6  80ae              STRH     r6,[r5,#4]
;;;219    
;;;220    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;221      /* Disable the selected I2C peripheral to configure TRISE */
;;;222      I2Cx->CR1 &= CR1_PE_Reset;
0000e8  8828              LDRH     r0,[r5,#0]
0000ea  f64f71fe          MOV      r1,#0xfffe
0000ee  4008              ANDS     r0,r0,r1
0000f0  8028              STRH     r0,[r5,#0]
;;;223      /* Reset tmpreg value */
;;;224      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;225      tmpreg = 0;
0000f2  2600              MOVS     r6,#0
;;;226    
;;;227      /* Configure speed in standard mode */
;;;228      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
0000f4  492b              LDR      r1,|L21.420|
0000f6  6820              LDR      r0,[r4,#0]
0000f8  4288              CMP      r0,r1
0000fa  d80c              BHI      |L21.278|
;;;229      {
;;;230        /* Standard mode speed calculate */
;;;231        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
0000fc  6820              LDR      r0,[r4,#0]
0000fe  0040              LSLS     r0,r0,#1
000100  fbb8f0f0          UDIV     r0,r8,r0
000104  b287              UXTH     r7,r0
;;;232        /* Test if CCR value is under 0x4*/
;;;233        if (result < 0x04)
000106  2f04              CMP      r7,#4
000108  da00              BGE      |L21.268|
;;;234        {
;;;235          /* Set minimum allowed value */
;;;236          result = 0x04;  
00010a  2704              MOVS     r7,#4
                  |L21.268|
;;;237        }
;;;238        /* Set speed value for standard mode */
;;;239        tmpreg |= result;	  
00010c  433e              ORRS     r6,r6,r7
;;;240        /* Set Maximum Rise Time for standard mode */
;;;241        I2Cx->TRISE = freqrange + 1; 
00010e  f1090001          ADD      r0,r9,#1
000112  8428              STRH     r0,[r5,#0x20]
000114  e027              B        |L21.358|
                  |L21.278|
;;;242      }
;;;243      /* Configure speed in fast mode */
;;;244      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;245      {
;;;246        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000116  88e0              LDRH     r0,[r4,#6]
000118  f64b71ff          MOV      r1,#0xbfff
00011c  4288              CMP      r0,r1
00011e  d106              BNE      |L21.302|
;;;247        {
;;;248          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;249          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
000120  6820              LDR      r0,[r4,#0]
000122  eb000040          ADD      r0,r0,r0,LSL #1
000126  fbb8f0f0          UDIV     r0,r8,r0
00012a  b287              UXTH     r7,r0
00012c  e009              B        |L21.322|
                  |L21.302|
;;;250        }
;;;251        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;252        {
;;;253          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;254          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00012e  6820              LDR      r0,[r4,#0]
000130  eb0001c0          ADD      r1,r0,r0,LSL #3
000134  eb011000          ADD      r0,r1,r0,LSL #4
000138  fbb8f0f0          UDIV     r0,r8,r0
00013c  b287              UXTH     r7,r0
;;;255          /* Set DUTY bit */
;;;256          result |= I2C_DutyCycle_16_9;
00013e  f4474780          ORR      r7,r7,#0x4000
                  |L21.322|
;;;257        }
;;;258    
;;;259        /* Test if CCR value is under 0x1*/
;;;260        if ((result & CCR_CCR_Set) == 0)
000142  f3c7000b          UBFX     r0,r7,#0,#12
000146  b908              CBNZ     r0,|L21.332|
;;;261        {
;;;262          /* Set minimum allowed value */
;;;263          result |= (uint16_t)0x0001;  
000148  f0470701          ORR      r7,r7,#1
                  |L21.332|
;;;264        }
;;;265        /* Set speed value and set F/S bit for fast mode */
;;;266        tmpreg |= (uint16_t)(result | CCR_FS_Set);
00014c  f4474000          ORR      r0,r7,#0x8000
000150  4306              ORRS     r6,r6,r0
;;;267        /* Set Maximum Rise Time for fast mode */
;;;268        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
000152  f44f7096          MOV      r0,#0x12c
000156  fb09f000          MUL      r0,r9,r0
00015a  f44f717a          MOV      r1,#0x3e8
00015e  fb90f0f1          SDIV     r0,r0,r1
000162  1c40              ADDS     r0,r0,#1
000164  8428              STRH     r0,[r5,#0x20]
                  |L21.358|
;;;269      }
;;;270    
;;;271      /* Write to I2Cx CCR */
;;;272      I2Cx->CCR = tmpreg;
000166  83ae              STRH     r6,[r5,#0x1c]
;;;273      /* Enable the selected I2C peripheral */
;;;274      I2Cx->CR1 |= CR1_PE_Set;
000168  8828              LDRH     r0,[r5,#0]
00016a  f0400001          ORR      r0,r0,#1
00016e  8028              STRH     r0,[r5,#0]
;;;275    
;;;276    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;277      /* Get the I2Cx CR1 value */
;;;278      tmpreg = I2Cx->CR1;
000170  882e              LDRH     r6,[r5,#0]
;;;279      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;280      tmpreg &= CR1_CLEAR_Mask;
000172  f64f30f5          MOV      r0,#0xfbf5
000176  4006              ANDS     r6,r6,r0
;;;281      /* Configure I2Cx: mode and acknowledgement */
;;;282      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;283      /* Set ACK bit according to I2C_Ack value */
;;;284      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000178  88a0              LDRH     r0,[r4,#4]
00017a  8961              LDRH     r1,[r4,#0xa]
00017c  4308              ORRS     r0,r0,r1
00017e  4306              ORRS     r6,r6,r0
;;;285      /* Write to I2Cx CR1 */
;;;286      I2Cx->CR1 = tmpreg;
000180  802e              STRH     r6,[r5,#0]
;;;287    
;;;288    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;289      /* Set I2Cx Own Address1 and acknowledged address */
;;;290      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000182  89a0              LDRH     r0,[r4,#0xc]
000184  8921              LDRH     r1,[r4,#8]
000186  4308              ORRS     r0,r0,r1
000188  8128              STRH     r0,[r5,#8]
;;;291    }
00018a  b005              ADD      sp,sp,#0x14
00018c  e8bd83f0          POP      {r4-r9,pc}
;;;292    
                          ENDP

                  |L21.400|
                          DCD      0x007a1200
                  |L21.404|
                          DCD      0x40005400
                  |L21.408|
                          DCD      0x40005800
                  |L21.412|
                          DCD      0x00061a80
                  |L21.416|
                          DCD      0x000f4240
                  |L21.420|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=2

                  I2C_NACKPositionConfig PROC
;;;695      */
;;;696    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  b570              PUSH     {r4-r6,lr}
;;;697    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;698      /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4913              LDR      r1,|L22.84|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L22.18|
00000c  4912              LDR      r1,|L22.88|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L22.22|
                  |L22.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L22.24|
                  |L22.22|
000016  2100              MOVS     r1,#0
                  |L22.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;700      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
00001e  f5b56f00          CMP      r5,#0x800
000022  d003              BEQ      |L22.44|
000024  f24f71ff          MOV      r1,#0xf7ff
000028  428d              CMP      r5,r1
00002a  d101              BNE      |L22.48|
                  |L22.44|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L22.50|
                  |L22.48|
000030  2100              MOVS     r1,#0
                  |L22.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;701      
;;;702      /* Check the input parameter */
;;;703      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000038  f5b56f00          CMP      r5,#0x800
00003c  d104              BNE      |L22.72|
;;;704      {
;;;705        /* Next byte in shift register is the last received byte */
;;;706        I2Cx->CR1 |= I2C_NACKPosition_Next;
00003e  8820              LDRH     r0,[r4,#0]
000040  f4406000          ORR      r0,r0,#0x800
000044  8020              STRH     r0,[r4,#0]
000046  e004              B        |L22.82|
                  |L22.72|
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Current byte in shift register is the last received byte */
;;;711        I2Cx->CR1 &= I2C_NACKPosition_Current;
000048  8820              LDRH     r0,[r4,#0]
00004a  f24f71ff          MOV      r1,#0xf7ff
00004e  4008              ANDS     r0,r0,r1
000050  8020              STRH     r0,[r4,#0]
                  |L22.82|
;;;712      }
;;;713    }
000052  bd70              POP      {r4-r6,pc}
;;;714    
                          ENDP

                  |L22.84|
                          DCD      0x40005400
                  |L22.88|
                          DCD      0x40005800

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=2

                  I2C_OwnAddress2Config PROC
;;;464      */
;;;465    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;467      uint16_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;468    
;;;469      /* Check the parameters */
;;;470      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000008  490a              LDR      r1,|L23.52|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L23.20|
00000e  490a              LDR      r1,|L23.56|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L23.24|
                  |L23.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L23.26|
                  |L23.24|
000018  2100              MOVS     r1,#0
                  |L23.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;471    
;;;472      /* Get the old register value */
;;;473      tmpreg = I2Cx->OAR2;
000020  89a5              LDRH     r5,[r4,#0xc]
;;;474    
;;;475      /* Reset I2Cx Own address2 bit [7:1] */
;;;476      tmpreg &= OAR2_ADD2_Reset;
000022  f64f7001          MOV      r0,#0xff01
000026  4005              ANDS     r5,r5,r0
;;;477    
;;;478      /* Set I2Cx Own address2 */
;;;479      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000028  f00600fe          AND      r0,r6,#0xfe
00002c  4305              ORRS     r5,r5,r0
;;;480    
;;;481      /* Store the new register value */
;;;482      I2Cx->OAR2 = tmpreg;
00002e  81a5              STRH     r5,[r4,#0xc]
;;;483    }
000030  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

000032  0000              DCW      0x0000
                  |L23.52|
                          DCD      0x40005400
                  |L23.56|
                          DCD      0x40005800

                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=2

                  I2C_PECPositionConfig PROC
;;;778      */
;;;779    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  b570              PUSH     {r4-r6,lr}
;;;780    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;781      /* Check the parameters */
;;;782      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4913              LDR      r1,|L24.84|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L24.18|
00000c  4912              LDR      r1,|L24.88|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L24.22|
                  |L24.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L24.24|
                  |L24.22|
000016  2100              MOVS     r1,#0
                  |L24.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;783      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
00001e  f5b56f00          CMP      r5,#0x800
000022  d003              BEQ      |L24.44|
000024  f24f71ff          MOV      r1,#0xf7ff
000028  428d              CMP      r5,r1
00002a  d101              BNE      |L24.48|
                  |L24.44|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L24.50|
                  |L24.48|
000030  2100              MOVS     r1,#0
                  |L24.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;784      if (I2C_PECPosition == I2C_PECPosition_Next)
000038  f5b56f00          CMP      r5,#0x800
00003c  d104              BNE      |L24.72|
;;;785      {
;;;786        /* Next byte in shift register is PEC */
;;;787        I2Cx->CR1 |= I2C_PECPosition_Next;
00003e  8820              LDRH     r0,[r4,#0]
000040  f4406000          ORR      r0,r0,#0x800
000044  8020              STRH     r0,[r4,#0]
000046  e004              B        |L24.82|
                  |L24.72|
;;;788      }
;;;789      else
;;;790      {
;;;791        /* Current byte in shift register is PEC */
;;;792        I2Cx->CR1 &= I2C_PECPosition_Current;
000048  8820              LDRH     r0,[r4,#0]
00004a  f24f71ff          MOV      r1,#0xf7ff
00004e  4008              ANDS     r0,r0,r1
000050  8020              STRH     r0,[r4,#0]
                  |L24.82|
;;;793      }
;;;794    }
000052  bd70              POP      {r4-r6,pc}
;;;795    
                          ENDP

                  |L24.84|
                          DCD      0x40005400
                  |L24.88|
                          DCD      0x40005800

                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=2

                  I2C_ReadRegister PROC
;;;635      */
;;;636    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b538              PUSH     {r3-r5,lr}
;;;637    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;638      __IO uint32_t tmp = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;639    
;;;640      /* Check the parameters */
;;;641      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
00000a  4915              LDR      r1,|L25.96|
00000c  428d              CMP      r5,r1
00000e  d002              BEQ      |L25.22|
000010  4914              LDR      r1,|L25.100|
000012  428d              CMP      r5,r1
000014  d101              BNE      |L25.26|
                  |L25.22|
000016  2101              MOVS     r1,#1
000018  e000              B        |L25.28|
                  |L25.26|
00001a  2100              MOVS     r1,#0
                  |L25.28|
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       assert_param
;;;642      assert_param(IS_I2C_REGISTER(I2C_Register));
000022  b17c              CBZ      r4,|L25.68|
000024  2c04              CMP      r4,#4
000026  d00d              BEQ      |L25.68|
000028  2c08              CMP      r4,#8
00002a  d00b              BEQ      |L25.68|
00002c  2c0c              CMP      r4,#0xc
00002e  d009              BEQ      |L25.68|
000030  2c10              CMP      r4,#0x10
000032  d007              BEQ      |L25.68|
000034  2c14              CMP      r4,#0x14
000036  d005              BEQ      |L25.68|
000038  2c18              CMP      r4,#0x18
00003a  d003              BEQ      |L25.68|
00003c  2c1c              CMP      r4,#0x1c
00003e  d001              BEQ      |L25.68|
000040  2c20              CMP      r4,#0x20
000042  d101              BNE      |L25.72|
                  |L25.68|
000044  2101              MOVS     r1,#1
000046  e000              B        |L25.74|
                  |L25.72|
000048  2100              MOVS     r1,#0
                  |L25.74|
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       assert_param
;;;643    
;;;644      tmp = (uint32_t) I2Cx;
000050  9500              STR      r5,[sp,#0]
;;;645      tmp += I2C_Register;
000052  9800              LDR      r0,[sp,#0]
000054  4420              ADD      r0,r0,r4
000056  9000              STR      r0,[sp,#0]
;;;646    
;;;647      /* Return the selected register value */
;;;648      return (*(__IO uint16_t *) tmp);
000058  9800              LDR      r0,[sp,#0]
00005a  8800              LDRH     r0,[r0,#0]
;;;649    }
00005c  bd38              POP      {r3-r5,pc}
;;;650    
                          ENDP

00005e  0000              DCW      0x0000
                  |L25.96|
                          DCD      0x40005400
                  |L25.100|
                          DCD      0x40005800

                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=2

                  I2C_ReceiveData PROC
;;;582      */
;;;583    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;584    {
000002  4604              MOV      r4,r0
;;;585      /* Check the parameters */
;;;586      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4907              LDR      r1,|L26.36|
000006  428c              CMP      r4,r1
000008  d002              BEQ      |L26.16|
00000a  4907              LDR      r1,|L26.40|
00000c  428c              CMP      r4,r1
00000e  d101              BNE      |L26.20|
                  |L26.16|
000010  2101              MOVS     r1,#1
000012  e000              B        |L26.22|
                  |L26.20|
000014  2100              MOVS     r1,#0
                  |L26.22|
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       assert_param
;;;587      /* Return the data in the DR register */
;;;588      return (uint8_t)I2Cx->DR;
00001c  8a20              LDRH     r0,[r4,#0x10]
00001e  b2c0              UXTB     r0,r0
;;;589    }
000020  bd10              POP      {r4,pc}
;;;590    
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      0x40005400
                  |L26.40|
                          DCD      0x40005800

                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=2

                  I2C_SMBusAlertConfig PROC
;;;723      */
;;;724    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  b570              PUSH     {r4-r6,lr}
;;;725    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;726      /* Check the parameters */
;;;727      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4913              LDR      r1,|L27.84|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L27.18|
00000c  4912              LDR      r1,|L27.88|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L27.22|
                  |L27.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L27.24|
                  |L27.22|
000016  2100              MOVS     r1,#0
                  |L27.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;728      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
00001e  f5b55f00          CMP      r5,#0x2000
000022  d003              BEQ      |L27.44|
000024  f64d71ff          MOV      r1,#0xdfff
000028  428d              CMP      r5,r1
00002a  d101              BNE      |L27.48|
                  |L27.44|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L27.50|
                  |L27.48|
000030  2100              MOVS     r1,#0
                  |L27.50|
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       assert_param
;;;729      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000038  f5b55f00          CMP      r5,#0x2000
00003c  d104              BNE      |L27.72|
;;;730      {
;;;731        /* Drive the SMBusAlert pin Low */
;;;732        I2Cx->CR1 |= I2C_SMBusAlert_Low;
00003e  8820              LDRH     r0,[r4,#0]
000040  f4405000          ORR      r0,r0,#0x2000
000044  8020              STRH     r0,[r4,#0]
000046  e004              B        |L27.82|
                  |L27.72|
;;;733      }
;;;734      else
;;;735      {
;;;736        /* Drive the SMBusAlert pin High  */
;;;737        I2Cx->CR1 &= I2C_SMBusAlert_High;
000048  8820              LDRH     r0,[r4,#0]
00004a  f64d71ff          MOV      r1,#0xdfff
00004e  4008              ANDS     r0,r0,r1
000050  8020              STRH     r0,[r4,#0]
                  |L27.82|
;;;738      }
;;;739    }
000052  bd70              POP      {r4-r6,pc}
;;;740    
                          ENDP

                  |L27.84|
                          DCD      0x40005400
                  |L27.88|
                          DCD      0x40005800

                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=2

                  I2C_Send7bitAddress PROC
;;;600      */
;;;601    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b570              PUSH     {r4-r6,lr}
;;;602    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;603      /* Check the parameters */
;;;604      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000008  490e              LDR      r1,|L28.68|
00000a  428c              CMP      r4,r1
00000c  d002              BEQ      |L28.20|
00000e  490e              LDR      r1,|L28.72|
000010  428c              CMP      r4,r1
000012  d101              BNE      |L28.24|
                  |L28.20|
000014  2101              MOVS     r1,#1
000016  e000              B        |L28.26|
                  |L28.24|
000018  2100              MOVS     r1,#0
                  |L28.26|
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       assert_param
;;;605      assert_param(IS_I2C_DIRECTION(I2C_Direction));
000020  b10e              CBZ      r6,|L28.38|
000022  2e01              CMP      r6,#1
000024  d101              BNE      |L28.42|
                  |L28.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L28.44|
                  |L28.42|
00002a  2100              MOVS     r1,#0
                  |L28.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;606      /* Test on the direction to set/reset the read/write bit */
;;;607      if (I2C_Direction != I2C_Direction_Transmitter)
000032  b116              CBZ      r6,|L28.58|
;;;608      {
;;;609        /* Set the address bit0 for read */
;;;610        Address |= OAR1_ADD0_Set;
000034  f0450501          ORR      r5,r5,#1
000038  e002              B        |L28.64|
                  |L28.58|
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Reset the address bit0 for write */
;;;615        Address &= OAR1_ADD0_Reset;
00003a  f64f70fe          MOV      r0,#0xfffe
00003e  4005              ANDS     r5,r5,r0
                  |L28.64|
;;;616      }
;;;617      /* Send the address */
;;;618      I2Cx->DR = Address;
000040  8225              STRH     r5,[r4,#0x10]
;;;619    }
000042  bd70              POP      {r4-r6,pc}
;;;620    
                          ENDP

                  |L28.68|
                          DCD      0x40005400
                  |L28.72|
                          DCD      0x40005800

                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=2

                  I2C_SendData PROC
;;;569      */
;;;570    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;571    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;572      /* Check the parameters */
;;;573      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4907              LDR      r1,|L29.36|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L29.18|
00000c  4906              LDR      r1,|L29.40|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L29.22|
                  |L29.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L29.24|
                  |L29.22|
000016  2100              MOVS     r1,#0
                  |L29.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;574      /* Write in the DR register the data to be sent */
;;;575      I2Cx->DR = Data;
00001e  8225              STRH     r5,[r4,#0x10]
;;;576    }
000020  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

000022  0000              DCW      0x0000
                  |L29.36|
                          DCD      0x40005400
                  |L29.40|
                          DCD      0x40005800

                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=2

                  I2C_SoftwareResetCmd PROC
;;;657      */
;;;658    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;659    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;660      /* Check the parameters */
;;;661      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L30.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L30.18|
00000c  490f              LDR      r1,|L30.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L30.22|
                  |L30.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L30.24|
                  |L30.22|
000016  2100              MOVS     r1,#0
                  |L30.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;662      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L30.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L30.40|
                  |L30.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L30.42|
                  |L30.40|
000028  2100              MOVS     r1,#0
                  |L30.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;663      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L30.60|
;;;664      {
;;;665        /* Peripheral under reset */
;;;666        I2Cx->CR1 |= CR1_SWRST_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f4404000          ORR      r0,r0,#0x8000
000038  8020              STRH     r0,[r4,#0]
00003a  e003              B        |L30.68|
                  |L30.60|
;;;667      }
;;;668      else
;;;669      {
;;;670        /* Peripheral not under reset */
;;;671        I2Cx->CR1 &= CR1_SWRST_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f3c0000e          UBFX     r0,r0,#0,#15
000042  8020              STRH     r0,[r4,#0]
                  |L30.68|
;;;672      }
;;;673    }
000044  bd70              POP      {r4-r6,pc}
;;;674    
                          ENDP

000046  0000              DCW      0x0000
                  |L30.72|
                          DCD      0x40005400
                  |L30.76|
                          DCD      0x40005800

                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=2

                  I2C_StretchClockCmd PROC
;;;863      */
;;;864    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;865    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;866      /* Check the parameters */
;;;867      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L31.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L31.18|
00000c  490f              LDR      r1,|L31.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L31.22|
                  |L31.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L31.24|
                  |L31.22|
000016  2100              MOVS     r1,#0
                  |L31.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;868      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L31.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L31.40|
                  |L31.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L31.42|
                  |L31.40|
000028  2100              MOVS     r1,#0
                  |L31.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;869      if (NewState == DISABLE)
000030  b925              CBNZ     r5,|L31.60|
;;;870      {
;;;871        /* Enable the selected I2C Clock stretching */
;;;872        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400080          ORR      r0,r0,#0x80
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L31.70|
                  |L31.60|
;;;873      }
;;;874      else
;;;875      {
;;;876        /* Disable the selected I2C Clock stretching */
;;;877        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64f717f          MOV      r1,#0xff7f
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L31.70|
;;;878      }
;;;879    }
000046  bd70              POP      {r4-r6,pc}
;;;880    
                          ENDP

                  |L31.72|
                          DCD      0x40005400
                  |L31.76|
                          DCD      0x40005800

                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;297      */
;;;298    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;299    {
;;;300    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;301      /* initialize the I2C_ClockSpeed member */
;;;302      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;303      /* Initialize the I2C_Mode member */
;;;304      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;305      /* Initialize the I2C_DutyCycle member */
;;;306      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b71ff          MOV      r1,#0xbfff
00000e  80c1              STRH     r1,[r0,#6]
;;;307      /* Initialize the I2C_OwnAddress1 member */
;;;308      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  2100              MOVS     r1,#0
000012  8101              STRH     r1,[r0,#8]
;;;309      /* Initialize the I2C_Ack member */
;;;310      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000014  8141              STRH     r1,[r0,#0xa]
;;;311      /* Initialize the I2C_AcknowledgedAddress member */
;;;312      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000016  f44f4180          MOV      r1,#0x4000
00001a  8181              STRH     r1,[r0,#0xc]
;;;313    }
00001c  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=2

                  I2C_TransmitPEC PROC
;;;747      */
;;;748    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;749    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;750      /* Check the parameters */
;;;751      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4910              LDR      r1,|L33.72|
000008  428c              CMP      r4,r1
00000a  d002              BEQ      |L33.18|
00000c  490f              LDR      r1,|L33.76|
00000e  428c              CMP      r4,r1
000010  d101              BNE      |L33.22|
                  |L33.18|
000012  2101              MOVS     r1,#1
000014  e000              B        |L33.24|
                  |L33.22|
000016  2100              MOVS     r1,#0
                  |L33.24|
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       assert_param
;;;752      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L33.36|
000020  2d01              CMP      r5,#1
000022  d101              BNE      |L33.40|
                  |L33.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L33.42|
                  |L33.40|
000028  2100              MOVS     r1,#0
                  |L33.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;753      if (NewState != DISABLE)
000030  b125              CBZ      r5,|L33.60|
;;;754      {
;;;755        /* Enable the selected I2C PEC transmission */
;;;756        I2Cx->CR1 |= CR1_PEC_Set;
000032  8820              LDRH     r0,[r4,#0]
000034  f4405080          ORR      r0,r0,#0x1000
000038  8020              STRH     r0,[r4,#0]
00003a  e004              B        |L33.70|
                  |L33.60|
;;;757      }
;;;758      else
;;;759      {
;;;760        /* Disable the selected I2C PEC transmission */
;;;761        I2Cx->CR1 &= CR1_PEC_Reset;
00003c  8820              LDRH     r0,[r4,#0]
00003e  f64e71ff          MOV      r1,#0xefff
000042  4008              ANDS     r0,r0,r1
000044  8020              STRH     r0,[r4,#0]
                  |L33.70|
;;;762      }
;;;763    }
000046  bd70              POP      {r4-r6,pc}
;;;764    
                          ENDP

                  |L33.72|
                          DCD      0x40005400
                  |L33.76|
                          DCD      0x40005800
