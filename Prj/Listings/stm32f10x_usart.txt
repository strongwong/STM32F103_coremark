; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f10x_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\App\inc -I..\Board\inc -I..\Chip\Hal_lib\inc -I..\Chip\Startup\inc -I..\coremark -I..\Chip\CMSIS -I.\RTE\_CoreMark -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD --omf_browse=.\objects\stm32f10x_usart.crf ..\Chip\Hal_lib\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=2

                  USART_ClearFlag PROC
;;;922      */
;;;923    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;924    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;925      /* Check the parameters */
;;;926      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  491b              LDR      r1,|L1.116|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L1.36|
00000c  491a              LDR      r1,|L1.120|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L1.36|
000012  491a              LDR      r1,|L1.124|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L1.36|
000018  4919              LDR      r1,|L1.128|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L1.36|
00001e  4919              LDR      r1,|L1.132|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L1.40|
                  |L1.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L1.42|
                  |L1.40|
000028  2100              MOVS     r1,#0
                  |L1.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;927      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
000030  f64f419f          MOV      r1,#0xfc9f
000034  4029              ANDS     r1,r1,r5
000036  b911              CBNZ     r1,|L1.62|
000038  b10d              CBZ      r5,|L1.62|
00003a  2101              MOVS     r1,#1
00003c  e000              B        |L1.64|
                  |L1.62|
00003e  2100              MOVS     r1,#0
                  |L1.64|
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       assert_param
;;;928      /* The CTS flag is not available for UART4 and UART5 */
;;;929      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000046  f4057000          AND      r0,r5,#0x200
00004a  f5b07f00          CMP      r0,#0x200
00004e  d10e              BNE      |L1.110|
;;;930      {
;;;931        assert_param(IS_USART_123_PERIPH(USARTx));
000050  4908              LDR      r1,|L1.116|
000052  428c              CMP      r4,r1
000054  d005              BEQ      |L1.98|
000056  4908              LDR      r1,|L1.120|
000058  428c              CMP      r4,r1
00005a  d002              BEQ      |L1.98|
00005c  4907              LDR      r1,|L1.124|
00005e  428c              CMP      r4,r1
000060  d101              BNE      |L1.102|
                  |L1.98|
000062  2101              MOVS     r1,#1
000064  e000              B        |L1.104|
                  |L1.102|
000066  2100              MOVS     r1,#0
                  |L1.104|
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       assert_param
                  |L1.110|
;;;932      } 
;;;933       
;;;934      USARTx->SR = (uint16_t)~USART_FLAG;
00006e  43e8              MVNS     r0,r5
000070  8020              STRH     r0,[r4,#0]
;;;935    }
000072  bd70              POP      {r4-r6,pc}
;;;936    
                          ENDP

                  |L1.116|
                          DCD      0x40013800
                  |L1.120|
                          DCD      0x40004400
                  |L1.124|
                          DCD      0x40004800
                  |L1.128|
                          DCD      0x40004c00
                  |L1.132|
                          DCD      0x40005000

                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  USART_ClearITPendingBit PROC
;;;1029     */
;;;1030   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1031   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1032     uint16_t bitpos = 0x00, itmask = 0x00;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;1033     /* Check the parameters */
;;;1034     assert_param(IS_USART_ALL_PERIPH(USARTx));
00000c  4922              LDR      r1,|L2.152|
00000e  428c              CMP      r4,r1
000010  d00b              BEQ      |L2.42|
000012  4922              LDR      r1,|L2.156|
000014  428c              CMP      r4,r1
000016  d008              BEQ      |L2.42|
000018  4921              LDR      r1,|L2.160|
00001a  428c              CMP      r4,r1
00001c  d005              BEQ      |L2.42|
00001e  4921              LDR      r1,|L2.164|
000020  428c              CMP      r4,r1
000022  d002              BEQ      |L2.42|
000024  4920              LDR      r1,|L2.168|
000026  428c              CMP      r4,r1
000028  d101              BNE      |L2.46|
                  |L2.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L2.48|
                  |L2.46|
00002e  2100              MOVS     r1,#0
                  |L2.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;1035     assert_param(IS_USART_CLEAR_IT(USART_IT));
000036  f2406126          MOV      r1,#0x626
00003a  428d              CMP      r5,r1
00003c  d00b              BEQ      |L2.86|
00003e  f2405125          MOV      r1,#0x525
000042  428d              CMP      r5,r1
000044  d007              BEQ      |L2.86|
000046  f6400146          MOV      r1,#0x846
00004a  428d              CMP      r5,r1
00004c  d003              BEQ      |L2.86|
00004e  f640116a          MOV      r1,#0x96a
000052  428d              CMP      r5,r1
000054  d101              BNE      |L2.90|
                  |L2.86|
000056  2101              MOVS     r1,#1
000058  e000              B        |L2.92|
                  |L2.90|
00005a  2100              MOVS     r1,#0
                  |L2.92|
00005c  4608              MOV      r0,r1
00005e  f7fffffe          BL       assert_param
;;;1036     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1037     if (USART_IT == USART_IT_CTS)
000062  f640106a          MOV      r0,#0x96a
000066  4285              CMP      r5,r0
000068  d10e              BNE      |L2.136|
;;;1038     {
;;;1039       assert_param(IS_USART_123_PERIPH(USARTx));
00006a  490b              LDR      r1,|L2.152|
00006c  428c              CMP      r4,r1
00006e  d005              BEQ      |L2.124|
000070  490a              LDR      r1,|L2.156|
000072  428c              CMP      r4,r1
000074  d002              BEQ      |L2.124|
000076  490a              LDR      r1,|L2.160|
000078  428c              CMP      r4,r1
00007a  d101              BNE      |L2.128|
                  |L2.124|
00007c  2101              MOVS     r1,#1
00007e  e000              B        |L2.130|
                  |L2.128|
000080  2100              MOVS     r1,#0
                  |L2.130|
000082  4608              MOV      r0,r1
000084  f7fffffe          BL       assert_param
                  |L2.136|
;;;1040     }   
;;;1041     
;;;1042     bitpos = USART_IT >> 0x08;
000088  122e              ASRS     r6,r5,#8
;;;1043     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
00008a  2001              MOVS     r0,#1
00008c  40b0              LSLS     r0,r0,r6
00008e  b287              UXTH     r7,r0
;;;1044     USARTx->SR = (uint16_t)~itmask;
000090  43f8              MVNS     r0,r7
000092  8020              STRH     r0,[r4,#0]
;;;1045   }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;1046   /**
                          ENDP

                  |L2.152|
                          DCD      0x40013800
                  |L2.156|
                          DCD      0x40004400
                  |L2.160|
                          DCD      0x40004800
                  |L2.164|
                          DCD      0x40004c00
                  |L2.168|
                          DCD      0x40005000

                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=2

                  USART_ClockInit PROC
;;;301      */
;;;302    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;304      uint32_t tmpreg = 0x00;
000006  2600              MOVS     r6,#0
;;;305      /* Check the parameters */
;;;306      assert_param(IS_USART_123_PERIPH(USARTx));
000008  4926              LDR      r1,|L3.164|
00000a  428d              CMP      r5,r1
00000c  d005              BEQ      |L3.26|
00000e  4926              LDR      r1,|L3.168|
000010  428d              CMP      r5,r1
000012  d002              BEQ      |L3.26|
000014  4925              LDR      r1,|L3.172|
000016  428d              CMP      r5,r1
000018  d101              BNE      |L3.30|
                  |L3.26|
00001a  2101              MOVS     r1,#1
00001c  e000              B        |L3.32|
                  |L3.30|
00001e  2100              MOVS     r1,#0
                  |L3.32|
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       assert_param
;;;307      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
000026  8821              LDRH     r1,[r4,#0]
000028  b119              CBZ      r1,|L3.50|
00002a  8821              LDRH     r1,[r4,#0]
00002c  f5b16f00          CMP      r1,#0x800
000030  d101              BNE      |L3.54|
                  |L3.50|
000032  2101              MOVS     r1,#1
000034  e000              B        |L3.56|
                  |L3.54|
000036  2100              MOVS     r1,#0
                  |L3.56|
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       assert_param
;;;308      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
00003e  8861              LDRH     r1,[r4,#2]
000040  b119              CBZ      r1,|L3.74|
000042  8861              LDRH     r1,[r4,#2]
000044  f5b16f80          CMP      r1,#0x400
000048  d101              BNE      |L3.78|
                  |L3.74|
00004a  2101              MOVS     r1,#1
00004c  e000              B        |L3.80|
                  |L3.78|
00004e  2100              MOVS     r1,#0
                  |L3.80|
000050  4608              MOV      r0,r1
000052  f7fffffe          BL       assert_param
;;;309      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
000056  88a1              LDRH     r1,[r4,#4]
000058  b119              CBZ      r1,|L3.98|
00005a  88a1              LDRH     r1,[r4,#4]
00005c  f5b17f00          CMP      r1,#0x200
000060  d101              BNE      |L3.102|
                  |L3.98|
000062  2101              MOVS     r1,#1
000064  e000              B        |L3.104|
                  |L3.102|
000066  2100              MOVS     r1,#0
                  |L3.104|
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       assert_param
;;;310      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
00006e  88e1              LDRH     r1,[r4,#6]
000070  b119              CBZ      r1,|L3.122|
000072  88e1              LDRH     r1,[r4,#6]
000074  f5b17f80          CMP      r1,#0x100
000078  d101              BNE      |L3.126|
                  |L3.122|
00007a  2101              MOVS     r1,#1
00007c  e000              B        |L3.128|
                  |L3.126|
00007e  2100              MOVS     r1,#0
                  |L3.128|
000080  4608              MOV      r0,r1
000082  f7fffffe          BL       assert_param
;;;311      
;;;312    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;313      tmpreg = USARTx->CR2;
000086  8a2e              LDRH     r6,[r5,#0x10]
;;;314      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;315      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000088  f24f00ff          MOV      r0,#0xf0ff
00008c  4006              ANDS     r6,r6,r0
;;;316      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;317      /* Set CLKEN bit according to USART_Clock value */
;;;318      /* Set CPOL bit according to USART_CPOL value */
;;;319      /* Set CPHA bit according to USART_CPHA value */
;;;320      /* Set LBCL bit according to USART_LastBit value */
;;;321      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00008e  8820              LDRH     r0,[r4,#0]
000090  8861              LDRH     r1,[r4,#2]
000092  4308              ORRS     r0,r0,r1
000094  88a1              LDRH     r1,[r4,#4]
000096  4308              ORRS     r0,r0,r1
000098  88e1              LDRH     r1,[r4,#6]
00009a  4308              ORRS     r0,r0,r1
00009c  4306              ORRS     r6,r6,r0
;;;322                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;323      /* Write to USART CR2 */
;;;324      USARTx->CR2 = (uint16_t)tmpreg;
00009e  822e              STRH     r6,[r5,#0x10]
;;;325    }
0000a0  bd70              POP      {r4-r6,pc}
;;;326    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      0x40013800
                  |L3.168|
                          DCD      0x40004400
                  |L3.172|
                          DCD      0x40004800

                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;332      */
;;;333    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;334    {
;;;335      /* USART_ClockInitStruct members default value */
;;;336      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;337      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;338      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;339      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;340    }
00000a  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=2

                  USART_Cmd PROC
;;;350      */
;;;351    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;352    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;353      /* Check the parameters */
;;;354      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L5.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L5.36|
00000c  4914              LDR      r1,|L5.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L5.36|
000012  4914              LDR      r1,|L5.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L5.36|
000018  4913              LDR      r1,|L5.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L5.36|
00001e  4913              LDR      r1,|L5.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L5.40|
                  |L5.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L5.42|
                  |L5.40|
000028  2100              MOVS     r1,#0
                  |L5.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;355      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L5.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L5.58|
                  |L5.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L5.60|
                  |L5.58|
00003a  2100              MOVS     r1,#0
                  |L5.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;356      
;;;357      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L5.78|
;;;358      {
;;;359        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;360        USARTx->CR1 |= CR1_UE_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4405000          ORR      r0,r0,#0x2000
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e004              B        |L5.88|
                  |L5.78|
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;365        USARTx->CR1 &= CR1_UE_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f64d71ff          MOV      r1,#0xdfff
000054  4008              ANDS     r0,r0,r1
000056  81a0              STRH     r0,[r4,#0xc]
                  |L5.88|
;;;366      }
;;;367    }
000058  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      0x40013800
                  |L5.96|
                          DCD      0x40004400
                  |L5.100|
                          DCD      0x40004800
                  |L5.104|
                          DCD      0x40004c00
                  |L5.108|
                          DCD      0x40005000

                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=2

                  USART_DMACmd PROC
;;;447      */
;;;448    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;449    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;450      /* Check the parameters */
;;;451      assert_param(IS_USART_ALL_PERIPH(USARTx));
000008  4918              LDR      r1,|L6.108|
00000a  428c              CMP      r4,r1
00000c  d00b              BEQ      |L6.38|
00000e  4918              LDR      r1,|L6.112|
000010  428c              CMP      r4,r1
000012  d008              BEQ      |L6.38|
000014  4917              LDR      r1,|L6.116|
000016  428c              CMP      r4,r1
000018  d005              BEQ      |L6.38|
00001a  4917              LDR      r1,|L6.120|
00001c  428c              CMP      r4,r1
00001e  d002              BEQ      |L6.38|
000020  4916              LDR      r1,|L6.124|
000022  428c              CMP      r4,r1
000024  d101              BNE      |L6.42|
                  |L6.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L6.44|
                  |L6.42|
00002a  2100              MOVS     r1,#0
                  |L6.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;452      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
000032  f64f713f          MOV      r1,#0xff3f
000036  4029              ANDS     r1,r1,r5
000038  b911              CBNZ     r1,|L6.64|
00003a  b10d              CBZ      r5,|L6.64|
00003c  2101              MOVS     r1,#1
00003e  e000              B        |L6.66|
                  |L6.64|
000040  2100              MOVS     r1,#0
                  |L6.66|
000042  4608              MOV      r0,r1
000044  f7fffffe          BL       assert_param
;;;453      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000048  b10e              CBZ      r6,|L6.78|
00004a  2e01              CMP      r6,#1
00004c  d101              BNE      |L6.82|
                  |L6.78|
00004e  2101              MOVS     r1,#1
000050  e000              B        |L6.84|
                  |L6.82|
000052  2100              MOVS     r1,#0
                  |L6.84|
000054  4608              MOV      r0,r1
000056  f7fffffe          BL       assert_param
;;;454      if (NewState != DISABLE)
00005a  b11e              CBZ      r6,|L6.100|
;;;455      {
;;;456        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;457           DMAR bits in the USART CR3 register */
;;;458        USARTx->CR3 |= USART_DMAReq;
00005c  8aa0              LDRH     r0,[r4,#0x14]
00005e  4328              ORRS     r0,r0,r5
000060  82a0              STRH     r0,[r4,#0x14]
000062  e002              B        |L6.106|
                  |L6.100|
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;463           DMAR bits in the USART CR3 register */
;;;464        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000064  8aa0              LDRH     r0,[r4,#0x14]
000066  43a8              BICS     r0,r0,r5
000068  82a0              STRH     r0,[r4,#0x14]
                  |L6.106|
;;;465      }
;;;466    }
00006a  bd70              POP      {r4-r6,pc}
;;;467    
                          ENDP

                  |L6.108|
                          DCD      0x40013800
                  |L6.112|
                          DCD      0x40004400
                  |L6.116|
                          DCD      0x40004800
                  |L6.120|
                          DCD      0x40004c00
                  |L6.124|
                          DCD      0x40005000

                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;129      */
;;;130    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132      /* Check the parameters */
;;;133      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  492a              LDR      r1,|L7.176|
000006  428c              CMP      r4,r1
000008  d00b              BEQ      |L7.34|
00000a  492a              LDR      r1,|L7.180|
00000c  428c              CMP      r4,r1
00000e  d008              BEQ      |L7.34|
000010  4929              LDR      r1,|L7.184|
000012  428c              CMP      r4,r1
000014  d005              BEQ      |L7.34|
000016  4929              LDR      r1,|L7.188|
000018  428c              CMP      r4,r1
00001a  d002              BEQ      |L7.34|
00001c  4928              LDR      r1,|L7.192|
00001e  428c              CMP      r4,r1
000020  d101              BNE      |L7.38|
                  |L7.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L7.40|
                  |L7.38|
000026  2100              MOVS     r1,#0
                  |L7.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;134    
;;;135      if (USARTx == USART1)
00002e  4820              LDR      r0,|L7.176|
000030  4284              CMP      r4,r0
000032  d109              BNE      |L7.72|
;;;136      {
;;;137        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000034  2101              MOVS     r1,#1
000036  0388              LSLS     r0,r1,#14
000038  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;138        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
00003c  2100              MOVS     r1,#0
00003e  f44f4080          MOV      r0,#0x4000
000042  f7fffffe          BL       RCC_APB2PeriphResetCmd
000046  e032              B        |L7.174|
                  |L7.72|
;;;139      }
;;;140      else if (USARTx == USART2)
000048  481a              LDR      r0,|L7.180|
00004a  4284              CMP      r4,r0
00004c  d109              BNE      |L7.98|
;;;141      {
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00004e  2101              MOVS     r1,#1
000050  0448              LSLS     r0,r1,#17
000052  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000056  2100              MOVS     r1,#0
000058  f44f3000          MOV      r0,#0x20000
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000060  e025              B        |L7.174|
                  |L7.98|
;;;144      }
;;;145      else if (USARTx == USART3)
000062  4815              LDR      r0,|L7.184|
000064  4284              CMP      r4,r0
000066  d109              BNE      |L7.124|
;;;146      {
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000068  2101              MOVS     r1,#1
00006a  0488              LSLS     r0,r1,#18
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000070  2100              MOVS     r1,#0
000072  f44f2080          MOV      r0,#0x40000
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e018              B        |L7.174|
                  |L7.124|
;;;149      }    
;;;150      else if (USARTx == UART4)
00007c  480f              LDR      r0,|L7.188|
00007e  4284              CMP      r4,r0
000080  d109              BNE      |L7.150|
;;;151      {
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000082  2101              MOVS     r1,#1
000084  04c8              LSLS     r0,r1,#19
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  f44f2000          MOV      r0,#0x80000
000090  f7fffffe          BL       RCC_APB1PeriphResetCmd
000094  e00b              B        |L7.174|
                  |L7.150|
;;;154      }    
;;;155      else
;;;156      {
;;;157        if (USARTx == UART5)
000096  480a              LDR      r0,|L7.192|
000098  4284              CMP      r4,r0
00009a  d108              BNE      |L7.174|
;;;158        { 
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
00009c  2101              MOVS     r1,#1
00009e  0508              LSLS     r0,r1,#20
0000a0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
0000a4  2100              MOVS     r1,#0
0000a6  f44f1080          MOV      r0,#0x100000
0000aa  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L7.174|
;;;161        }
;;;162      }
;;;163    }
0000ae  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  |L7.176|
                          DCD      0x40013800
                  |L7.180|
                          DCD      0x40004400
                  |L7.184|
                          DCD      0x40004800
                  |L7.188|
                          DCD      0x40004c00
                  |L7.192|
                          DCD      0x40005000

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  USART_GetFlagStatus PROC
;;;873      */
;;;874    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;875    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;876      FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;877      /* Check the parameters */
;;;878      assert_param(IS_USART_ALL_PERIPH(USARTx));
000008  4925              LDR      r1,|L8.160|
00000a  428d              CMP      r5,r1
00000c  d00b              BEQ      |L8.38|
00000e  4925              LDR      r1,|L8.164|
000010  428d              CMP      r5,r1
000012  d008              BEQ      |L8.38|
000014  4924              LDR      r1,|L8.168|
000016  428d              CMP      r5,r1
000018  d005              BEQ      |L8.38|
00001a  4924              LDR      r1,|L8.172|
00001c  428d              CMP      r5,r1
00001e  d002              BEQ      |L8.38|
000020  4923              LDR      r1,|L8.176|
000022  428d              CMP      r5,r1
000024  d101              BNE      |L8.42|
                  |L8.38|
000026  2101              MOVS     r1,#1
000028  e000              B        |L8.44|
                  |L8.42|
00002a  2100              MOVS     r1,#0
                  |L8.44|
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       assert_param
;;;879      assert_param(IS_USART_FLAG(USART_FLAG));
000032  2c01              CMP      r4,#1
000034  d013              BEQ      |L8.94|
000036  2c80              CMP      r4,#0x80
000038  d011              BEQ      |L8.94|
00003a  2c40              CMP      r4,#0x40
00003c  d00f              BEQ      |L8.94|
00003e  2c20              CMP      r4,#0x20
000040  d00d              BEQ      |L8.94|
000042  2c10              CMP      r4,#0x10
000044  d00b              BEQ      |L8.94|
000046  f5b47f80          CMP      r4,#0x100
00004a  d008              BEQ      |L8.94|
00004c  f5b47f00          CMP      r4,#0x200
000050  d005              BEQ      |L8.94|
000052  2c08              CMP      r4,#8
000054  d003              BEQ      |L8.94|
000056  2c04              CMP      r4,#4
000058  d001              BEQ      |L8.94|
00005a  2c02              CMP      r4,#2
00005c  d101              BNE      |L8.98|
                  |L8.94|
00005e  2101              MOVS     r1,#1
000060  e000              B        |L8.100|
                  |L8.98|
000062  2100              MOVS     r1,#0
                  |L8.100|
000064  4608              MOV      r0,r1
000066  f7fffffe          BL       assert_param
;;;880      /* The CTS flag is not available for UART4 and UART5 */
;;;881      if (USART_FLAG == USART_FLAG_CTS)
00006a  f5b47f00          CMP      r4,#0x200
00006e  d10e              BNE      |L8.142|
;;;882      {
;;;883        assert_param(IS_USART_123_PERIPH(USARTx));
000070  490b              LDR      r1,|L8.160|
000072  428d              CMP      r5,r1
000074  d005              BEQ      |L8.130|
000076  490b              LDR      r1,|L8.164|
000078  428d              CMP      r5,r1
00007a  d002              BEQ      |L8.130|
00007c  490a              LDR      r1,|L8.168|
00007e  428d              CMP      r5,r1
000080  d101              BNE      |L8.134|
                  |L8.130|
000082  2101              MOVS     r1,#1
000084  e000              B        |L8.136|
                  |L8.134|
000086  2100              MOVS     r1,#0
                  |L8.136|
000088  4608              MOV      r0,r1
00008a  f7fffffe          BL       assert_param
                  |L8.142|
;;;884      }  
;;;885      
;;;886      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00008e  8828              LDRH     r0,[r5,#0]
000090  4020              ANDS     r0,r0,r4
000092  b108              CBZ      r0,|L8.152|
;;;887      {
;;;888        bitstatus = SET;
000094  2601              MOVS     r6,#1
000096  e000              B        |L8.154|
                  |L8.152|
;;;889      }
;;;890      else
;;;891      {
;;;892        bitstatus = RESET;
000098  2600              MOVS     r6,#0
                  |L8.154|
;;;893      }
;;;894      return bitstatus;
00009a  4630              MOV      r0,r6
;;;895    }
00009c  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP

00009e  0000              DCW      0x0000
                  |L8.160|
                          DCD      0x40013800
                  |L8.164|
                          DCD      0x40004400
                  |L8.168|
                          DCD      0x40004800
                  |L8.172|
                          DCD      0x40004c00
                  |L8.176|
                          DCD      0x40005000

                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=2

                  USART_GetITStatus PROC
;;;955      */
;;;956    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;957    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;958      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000008  2700              MOVS     r7,#0
00000a  2600              MOVS     r6,#0
00000c  46b0              MOV      r8,r6
;;;959      ITStatus bitstatus = RESET;
00000e  46b1              MOV      r9,r6
;;;960      /* Check the parameters */
;;;961      assert_param(IS_USART_ALL_PERIPH(USARTx));
000010  493a              LDR      r1,|L9.252|
000012  428d              CMP      r5,r1
000014  d00b              BEQ      |L9.46|
000016  493a              LDR      r1,|L9.256|
000018  428d              CMP      r5,r1
00001a  d008              BEQ      |L9.46|
00001c  4939              LDR      r1,|L9.260|
00001e  428d              CMP      r5,r1
000020  d005              BEQ      |L9.46|
000022  4939              LDR      r1,|L9.264|
000024  428d              CMP      r5,r1
000026  d002              BEQ      |L9.46|
000028  4938              LDR      r1,|L9.268|
00002a  428d              CMP      r5,r1
00002c  d101              BNE      |L9.50|
                  |L9.46|
00002e  2101              MOVS     r1,#1
000030  e000              B        |L9.52|
                  |L9.50|
000032  2100              MOVS     r1,#0
                  |L9.52|
000034  4608              MOV      r0,r1
000036  f7fffffe          BL       assert_param
;;;962      assert_param(IS_USART_GET_IT(USART_IT));
00003a  2c28              CMP      r4,#0x28
00003c  d020              BEQ      |L9.128|
00003e  f2407127          MOV      r1,#0x727
000042  428c              CMP      r4,r1
000044  d01c              BEQ      |L9.128|
000046  f2406126          MOV      r1,#0x626
00004a  428c              CMP      r4,r1
00004c  d018              BEQ      |L9.128|
00004e  f2405125          MOV      r1,#0x525
000052  428c              CMP      r4,r1
000054  d014              BEQ      |L9.128|
000056  f2404124          MOV      r1,#0x424
00005a  428c              CMP      r4,r1
00005c  d010              BEQ      |L9.128|
00005e  f6400146          MOV      r1,#0x846
000062  428c              CMP      r4,r1
000064  d00c              BEQ      |L9.128|
000066  f640116a          MOV      r1,#0x96a
00006a  428c              CMP      r4,r1
00006c  d008              BEQ      |L9.128|
00006e  f5b47f58          CMP      r4,#0x360
000072  d005              BEQ      |L9.128|
000074  f5b47f18          CMP      r4,#0x260
000078  d002              BEQ      |L9.128|
00007a  f5b47fb0          CMP      r4,#0x160
00007e  d101              BNE      |L9.132|
                  |L9.128|
000080  2101              MOVS     r1,#1
000082  e000              B        |L9.134|
                  |L9.132|
000084  2100              MOVS     r1,#0
                  |L9.134|
000086  4608              MOV      r0,r1
000088  f7fffffe          BL       assert_param
;;;963      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;964      if (USART_IT == USART_IT_CTS)
00008c  f640106a          MOV      r0,#0x96a
000090  4284              CMP      r4,r0
000092  d10e              BNE      |L9.178|
;;;965      {
;;;966        assert_param(IS_USART_123_PERIPH(USARTx));
000094  4919              LDR      r1,|L9.252|
000096  428d              CMP      r5,r1
000098  d005              BEQ      |L9.166|
00009a  4919              LDR      r1,|L9.256|
00009c  428d              CMP      r5,r1
00009e  d002              BEQ      |L9.166|
0000a0  4918              LDR      r1,|L9.260|
0000a2  428d              CMP      r5,r1
0000a4  d101              BNE      |L9.170|
                  |L9.166|
0000a6  2101              MOVS     r1,#1
0000a8  e000              B        |L9.172|
                  |L9.170|
0000aa  2100              MOVS     r1,#0
                  |L9.172|
0000ac  4608              MOV      r0,r1
0000ae  f7fffffe          BL       assert_param
                  |L9.178|
;;;967      }   
;;;968      
;;;969      /* Get the USART register index */
;;;970      usartreg = (((uint8_t)USART_IT) >> 0x05);
0000b2  f3c41842          UBFX     r8,r4,#5,#3
;;;971      /* Get the interrupt position */
;;;972      itmask = USART_IT & IT_Mask;
0000b6  f004061f          AND      r6,r4,#0x1f
;;;973      itmask = (uint32_t)0x01 << itmask;
0000ba  2001              MOVS     r0,#1
0000bc  fa00f606          LSL      r6,r0,r6
;;;974      
;;;975      if (usartreg == 0x01) /* The IT  is in CR1 register */
0000c0  f1b80f01          CMP      r8,#1
0000c4  d102              BNE      |L9.204|
;;;976      {
;;;977        itmask &= USARTx->CR1;
0000c6  89a8              LDRH     r0,[r5,#0xc]
0000c8  4006              ANDS     r6,r6,r0
0000ca  e007              B        |L9.220|
                  |L9.204|
;;;978      }
;;;979      else if (usartreg == 0x02) /* The IT  is in CR2 register */
0000cc  f1b80f02          CMP      r8,#2
0000d0  d102              BNE      |L9.216|
;;;980      {
;;;981        itmask &= USARTx->CR2;
0000d2  8a28              LDRH     r0,[r5,#0x10]
0000d4  4006              ANDS     r6,r6,r0
0000d6  e001              B        |L9.220|
                  |L9.216|
;;;982      }
;;;983      else /* The IT  is in CR3 register */
;;;984      {
;;;985        itmask &= USARTx->CR3;
0000d8  8aa8              LDRH     r0,[r5,#0x14]
0000da  4006              ANDS     r6,r6,r0
                  |L9.220|
;;;986      }
;;;987      
;;;988      bitpos = USART_IT >> 0x08;
0000dc  1227              ASRS     r7,r4,#8
;;;989      bitpos = (uint32_t)0x01 << bitpos;
0000de  2001              MOVS     r0,#1
0000e0  fa00f707          LSL      r7,r0,r7
;;;990      bitpos &= USARTx->SR;
0000e4  8828              LDRH     r0,[r5,#0]
0000e6  4007              ANDS     r7,r7,r0
;;;991      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
0000e8  b11e              CBZ      r6,|L9.242|
0000ea  b117              CBZ      r7,|L9.242|
;;;992      {
;;;993        bitstatus = SET;
0000ec  f04f0901          MOV      r9,#1
0000f0  e001              B        |L9.246|
                  |L9.242|
;;;994      }
;;;995      else
;;;996      {
;;;997        bitstatus = RESET;
0000f2  f04f0900          MOV      r9,#0
                  |L9.246|
;;;998      }
;;;999      
;;;1000     return bitstatus;  
0000f6  4648              MOV      r0,r9
;;;1001   }
0000f8  e8bd87f0          POP      {r4-r10,pc}
;;;1002   
                          ENDP

                  |L9.252|
                          DCD      0x40013800
                  |L9.256|
                          DCD      0x40004400
                  |L9.260|
                          DCD      0x40004800
                  |L9.264|
                          DCD      0x40004c00
                  |L9.268|
                          DCD      0x40005000

                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=2

                  USART_HalfDuplexCmd PROC
;;;730      */
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;732    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L10.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L10.36|
00000c  4914              LDR      r1,|L10.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L10.36|
000012  4914              LDR      r1,|L10.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L10.36|
000018  4913              LDR      r1,|L10.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L10.36|
00001e  4913              LDR      r1,|L10.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L10.40|
                  |L10.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L10.42|
                  |L10.40|
000028  2100              MOVS     r1,#0
                  |L10.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L10.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L10.58|
                  |L10.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L10.60|
                  |L10.58|
00003a  2100              MOVS     r1,#0
                  |L10.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;736      
;;;737      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L10.78|
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400008          ORR      r0,r0,#8
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L10.88|
                  |L10.78|
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f64f71f7          MOV      r1,#0xfff7
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L10.88|
;;;746      }
;;;747    }
000058  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      0x40013800
                  |L10.96|
                          DCD      0x40004400
                  |L10.100|
                          DCD      0x40004800
                  |L10.104|
                          DCD      0x40004c00
                  |L10.108|
                          DCD      0x40005000

                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=2

                  USART_ITConfig PROC
;;;387      */
;;;388    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;389    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;390      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
00000a  f04f0800          MOV      r8,#0
00000e  46c2              MOV      r10,r8
000010  46c1              MOV      r9,r8
;;;391      uint32_t usartxbase = 0x00;
000012  2600              MOVS     r6,#0
;;;392      /* Check the parameters */
;;;393      assert_param(IS_USART_ALL_PERIPH(USARTx));
000014  4938              LDR      r1,|L11.248|
000016  428d              CMP      r5,r1
000018  d00b              BEQ      |L11.50|
00001a  4938              LDR      r1,|L11.252|
00001c  428d              CMP      r5,r1
00001e  d008              BEQ      |L11.50|
000020  4937              LDR      r1,|L11.256|
000022  428d              CMP      r5,r1
000024  d005              BEQ      |L11.50|
000026  4937              LDR      r1,|L11.260|
000028  428d              CMP      r5,r1
00002a  d002              BEQ      |L11.50|
00002c  4936              LDR      r1,|L11.264|
00002e  428d              CMP      r5,r1
000030  d101              BNE      |L11.54|
                  |L11.50|
000032  2101              MOVS     r1,#1
000034  e000              B        |L11.56|
                  |L11.54|
000036  2100              MOVS     r1,#0
                  |L11.56|
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       assert_param
;;;394      assert_param(IS_USART_CONFIG_IT(USART_IT));
00003e  2c28              CMP      r4,#0x28
000040  d019              BEQ      |L11.118|
000042  f2407127          MOV      r1,#0x727
000046  428c              CMP      r4,r1
000048  d015              BEQ      |L11.118|
00004a  f2406126          MOV      r1,#0x626
00004e  428c              CMP      r4,r1
000050  d011              BEQ      |L11.118|
000052  f2405125          MOV      r1,#0x525
000056  428c              CMP      r4,r1
000058  d00d              BEQ      |L11.118|
00005a  f2404124          MOV      r1,#0x424
00005e  428c              CMP      r4,r1
000060  d009              BEQ      |L11.118|
000062  f6400146          MOV      r1,#0x846
000066  428c              CMP      r4,r1
000068  d005              BEQ      |L11.118|
00006a  f640116a          MOV      r1,#0x96a
00006e  428c              CMP      r4,r1
000070  d001              BEQ      |L11.118|
000072  2c60              CMP      r4,#0x60
000074  d101              BNE      |L11.122|
                  |L11.118|
000076  2101              MOVS     r1,#1
000078  e000              B        |L11.124|
                  |L11.122|
00007a  2100              MOVS     r1,#0
                  |L11.124|
00007c  4608              MOV      r0,r1
00007e  f7fffffe          BL       assert_param
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
000082  b10f              CBZ      r7,|L11.136|
000084  2f01              CMP      r7,#1
000086  d101              BNE      |L11.140|
                  |L11.136|
000088  2101              MOVS     r1,#1
00008a  e000              B        |L11.142|
                  |L11.140|
00008c  2100              MOVS     r1,#0
                  |L11.142|
00008e  4608              MOV      r0,r1
000090  f7fffffe          BL       assert_param
;;;396      /* The CTS interrupt is not available for UART4 and UART5 */
;;;397      if (USART_IT == USART_IT_CTS)
000094  f640106a          MOV      r0,#0x96a
000098  4284              CMP      r4,r0
00009a  d10e              BNE      |L11.186|
;;;398      {
;;;399        assert_param(IS_USART_123_PERIPH(USARTx));
00009c  4916              LDR      r1,|L11.248|
00009e  428d              CMP      r5,r1
0000a0  d005              BEQ      |L11.174|
0000a2  4916              LDR      r1,|L11.252|
0000a4  428d              CMP      r5,r1
0000a6  d002              BEQ      |L11.174|
0000a8  4915              LDR      r1,|L11.256|
0000aa  428d              CMP      r5,r1
0000ac  d101              BNE      |L11.178|
                  |L11.174|
0000ae  2101              MOVS     r1,#1
0000b0  e000              B        |L11.180|
                  |L11.178|
0000b2  2100              MOVS     r1,#0
                  |L11.180|
0000b4  4608              MOV      r0,r1
0000b6  f7fffffe          BL       assert_param
                  |L11.186|
;;;400      }   
;;;401      
;;;402      usartxbase = (uint32_t)USARTx;
0000ba  462e              MOV      r6,r5
;;;403    
;;;404      /* Get the USART register index */
;;;405      usartreg = (((uint8_t)USART_IT) >> 0x05);
0000bc  f3c41842          UBFX     r8,r4,#5,#3
;;;406    
;;;407      /* Get the interrupt position */
;;;408      itpos = USART_IT & IT_Mask;
0000c0  f0040a1f          AND      r10,r4,#0x1f
;;;409      itmask = (((uint32_t)0x01) << itpos);
0000c4  2001              MOVS     r0,#1
0000c6  fa00f90a          LSL      r9,r0,r10
;;;410        
;;;411      if (usartreg == 0x01) /* The IT is in CR1 register */
0000ca  f1b80f01          CMP      r8,#1
0000ce  d101              BNE      |L11.212|
;;;412      {
;;;413        usartxbase += 0x0C;
0000d0  360c              ADDS     r6,r6,#0xc
0000d2  e005              B        |L11.224|
                  |L11.212|
;;;414      }
;;;415      else if (usartreg == 0x02) /* The IT is in CR2 register */
0000d4  f1b80f02          CMP      r8,#2
0000d8  d101              BNE      |L11.222|
;;;416      {
;;;417        usartxbase += 0x10;
0000da  3610              ADDS     r6,r6,#0x10
0000dc  e000              B        |L11.224|
                  |L11.222|
;;;418      }
;;;419      else /* The IT is in CR3 register */
;;;420      {
;;;421        usartxbase += 0x14; 
0000de  3614              ADDS     r6,r6,#0x14
                  |L11.224|
;;;422      }
;;;423      if (NewState != DISABLE)
0000e0  b127              CBZ      r7,|L11.236|
;;;424      {
;;;425        *(__IO uint32_t*)usartxbase  |= itmask;
0000e2  6830              LDR      r0,[r6,#0]
0000e4  ea400009          ORR      r0,r0,r9
0000e8  6030              STR      r0,[r6,#0]
0000ea  e003              B        |L11.244|
                  |L11.236|
;;;426      }
;;;427      else
;;;428      {
;;;429        *(__IO uint32_t*)usartxbase &= ~itmask;
0000ec  6830              LDR      r0,[r6,#0]
0000ee  ea200009          BIC      r0,r0,r9
0000f2  6030              STR      r0,[r6,#0]
                  |L11.244|
;;;430      }
;;;431    }
0000f4  e8bd87f0          POP      {r4-r10,pc}
;;;432    
                          ENDP

                  |L11.248|
                          DCD      0x40013800
                  |L11.252|
                          DCD      0x40004400
                  |L11.256|
                          DCD      0x40004800
                  |L11.260|
                          DCD      0x40004c00
                  |L11.264|
                          DCD      0x40005000

                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;175      */
;;;176    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;177    {
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;178      uint32_t tmpreg = 0x00, apbclock = 0x00;
00000a  2600              MOVS     r6,#0
00000c  46b2              MOV      r10,r6
;;;179      uint32_t integerdivider = 0x00;
00000e  bf00              NOP      
;;;180      uint32_t fractionaldivider = 0x00;
000010  46b1              MOV      r9,r6
;;;181      uint32_t usartxbase = 0;
000012  2700              MOVS     r7,#0
;;;182      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_USART_ALL_PERIPH(USARTx));
000014  496f              LDR      r1,|L12.468|
000016  428d              CMP      r5,r1
000018  d00b              BEQ      |L12.50|
00001a  496f              LDR      r1,|L12.472|
00001c  428d              CMP      r5,r1
00001e  d008              BEQ      |L12.50|
000020  496e              LDR      r1,|L12.476|
000022  428d              CMP      r5,r1
000024  d005              BEQ      |L12.50|
000026  496e              LDR      r1,|L12.480|
000028  428d              CMP      r5,r1
00002a  d002              BEQ      |L12.50|
00002c  496d              LDR      r1,|L12.484|
00002e  428d              CMP      r5,r1
000030  d101              BNE      |L12.54|
                  |L12.50|
000032  2101              MOVS     r1,#1
000034  e000              B        |L12.56|
                  |L12.54|
000036  2100              MOVS     r1,#0
                  |L12.56|
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       assert_param
;;;185      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
00003e  6821              LDR      r1,[r4,#0]
000040  b129              CBZ      r1,|L12.78|
000042  4a69              LDR      r2,|L12.488|
000044  6821              LDR      r1,[r4,#0]
000046  4291              CMP      r1,r2
000048  d201              BCS      |L12.78|
00004a  2101              MOVS     r1,#1
00004c  e000              B        |L12.80|
                  |L12.78|
00004e  2100              MOVS     r1,#0
                  |L12.80|
000050  4608              MOV      r0,r1
000052  f7fffffe          BL       assert_param
;;;186      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
000056  88a1              LDRH     r1,[r4,#4]
000058  b119              CBZ      r1,|L12.98|
00005a  88a1              LDRH     r1,[r4,#4]
00005c  f5b15f80          CMP      r1,#0x1000
000060  d101              BNE      |L12.102|
                  |L12.98|
000062  2101              MOVS     r1,#1
000064  e000              B        |L12.104|
                  |L12.102|
000066  2100              MOVS     r1,#0
                  |L12.104|
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       assert_param
;;;187      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
00006e  88e1              LDRH     r1,[r4,#6]
000070  b159              CBZ      r1,|L12.138|
000072  88e1              LDRH     r1,[r4,#6]
000074  f5b15f80          CMP      r1,#0x1000
000078  d007              BEQ      |L12.138|
00007a  88e1              LDRH     r1,[r4,#6]
00007c  f5b15f00          CMP      r1,#0x2000
000080  d003              BEQ      |L12.138|
000082  88e1              LDRH     r1,[r4,#6]
000084  f5b15f40          CMP      r1,#0x3000
000088  d101              BNE      |L12.142|
                  |L12.138|
00008a  2101              MOVS     r1,#1
00008c  e000              B        |L12.144|
                  |L12.142|
00008e  2100              MOVS     r1,#0
                  |L12.144|
000090  4608              MOV      r0,r1
000092  f7fffffe          BL       assert_param
;;;188      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
000096  8921              LDRH     r1,[r4,#8]
000098  b139              CBZ      r1,|L12.170|
00009a  8921              LDRH     r1,[r4,#8]
00009c  f5b16f80          CMP      r1,#0x400
0000a0  d003              BEQ      |L12.170|
0000a2  8921              LDRH     r1,[r4,#8]
0000a4  f5b16fc0          CMP      r1,#0x600
0000a8  d101              BNE      |L12.174|
                  |L12.170|
0000aa  2101              MOVS     r1,#1
0000ac  e000              B        |L12.176|
                  |L12.174|
0000ae  2100              MOVS     r1,#0
                  |L12.176|
0000b0  4608              MOV      r0,r1
0000b2  f7fffffe          BL       assert_param
;;;189      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
0000b6  8961              LDRH     r1,[r4,#0xa]
0000b8  f64f72f3          MOV      r2,#0xfff3
0000bc  4011              ANDS     r1,r1,r2
0000be  b919              CBNZ     r1,|L12.200|
0000c0  8961              LDRH     r1,[r4,#0xa]
0000c2  b109              CBZ      r1,|L12.200|
0000c4  2101              MOVS     r1,#1
0000c6  e000              B        |L12.202|
                  |L12.200|
0000c8  2100              MOVS     r1,#0
                  |L12.202|
0000ca  4608              MOV      r0,r1
0000cc  f7fffffe          BL       assert_param
;;;190      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
0000d0  89a1              LDRH     r1,[r4,#0xc]
0000d2  b159              CBZ      r1,|L12.236|
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  f5b17f80          CMP      r1,#0x100
0000da  d007              BEQ      |L12.236|
0000dc  89a1              LDRH     r1,[r4,#0xc]
0000de  f5b17f00          CMP      r1,#0x200
0000e2  d003              BEQ      |L12.236|
0000e4  89a1              LDRH     r1,[r4,#0xc]
0000e6  f5b17f40          CMP      r1,#0x300
0000ea  d101              BNE      |L12.240|
                  |L12.236|
0000ec  2101              MOVS     r1,#1
0000ee  e000              B        |L12.242|
                  |L12.240|
0000f0  2100              MOVS     r1,#0
                  |L12.242|
0000f2  4608              MOV      r0,r1
0000f4  f7fffffe          BL       assert_param
;;;191      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;192      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
0000f8  89a0              LDRH     r0,[r4,#0xc]
0000fa  b170              CBZ      r0,|L12.282|
;;;193      {
;;;194        assert_param(IS_USART_123_PERIPH(USARTx));
0000fc  4935              LDR      r1,|L12.468|
0000fe  428d              CMP      r5,r1
000100  d005              BEQ      |L12.270|
000102  4935              LDR      r1,|L12.472|
000104  428d              CMP      r5,r1
000106  d002              BEQ      |L12.270|
000108  4934              LDR      r1,|L12.476|
00010a  428d              CMP      r5,r1
00010c  d101              BNE      |L12.274|
                  |L12.270|
00010e  2101              MOVS     r1,#1
000110  e000              B        |L12.276|
                  |L12.274|
000112  2100              MOVS     r1,#0
                  |L12.276|
000114  4608              MOV      r0,r1
000116  f7fffffe          BL       assert_param
                  |L12.282|
;;;195      }
;;;196    
;;;197      usartxbase = (uint32_t)USARTx;
00011a  462f              MOV      r7,r5
;;;198    
;;;199    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;200      tmpreg = USARTx->CR2;
00011c  8a2e              LDRH     r6,[r5,#0x10]
;;;201      /* Clear STOP[13:12] bits */
;;;202      tmpreg &= CR2_STOP_CLEAR_Mask;
00011e  f64c70ff          MOV      r0,#0xcfff
000122  4006              ANDS     r6,r6,r0
;;;203      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;204      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;205      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000124  88e0              LDRH     r0,[r4,#6]
000126  4306              ORRS     r6,r6,r0
;;;206      
;;;207      /* Write to USART CR2 */
;;;208      USARTx->CR2 = (uint16_t)tmpreg;
000128  822e              STRH     r6,[r5,#0x10]
;;;209    
;;;210    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;211      tmpreg = USARTx->CR1;
00012a  89ae              LDRH     r6,[r5,#0xc]
;;;212      /* Clear M, PCE, PS, TE and RE bits */
;;;213      tmpreg &= CR1_CLEAR_Mask;
00012c  f64e10f3          MOV      r0,#0xe9f3
000130  4006              ANDS     r6,r6,r0
;;;214      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;215      /* Set the M bits according to USART_WordLength value */
;;;216      /* Set PCE and PS bits according to USART_Parity value */
;;;217      /* Set TE and RE bits according to USART_Mode value */
;;;218      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000132  88a0              LDRH     r0,[r4,#4]
000134  8921              LDRH     r1,[r4,#8]
000136  4308              ORRS     r0,r0,r1
000138  8961              LDRH     r1,[r4,#0xa]
00013a  4308              ORRS     r0,r0,r1
00013c  4306              ORRS     r6,r6,r0
;;;219                USART_InitStruct->USART_Mode;
;;;220      /* Write to USART CR1 */
;;;221      USARTx->CR1 = (uint16_t)tmpreg;
00013e  81ae              STRH     r6,[r5,#0xc]
;;;222    
;;;223    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;224      tmpreg = USARTx->CR3;
000140  8aae              LDRH     r6,[r5,#0x14]
;;;225      /* Clear CTSE and RTSE bits */
;;;226      tmpreg &= CR3_CLEAR_Mask;
000142  f64f40ff          MOV      r0,#0xfcff
000146  4006              ANDS     r6,r6,r0
;;;227      /* Configure the USART HFC -------------------------------------------------*/
;;;228      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;229      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000148  89a0              LDRH     r0,[r4,#0xc]
00014a  4306              ORRS     r6,r6,r0
;;;230      /* Write to USART CR3 */
;;;231      USARTx->CR3 = (uint16_t)tmpreg;
00014c  82ae              STRH     r6,[r5,#0x14]
;;;232    
;;;233    /*---------------------------- USART BRR Configuration -----------------------*/
;;;234      /* Configure the USART Baud Rate -------------------------------------------*/
;;;235      RCC_GetClocksFreq(&RCC_ClocksStatus);
00014e  a801              ADD      r0,sp,#4
000150  f7fffffe          BL       RCC_GetClocksFreq
;;;236      if (usartxbase == USART1_BASE)
000154  481f              LDR      r0,|L12.468|
000156  4287              CMP      r7,r0
000158  d102              BNE      |L12.352|
;;;237      {
;;;238        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00015a  f8dda010          LDR      r10,[sp,#0x10]
00015e  e001              B        |L12.356|
                  |L12.352|
;;;239      }
;;;240      else
;;;241      {
;;;242        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000160  f8dda00c          LDR      r10,[sp,#0xc]
                  |L12.356|
;;;243      }
;;;244      
;;;245      /* Determine the integer part */
;;;246      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000164  89a8              LDRH     r0,[r5,#0xc]
000166  f4004000          AND      r0,r0,#0x8000
00016a  b140              CBZ      r0,|L12.382|
;;;247      {
;;;248        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;249        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
00016c  eb0a00ca          ADD      r0,r10,r10,LSL #3
000170  eb00100a          ADD      r0,r0,r10,LSL #4
000174  6821              LDR      r1,[r4,#0]
000176  0049              LSLS     r1,r1,#1
000178  fbb0f8f1          UDIV     r8,r0,r1
00017c  e007              B        |L12.398|
                  |L12.382|
;;;250      }
;;;251      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;252      {
;;;253        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;254        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00017e  eb0a00ca          ADD      r0,r10,r10,LSL #3
000182  eb00100a          ADD      r0,r0,r10,LSL #4
000186  6821              LDR      r1,[r4,#0]
000188  0089              LSLS     r1,r1,#2
00018a  fbb0f8f1          UDIV     r8,r0,r1
                  |L12.398|
;;;255      }
;;;256      tmpreg = (integerdivider / 100) << 4;
00018e  2064              MOVS     r0,#0x64
000190  fbb8f0f0          UDIV     r0,r8,r0
000194  0106              LSLS     r6,r0,#4
;;;257    
;;;258      /* Determine the fractional part */
;;;259      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000196  0930              LSRS     r0,r6,#4
000198  2164              MOVS     r1,#0x64
00019a  fb018910          MLS      r9,r1,r0,r8
;;;260    
;;;261      /* Implement the fractional part in the register */
;;;262      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
00019e  89a8              LDRH     r0,[r5,#0xc]
0001a0  f4004000          AND      r0,r0,#0x8000
0001a4  b140              CBZ      r0,|L12.440|
;;;263      {
;;;264        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
0001a6  2032              MOVS     r0,#0x32
0001a8  eb0000c9          ADD      r0,r0,r9,LSL #3
0001ac  fbb0f0f1          UDIV     r0,r0,r1
0001b0  f0000007          AND      r0,r0,#7
0001b4  4306              ORRS     r6,r6,r0
0001b6  e008              B        |L12.458|
                  |L12.440|
;;;265      }
;;;266      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;267      {
;;;268        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0001b8  2032              MOVS     r0,#0x32
0001ba  eb001009          ADD      r0,r0,r9,LSL #4
0001be  2164              MOVS     r1,#0x64
0001c0  fbb0f0f1          UDIV     r0,r0,r1
0001c4  f000000f          AND      r0,r0,#0xf
0001c8  4306              ORRS     r6,r6,r0
                  |L12.458|
;;;269      }
;;;270      
;;;271      /* Write to USART BRR */
;;;272      USARTx->BRR = (uint16_t)tmpreg;
0001ca  812e              STRH     r6,[r5,#8]
;;;273    }
0001cc  b006              ADD      sp,sp,#0x18
0001ce  e8bd87f0          POP      {r4-r10,pc}
;;;274    
                          ENDP

0001d2  0000              DCW      0x0000
                  |L12.468|
                          DCD      0x40013800
                  |L12.472|
                          DCD      0x40004400
                  |L12.476|
                          DCD      0x40004800
                  |L12.480|
                          DCD      0x40004c00
                  |L12.484|
                          DCD      0x40005000
                  |L12.488|
                          DCD      0x0044aa21

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=2

                  USART_IrDACmd PROC
;;;836      */
;;;837    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;838    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;839      /* Check the parameters */
;;;840      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L13.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L13.36|
00000c  4914              LDR      r1,|L13.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L13.36|
000012  4914              LDR      r1,|L13.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L13.36|
000018  4913              LDR      r1,|L13.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L13.36|
00001e  4913              LDR      r1,|L13.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L13.40|
                  |L13.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L13.42|
                  |L13.40|
000028  2100              MOVS     r1,#0
                  |L13.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;841      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L13.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L13.58|
                  |L13.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L13.60|
                  |L13.58|
00003a  2100              MOVS     r1,#0
                  |L13.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;842        
;;;843      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L13.78|
;;;844      {
;;;845        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;846        USARTx->CR3 |= CR3_IREN_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400002          ORR      r0,r0,#2
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L13.88|
                  |L13.78|
;;;847      }
;;;848      else
;;;849      {
;;;850        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;851        USARTx->CR3 &= CR3_IREN_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f64f71fd          MOV      r1,#0xfffd
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L13.88|
;;;852      }
;;;853    }
000058  bd70              POP      {r4-r6,pc}
;;;854    
                          ENDP

00005a  0000              DCW      0x0000
                  |L13.92|
                          DCD      0x40013800
                  |L13.96|
                          DCD      0x40004400
                  |L13.100|
                          DCD      0x40004800
                  |L13.104|
                          DCD      0x40004c00
                  |L13.108|
                          DCD      0x40005000

                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=2

                  USART_IrDAConfig PROC
;;;817      */
;;;818    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  b570              PUSH     {r4-r6,lr}
;;;819    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;820      /* Check the parameters */
;;;821      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4913              LDR      r1,|L14.84|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L14.36|
00000c  4912              LDR      r1,|L14.88|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L14.36|
000012  4912              LDR      r1,|L14.92|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L14.36|
000018  4911              LDR      r1,|L14.96|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L14.36|
00001e  4911              LDR      r1,|L14.100|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L14.40|
                  |L14.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L14.42|
                  |L14.40|
000028  2100              MOVS     r1,#0
                  |L14.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;822      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
000030  2d04              CMP      r5,#4
000032  d000              BEQ      |L14.54|
000034  b90d              CBNZ     r5,|L14.58|
                  |L14.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L14.60|
                  |L14.58|
00003a  2100              MOVS     r1,#0
                  |L14.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;823        
;;;824      USARTx->CR3 &= CR3_IRLP_Mask;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71fb          MOV      r1,#0xfffb
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
;;;825      USARTx->CR3 |= USART_IrDAMode;
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  4328              ORRS     r0,r0,r5
000050  82a0              STRH     r0,[r4,#0x14]
;;;826    }
000052  bd70              POP      {r4-r6,pc}
;;;827    
                          ENDP

                  |L14.84|
                          DCD      0x40013800
                  |L14.88|
                          DCD      0x40004400
                  |L14.92|
                          DCD      0x40004800
                  |L14.96|
                          DCD      0x40004c00
                  |L14.100|
                          DCD      0x40005000

                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=2

                  USART_LINBreakDetectLengthConfig PROC
;;;546      */
;;;547    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;548    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;549      /* Check the parameters */
;;;550      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4913              LDR      r1,|L15.84|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L15.36|
00000c  4912              LDR      r1,|L15.88|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L15.36|
000012  4912              LDR      r1,|L15.92|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L15.36|
000018  4911              LDR      r1,|L15.96|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L15.36|
00001e  4911              LDR      r1,|L15.100|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L15.40|
                  |L15.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L15.42|
                  |L15.40|
000028  2100              MOVS     r1,#0
                  |L15.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;551      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
000030  b10d              CBZ      r5,|L15.54|
000032  2d20              CMP      r5,#0x20
000034  d101              BNE      |L15.58|
                  |L15.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L15.60|
                  |L15.58|
00003a  2100              MOVS     r1,#0
                  |L15.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;552      
;;;553      USARTx->CR2 &= CR2_LBDL_Mask;
000042  8a20              LDRH     r0,[r4,#0x10]
000044  f64f71df          MOV      r1,#0xffdf
000048  4008              ANDS     r0,r0,r1
00004a  8220              STRH     r0,[r4,#0x10]
;;;554      USARTx->CR2 |= USART_LINBreakDetectLength;  
00004c  8a20              LDRH     r0,[r4,#0x10]
00004e  4328              ORRS     r0,r0,r5
000050  8220              STRH     r0,[r4,#0x10]
;;;555    }
000052  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP

                  |L15.84|
                          DCD      0x40013800
                  |L15.88|
                          DCD      0x40004400
                  |L15.92|
                          DCD      0x40004800
                  |L15.96|
                          DCD      0x40004c00
                  |L15.100|
                          DCD      0x40005000

                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=2

                  USART_LINCmd PROC
;;;565      */
;;;566    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;567    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;568      /* Check the parameters */
;;;569      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L16.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L16.36|
00000c  4914              LDR      r1,|L16.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L16.36|
000012  4914              LDR      r1,|L16.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L16.36|
000018  4913              LDR      r1,|L16.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L16.36|
00001e  4913              LDR      r1,|L16.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L16.40|
                  |L16.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L16.42|
                  |L16.40|
000028  2100              MOVS     r1,#0
                  |L16.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;570      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L16.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L16.58|
                  |L16.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L16.60|
                  |L16.58|
00003a  2100              MOVS     r1,#0
                  |L16.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;571      
;;;572      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L16.78|
;;;573      {
;;;574        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;575        USARTx->CR2 |= CR2_LINEN_Set;
000044  8a20              LDRH     r0,[r4,#0x10]
000046  f4404080          ORR      r0,r0,#0x4000
00004a  8220              STRH     r0,[r4,#0x10]
00004c  e004              B        |L16.88|
                  |L16.78|
;;;576      }
;;;577      else
;;;578      {
;;;579        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;580        USARTx->CR2 &= CR2_LINEN_Reset;
00004e  8a20              LDRH     r0,[r4,#0x10]
000050  f64b71ff          MOV      r1,#0xbfff
000054  4008              ANDS     r0,r0,r1
000056  8220              STRH     r0,[r4,#0x10]
                  |L16.88|
;;;581      }
;;;582    }
000058  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

00005a  0000              DCW      0x0000
                  |L16.92|
                          DCD      0x40013800
                  |L16.96|
                          DCD      0x40004400
                  |L16.100|
                          DCD      0x40004800
                  |L16.104|
                          DCD      0x40004c00
                  |L16.108|
                          DCD      0x40005000

                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=2

                  USART_OneBitMethodCmd PROC
;;;788      */
;;;789    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;790    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;791      /* Check the parameters */
;;;792      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L17.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L17.36|
00000c  4914              LDR      r1,|L17.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L17.36|
000012  4914              LDR      r1,|L17.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L17.36|
000018  4913              LDR      r1,|L17.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L17.36|
00001e  4913              LDR      r1,|L17.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L17.40|
                  |L17.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L17.42|
                  |L17.40|
000028  2100              MOVS     r1,#0
                  |L17.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L17.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L17.58|
                  |L17.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L17.60|
                  |L17.58|
00003a  2100              MOVS     r1,#0
                  |L17.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;794      
;;;795      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L17.78|
;;;796      {
;;;797        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;798        USARTx->CR3 |= CR3_ONEBITE_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f4406000          ORR      r0,r0,#0x800
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L17.88|
                  |L17.78|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;803        USARTx->CR3 &= CR3_ONEBITE_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f24f71ff          MOV      r1,#0xf7ff
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L17.88|
;;;804      }
;;;805    }
000058  bd70              POP      {r4-r6,pc}
;;;806    
                          ENDP

00005a  0000              DCW      0x0000
                  |L17.92|
                          DCD      0x40013800
                  |L17.96|
                          DCD      0x40004400
                  |L17.100|
                          DCD      0x40004800
                  |L17.104|
                          DCD      0x40004c00
                  |L17.108|
                          DCD      0x40005000

                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=2

                  USART_OverSampling8Cmd PROC
;;;761      */
;;;762    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;763    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4914              LDR      r1,|L18.88|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L18.36|
00000c  4913              LDR      r1,|L18.92|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L18.36|
000012  4913              LDR      r1,|L18.96|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L18.36|
000018  4912              LDR      r1,|L18.100|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L18.36|
00001e  4912              LDR      r1,|L18.104|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L18.40|
                  |L18.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L18.42|
                  |L18.40|
000028  2100              MOVS     r1,#0
                  |L18.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;766      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L18.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L18.58|
                  |L18.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L18.60|
                  |L18.58|
00003a  2100              MOVS     r1,#0
                  |L18.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;767      
;;;768      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L18.78|
;;;769      {
;;;770        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;771        USARTx->CR1 |= CR1_OVER8_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4404000          ORR      r0,r0,#0x8000
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e003              B        |L18.86|
                  |L18.78|
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;776        USARTx->CR1 &= CR1_OVER8_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f3c0000e          UBFX     r0,r0,#0,#15
000054  81a0              STRH     r0,[r4,#0xc]
                  |L18.86|
;;;777      }
;;;778    }
000056  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  |L18.88|
                          DCD      0x40013800
                  |L18.92|
                          DCD      0x40004400
                  |L18.96|
                          DCD      0x40004800
                  |L18.100|
                          DCD      0x40004c00
                  |L18.104|
                          DCD      0x40005000

                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=2

                  USART_ReceiveData PROC
;;;608      */
;;;609    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;610    {
000002  4604              MOV      r4,r0
;;;611      /* Check the parameters */
;;;612      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  490c              LDR      r1,|L19.56|
000006  428c              CMP      r4,r1
000008  d00b              BEQ      |L19.34|
00000a  490c              LDR      r1,|L19.60|
00000c  428c              CMP      r4,r1
00000e  d008              BEQ      |L19.34|
000010  490b              LDR      r1,|L19.64|
000012  428c              CMP      r4,r1
000014  d005              BEQ      |L19.34|
000016  490b              LDR      r1,|L19.68|
000018  428c              CMP      r4,r1
00001a  d002              BEQ      |L19.34|
00001c  490a              LDR      r1,|L19.72|
00001e  428c              CMP      r4,r1
000020  d101              BNE      |L19.38|
                  |L19.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L19.40|
                  |L19.38|
000026  2100              MOVS     r1,#0
                  |L19.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;613      
;;;614      /* Receive Data */
;;;615      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
00002e  88a0              LDRH     r0,[r4,#4]
000030  f3c00008          UBFX     r0,r0,#0,#9
;;;616    }
000034  bd10              POP      {r4,pc}
;;;617    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      0x40013800
                  |L19.60|
                          DCD      0x40004400
                  |L19.64|
                          DCD      0x40004800
                  |L19.68|
                          DCD      0x40004c00
                  |L19.72|
                          DCD      0x40005000

                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=2

                  USART_ReceiverWakeUpCmd PROC
;;;517      */
;;;518    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;520      /* Check the parameters */
;;;521      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4915              LDR      r1,|L20.92|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L20.36|
00000c  4914              LDR      r1,|L20.96|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L20.36|
000012  4914              LDR      r1,|L20.100|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L20.36|
000018  4913              LDR      r1,|L20.104|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L20.36|
00001e  4913              LDR      r1,|L20.108|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L20.40|
                  |L20.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L20.42|
                  |L20.40|
000028  2100              MOVS     r1,#0
                  |L20.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000030  b10d              CBZ      r5,|L20.54|
000032  2d01              CMP      r5,#1
000034  d101              BNE      |L20.58|
                  |L20.54|
000036  2101              MOVS     r1,#1
000038  e000              B        |L20.60|
                  |L20.58|
00003a  2100              MOVS     r1,#0
                  |L20.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;523      
;;;524      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L20.78|
;;;525      {
;;;526        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;527        USARTx->CR1 |= CR1_RWU_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f0400002          ORR      r0,r0,#2
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e004              B        |L20.88|
                  |L20.78|
;;;528      }
;;;529      else
;;;530      {
;;;531        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;532        USARTx->CR1 &= CR1_RWU_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f64f71fd          MOV      r1,#0xfffd
000054  4008              ANDS     r0,r0,r1
000056  81a0              STRH     r0,[r4,#0xc]
                  |L20.88|
;;;533      }
;;;534    }
000058  bd70              POP      {r4-r6,pc}
;;;535    
                          ENDP

00005a  0000              DCW      0x0000
                  |L20.92|
                          DCD      0x40013800
                  |L20.96|
                          DCD      0x40004400
                  |L20.100|
                          DCD      0x40004800
                  |L20.104|
                          DCD      0x40004c00
                  |L20.108|
                          DCD      0x40005000

                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=2

                  USART_SendBreak PROC
;;;624      */
;;;625    void USART_SendBreak(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;626    {
000002  4604              MOV      r4,r0
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  490c              LDR      r1,|L21.56|
000006  428c              CMP      r4,r1
000008  d00b              BEQ      |L21.34|
00000a  490c              LDR      r1,|L21.60|
00000c  428c              CMP      r4,r1
00000e  d008              BEQ      |L21.34|
000010  490b              LDR      r1,|L21.64|
000012  428c              CMP      r4,r1
000014  d005              BEQ      |L21.34|
000016  490b              LDR      r1,|L21.68|
000018  428c              CMP      r4,r1
00001a  d002              BEQ      |L21.34|
00001c  490a              LDR      r1,|L21.72|
00001e  428c              CMP      r4,r1
000020  d101              BNE      |L21.38|
                  |L21.34|
000022  2101              MOVS     r1,#1
000024  e000              B        |L21.40|
                  |L21.38|
000026  2100              MOVS     r1,#0
                  |L21.40|
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       assert_param
;;;629      
;;;630      /* Send break characters */
;;;631      USARTx->CR1 |= CR1_SBK_Set;
00002e  89a0              LDRH     r0,[r4,#0xc]
000030  f0400001          ORR      r0,r0,#1
000034  81a0              STRH     r0,[r4,#0xc]
;;;632    }
000036  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  |L21.56|
                          DCD      0x40013800
                  |L21.60|
                          DCD      0x40004400
                  |L21.64|
                          DCD      0x40004800
                  |L21.68|
                          DCD      0x40004c00
                  |L21.72|
                          DCD      0x40005000

                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=2

                  USART_SendData PROC
;;;591      */
;;;592    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4911              LDR      r1,|L22.76|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L22.36|
00000c  4910              LDR      r1,|L22.80|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L22.36|
000012  4910              LDR      r1,|L22.84|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L22.36|
000018  490f              LDR      r1,|L22.88|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L22.36|
00001e  490f              LDR      r1,|L22.92|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L22.40|
                  |L22.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L22.42|
                  |L22.40|
000028  2100              MOVS     r1,#0
                  |L22.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;596      assert_param(IS_USART_DATA(Data)); 
000030  f5b57f00          CMP      r5,#0x200
000034  da01              BGE      |L22.58|
000036  2101              MOVS     r1,#1
000038  e000              B        |L22.60|
                  |L22.58|
00003a  2100              MOVS     r1,#0
                  |L22.60|
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       assert_param
;;;597        
;;;598      /* Transmit Data */
;;;599      USARTx->DR = (Data & (uint16_t)0x01FF);
000042  f3c50008          UBFX     r0,r5,#0,#9
000046  80a0              STRH     r0,[r4,#4]
;;;600    }
000048  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

00004a  0000              DCW      0x0000
                  |L22.76|
                          DCD      0x40013800
                  |L22.80|
                          DCD      0x40004400
                  |L22.84|
                          DCD      0x40004800
                  |L22.88|
                          DCD      0x40004c00
                  |L22.92|
                          DCD      0x40005000

                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=2

                  USART_SetAddress PROC
;;;475      */
;;;476    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;477    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;478      /* Check the parameters */
;;;479      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4913              LDR      r1,|L23.84|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L23.36|
00000c  4912              LDR      r1,|L23.88|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L23.36|
000012  4912              LDR      r1,|L23.92|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L23.36|
000018  4911              LDR      r1,|L23.96|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L23.36|
00001e  4911              LDR      r1,|L23.100|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L23.40|
                  |L23.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L23.42|
                  |L23.40|
000028  2100              MOVS     r1,#0
                  |L23.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;480      assert_param(IS_USART_ADDRESS(USART_Address)); 
000030  2d0f              CMP      r5,#0xf
000032  dc01              BGT      |L23.56|
000034  2101              MOVS     r1,#1
000036  e000              B        |L23.58|
                  |L23.56|
000038  2100              MOVS     r1,#0
                  |L23.58|
00003a  4608              MOV      r0,r1
00003c  f7fffffe          BL       assert_param
;;;481        
;;;482      /* Clear the USART address */
;;;483      USARTx->CR2 &= CR2_Address_Mask;
000040  8a20              LDRH     r0,[r4,#0x10]
000042  f64f71f0          MOV      r1,#0xfff0
000046  4008              ANDS     r0,r0,r1
000048  8220              STRH     r0,[r4,#0x10]
;;;484      /* Set the USART address node */
;;;485      USARTx->CR2 |= USART_Address;
00004a  8a20              LDRH     r0,[r4,#0x10]
00004c  4328              ORRS     r0,r0,r5
00004e  8220              STRH     r0,[r4,#0x10]
;;;486    }
000050  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      0x40013800
                  |L23.88|
                          DCD      0x40004400
                  |L23.92|
                          DCD      0x40004800
                  |L23.96|
                          DCD      0x40004c00
                  |L23.100|
                          DCD      0x40005000

                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=2

                  USART_SetGuardTime PROC
;;;640      */
;;;641    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  b570              PUSH     {r4-r6,lr}
;;;642    {    
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;643      /* Check the parameters */
;;;644      assert_param(IS_USART_123_PERIPH(USARTx));
000006  490b              LDR      r1,|L24.52|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L24.24|
00000c  490a              LDR      r1,|L24.56|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L24.24|
000012  490a              LDR      r1,|L24.60|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L24.28|
                  |L24.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L24.30|
                  |L24.28|
00001c  2100              MOVS     r1,#0
                  |L24.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;645      
;;;646      /* Clear the USART Guard time */
;;;647      USARTx->GTPR &= GTPR_LSB_Mask;
000024  8b20              LDRH     r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  8320              STRH     r0,[r4,#0x18]
;;;648      /* Set the USART guard time */
;;;649      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
00002a  8b20              LDRH     r0,[r4,#0x18]
00002c  ea402005          ORR      r0,r0,r5,LSL #8
000030  8320              STRH     r0,[r4,#0x18]
;;;650    }
000032  bd70              POP      {r4-r6,pc}
;;;651    
                          ENDP

                  |L24.52|
                          DCD      0x40013800
                  |L24.56|
                          DCD      0x40004400
                  |L24.60|
                          DCD      0x40004800

                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=2

                  USART_SetPrescaler PROC
;;;660      */
;;;661    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  b570              PUSH     {r4-r6,lr}
;;;662    { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  490e              LDR      r1,|L25.64|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L25.36|
00000c  490d              LDR      r1,|L25.68|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L25.36|
000012  490d              LDR      r1,|L25.72|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L25.36|
000018  490c              LDR      r1,|L25.76|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L25.36|
00001e  490c              LDR      r1,|L25.80|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L25.40|
                  |L25.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L25.42|
                  |L25.40|
000028  2100              MOVS     r1,#0
                  |L25.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;665      
;;;666      /* Clear the USART prescaler */
;;;667      USARTx->GTPR &= GTPR_MSB_Mask;
000030  8b20              LDRH     r0,[r4,#0x18]
000032  f400407f          AND      r0,r0,#0xff00
000036  8320              STRH     r0,[r4,#0x18]
;;;668      /* Set the USART prescaler */
;;;669      USARTx->GTPR |= USART_Prescaler;
000038  8b20              LDRH     r0,[r4,#0x18]
00003a  4328              ORRS     r0,r0,r5
00003c  8320              STRH     r0,[r4,#0x18]
;;;670    }
00003e  bd70              POP      {r4-r6,pc}
;;;671    
                          ENDP

                  |L25.64|
                          DCD      0x40013800
                  |L25.68|
                          DCD      0x40004400
                  |L25.72|
                          DCD      0x40004800
                  |L25.76|
                          DCD      0x40004c00
                  |L25.80|
                          DCD      0x40005000

                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardCmd PROC
;;;679      */
;;;680    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;681    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;682      /* Check the parameters */
;;;683      assert_param(IS_USART_123_PERIPH(USARTx));
000006  4912              LDR      r1,|L26.80|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L26.24|
00000c  4911              LDR      r1,|L26.84|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L26.24|
000012  4911              LDR      r1,|L26.88|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L26.28|
                  |L26.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L26.30|
                  |L26.28|
00001c  2100              MOVS     r1,#0
                  |L26.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;684      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L26.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L26.46|
                  |L26.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L26.48|
                  |L26.46|
00002e  2100              MOVS     r1,#0
                  |L26.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;685      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L26.66|
;;;686      {
;;;687        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;688        USARTx->CR3 |= CR3_SCEN_Set;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  82a0              STRH     r0,[r4,#0x14]
000040  e004              B        |L26.76|
                  |L26.66|
;;;689      }
;;;690      else
;;;691      {
;;;692        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;693        USARTx->CR3 &= CR3_SCEN_Reset;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71df          MOV      r1,#0xffdf
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
                  |L26.76|
;;;694      }
;;;695    }
00004c  bd70              POP      {r4-r6,pc}
;;;696    
                          ENDP

00004e  0000              DCW      0x0000
                  |L26.80|
                          DCD      0x40013800
                  |L26.84|
                          DCD      0x40004400
                  |L26.88|
                          DCD      0x40004800

                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardNACKCmd PROC
;;;704      */
;;;705    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;706    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;707      /* Check the parameters */
;;;708      assert_param(IS_USART_123_PERIPH(USARTx));  
000006  4912              LDR      r1,|L27.80|
000008  428c              CMP      r4,r1
00000a  d005              BEQ      |L27.24|
00000c  4911              LDR      r1,|L27.84|
00000e  428c              CMP      r4,r1
000010  d002              BEQ      |L27.24|
000012  4911              LDR      r1,|L27.88|
000014  428c              CMP      r4,r1
000016  d101              BNE      |L27.28|
                  |L27.24|
000018  2101              MOVS     r1,#1
00001a  e000              B        |L27.30|
                  |L27.28|
00001c  2100              MOVS     r1,#0
                  |L27.30|
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       assert_param
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L27.42|
000026  2d01              CMP      r5,#1
000028  d101              BNE      |L27.46|
                  |L27.42|
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L27.48|
                  |L27.46|
00002e  2100              MOVS     r1,#0
                  |L27.48|
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       assert_param
;;;710      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L27.66|
;;;711      {
;;;712        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;713        USARTx->CR3 |= CR3_NACK_Set;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400010          ORR      r0,r0,#0x10
00003e  82a0              STRH     r0,[r4,#0x14]
000040  e004              B        |L27.76|
                  |L27.66|
;;;714      }
;;;715      else
;;;716      {
;;;717        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;718        USARTx->CR3 &= CR3_NACK_Reset;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71ef          MOV      r1,#0xffef
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
                  |L27.76|
;;;719      }
;;;720    }
00004c  bd70              POP      {r4-r6,pc}
;;;721    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      0x40013800
                  |L27.84|
                          DCD      0x40004400
                  |L27.88|
                          DCD      0x40004800

                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;280      */
;;;281    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;282    {
;;;283      /* USART_InitStruct members default value */
;;;284      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;285      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;286      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;287      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;288      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;289      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;290    }
000016  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=2

                  USART_WakeUpConfig PROC
;;;498      */
;;;499    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  b570              PUSH     {r4-r6,lr}
;;;500    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;501      /* Check the parameters */
;;;502      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4914              LDR      r1,|L29.88|
000008  428c              CMP      r4,r1
00000a  d00b              BEQ      |L29.36|
00000c  4913              LDR      r1,|L29.92|
00000e  428c              CMP      r4,r1
000010  d008              BEQ      |L29.36|
000012  4913              LDR      r1,|L29.96|
000014  428c              CMP      r4,r1
000016  d005              BEQ      |L29.36|
000018  4912              LDR      r1,|L29.100|
00001a  428c              CMP      r4,r1
00001c  d002              BEQ      |L29.36|
00001e  4912              LDR      r1,|L29.104|
000020  428c              CMP      r4,r1
000022  d101              BNE      |L29.40|
                  |L29.36|
000024  2101              MOVS     r1,#1
000026  e000              B        |L29.42|
                  |L29.40|
000028  2100              MOVS     r1,#0
                  |L29.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       assert_param
;;;503      assert_param(IS_USART_WAKEUP(USART_WakeUp));
000030  b115              CBZ      r5,|L29.56|
000032  f5b56f00          CMP      r5,#0x800
000036  d101              BNE      |L29.60|
                  |L29.56|
000038  2101              MOVS     r1,#1
00003a  e000              B        |L29.62|
                  |L29.60|
00003c  2100              MOVS     r1,#0
                  |L29.62|
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       assert_param
;;;504      
;;;505      USARTx->CR1 &= CR1_WAKE_Mask;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f24f71ff          MOV      r1,#0xf7ff
00004a  4008              ANDS     r0,r0,r1
00004c  81a0              STRH     r0,[r4,#0xc]
;;;506      USARTx->CR1 |= USART_WakeUp;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  4328              ORRS     r0,r0,r5
000052  81a0              STRH     r0,[r4,#0xc]
;;;507    }
000054  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

000056  0000              DCW      0x0000
                  |L29.88|
                          DCD      0x40013800
                  |L29.92|
                          DCD      0x40004400
                  |L29.96|
                          DCD      0x40004800
                  |L29.100|
                          DCD      0x40004c00
                  |L29.104|
                          DCD      0x40005000
